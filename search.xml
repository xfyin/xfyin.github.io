<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm加载class文件的原理机制分析]]></title>
    <url>%2F2017%2F11%2F21%2Fjvm-classloader%2F</url>
    <content type="text"><![CDATA[案例分析A、B类中均包含静态代码块，非静态代码块以及构造器，A类是B类的父类。1234567891011121314public class A &#123; static &#123; System.out.print("A中静态代码块&gt;&gt;&gt;"); &#125; &#123; System.out.print("A中非静态代码块&gt;&gt;&gt;"); &#125; public A() &#123; System.out.print("A中构造器&gt;&gt;&gt;"); &#125;&#125; 12345678910111213public class B extends A&#123; static &#123; System.out.print("B中静态代码块&gt;&gt;&gt;"); &#125; &#123; System.out.print("B中非静态代码块&gt;&gt;&gt;"); &#125; public B() &#123; System.out.print("B中构造器&gt;&gt;&gt;"); &#125;&#125; 那么看看下面代码的运行结果。1234567public class ABTest &#123; public static void main(String[] args) &#123; A ab = new B(); System.out.println("\n==========================\n"); ab = new B(); &#125;&#125; 执行结果：1234A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt;A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt;==========================A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt; 总结： 同一类中：静态代码块 =&gt; 非静态代码块 =&gt; 构造器 父子类中：父类 =&gt; 子类； 静态代码块只在第一次实例化（new）执行了，非静态代码块在每次实例化都执行。 看执行结果，上面的3条总结都没问题，对于第3点，需要注意下：静态代码块其实不是跟着实例走的，而是跟着类走。看如下测试，通过Class.forName()动态加载类：123public static void main(String[] args) throws ClassNotFoundException &#123; Class.forName("B");&#125; 执行结果：1A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt; 这里并没有执行实例化过程，但是静态代码块却执行了，这也证明了静态static代码块并不是跟着实例走。下面将简单介绍下类加载相关概念及过程，介绍完后再看看上面的例子，印象会更深刻。首先得了解下几个比较重要的JVM的内存概念。 jvm的几个重要内存概念方法区 专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域。 常量池 是方法区的一部分，主要用来存放常量和类中的符号引用等信息。 堆区 用于存放类的对象实例，如new、数组对象。 栈区 由一个个栈帧组成的后进先出的结构，主要存放方法运行时产生的局部变量、方法出口等信息。 java类的生命周期我们编写完一个.java结尾的源文件后，经过编译后生成对应的一个或多个.class后缀结尾的文件。该文件也称为字节码文件，能在java虚拟机中运行。而类的生命周期正是：从类（.class文件）被加载到虚拟机内存，到从内存中卸载为止。整个周期一共分为7个阶段： 加载，验证，准备，解析，初始化，使用，卸载 其中 验证，准备，解析统称为连接； 加载，验证，准备，初始化，卸载，这5个的顺序是确定的。 值得注意的是，通常我们所说的类加载指的是：加载，验证，准备，解析，初始化，这5个阶段。 加载该阶段虚拟机的任务主要是找到需要加载的类，并把类的信息加载到jvm的方法区中，然后堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。 连接连接阶段有三个阶段：验证，准备，解析。主要任务是加载后的验证工作以及一些初始化前的准备工作。 验证当一个类被加载后，需要验证下该类是否合法，以保证加载的类能在虚拟机中正常运行。 准备该阶段主要是为类的静态变量分配内存并设置为jvm默认的初始值；对于非静态变量，则不会为它们分配内存。这里静态变量的初始值，不是由我们指定的，是jvm默认的。 基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0； 引用类型默认值是null； 常量的默认值为我们设定的值。比如我们定义final static int a = 1000，则在准备阶段中a的初始值就是1000。 解析这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，jvm会将所有的类、接口名、字段名、方法名等转换为具体的内存地址。譬如：我们要在内存中找到一个类里面的一个叫call的方法，显然做不到，但是该阶段，由于jvm已经将call这个名字转换为指向方法区中的一块内存地址了，也就是说我们通过call这个方法名会得到具体的内存地址，也就找到了call在内存中的位置了。 初始化有且仅有 5种情况必须立即对类进行“初始化”： 使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已经在编译器把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候； 使用java.lang.reflect包的方法进行反射调用时，若类没有进行初始化，需要先触发其初始化； 当初始化一个类时，若其父类还没有进行初始化，则需要先触发其父类的初始化； 执行main方法，虚拟机会先初始化其包含的那个主类； 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化（这一点不是很懂）。 在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。（这正好解释了案例中第3点结论） 使用初始化阶段的5种情况用了很强烈的限定词：有且仅有，这5种行为称为对一个类进行“主动引用”。其他所有引用类的方法（行为）都不会对类进行初始化，称之为“被动引用”。 《学习深入Java虚拟机》一书中列举了3个被动引用例子，我验证了下，确实如此，不过还得到了新的启发。这里列出其中的2个例子，如下： 例子1：通过子类引用父类的静态字段，不会导致子类初始化123456789package classloading;public class SuperClass &#123; static &#123; System.out.println("SuperClass init!"); &#125; public static int value = 123;&#125; 12345678package classloading;public class SubClass extends SuperClass&#123; static &#123; System.out.println("SubClass init!"); &#125;&#125; 1234567package classloading;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 执行结果：12SuperClass init!123 结论：通过子类SubClass来引用父类SuperClass的静态字段value，初始化的只是父类，并不会触发子类的初始化。 例子2：常量在编译阶段会存入调用类的常量池中，不会触发定义常量的类的初始化123456789package classloading;public class ConstClass &#123; static &#123; System.out.println("ConstClass init!"); &#125; public static final String HELLO_WORLD = "hello world";&#125; 1234567package classloading;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLO_WORLD); &#125;&#125; 执行结果：1hello world 结论：从打印的结果可以看到，并没有初始化ConstClass类；但是从源码上看是引用了ConstClass类的常量。因为在NotInitialization类的编译期中，通过常量优化，已经将常量 &quot;hello world&quot;存储到了NotInitialization类的常量池中了。也就是说，NotInitialization中引用ConstClass.HELLO_WORLD其实是对自身常量池中常量引用。 卸载在使用完类后，需满足下面，类将被卸载： 该类所有的实例都已经被回收，也就是java队中不存在该类的任何实例； 加载该类的ClassLoader已经被回收了； 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 当上面三个条件都满足后，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程本质上就是在方法区中清空类信息，结束整个类的生命周期。 jvm加载class文件的原理机制面试题中经常会问到JVM加载Class文件的原理机制，结合上面的分析，引用下面网上的分析，更加容易理解。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：&nbsp;&nbsp;1)&nbsp;&nbsp;如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；&nbsp;&nbsp;2)&nbsp;&nbsp;如果类中存在初始化语句，就依次执行这些初始化语句。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。 下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈java对象浅度克隆和深度克隆]]></title>
    <url>%2F2017%2F11%2F12%2Fshallow-and-deep-clone%2F</url>
    <content type="text"><![CDATA[需要克隆的原因在工作中我们有时会遇到这样的需求： A对象包含一些有用信息，这时候需要一个和A完全相同的B对象。拿到B对象后，只需要稍微调整下就ok。A和B是两个独立的对象，只是B的初始值来自于A。而A/B对象中包含了比较复杂的数据结构。此时通过简单的赋值，并不能满足这种需求。 我之前做过一个需求： 定时任务——自动新建XX产品：XX产品包含了很多信息，有基本类型数据也有复杂结构对象。已经上线的产品通过修改某些属性值就可以初始化形成新的XX产品，然后等待上线。这里就用到了克隆。 克隆的实现方式浅度克隆首先，定义一个Student类，包含两成员变量：name，age，并且实现Cloneable接口，代码如下：12345678910111213141516171819202122232425262728public class Student implements Cloneable&#123; private String name; private int age; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 再，定义一个Teacher类，也是两字段：一个name，一个聚合对象student，并且实现Cloneable接口，代码如下：12345678910111213141516171819202122232425262728public class Teacher implements Cloneable &#123; private String name; private Student student; public Teacher(String name, Student student) &#123; super(); this.name = name; this.student = student; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125;&#125; 需要clone的类为什么要实现Cloneable接口？我们先看看该接口的源码： 1234567891011121314151617181920212223242526272829package java.lang;/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object's clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; * By convention, classes that implement this interface should override * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method. * See &#123;@link java.lang.Object#clone()&#125; for details on overriding this * method. * &lt;p&gt; * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method. * Therefore, it is not possible to clone an object merely by virtue of the * fact that it implements this interface. Even if the clone method is invoked * reflectively, there is no guarantee that it will succeed. * * @author unascribed * @see java.lang.CloneNotSupportedException * @see java.lang.Object#clone() * @since JDK1.0 */public interface Cloneable &#123;&#125; 这是一个“标示接口”，即：没有任何方法和属性的接口。这个标示仅针对java.lang.Object#clone()方法。注释中：第一段可以看到：我们调用的clone()方法是Obejct类的方法；第二段中：若调用这个Object.clone()方法，但是不实现Cloneable接口(not implement Cloneable)的话，会抛CloneNotSupportedException异常。 我们来测试下，修改Student方法，去掉实现。代码修改如下：123456789public class Student &#123; ... public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student("jack", 27); Student cloneStudent = (Student) student.clone(); &#125;&#125; 执行结果如下：123Exception in thread "main" java.lang.CloneNotSupportedException: clone.Student at java.lang.Object.clone(Native Method) at clone.Student.main(Student.java:38) 第三段中说：按照惯例，对于Object.clone()方法，我们需要是重写。我们看下该方法源码：1protected native Object clone() throws CloneNotSupportedException; 是个native方法，一般来说native方法的效率要高于非native方法，因此比那种new出新对象再把旧对象的信息赋值到新对象的效率要高。该方法还是个protected方法，也就是说外部程序想调用有局限性，因此需要重写修饰符设置为public。 下面再看一个Teacher相关的例子，这里先重写下equals()方法：123456789101112131415161718@Overridepublic boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (this == obj) &#123; return true; &#125; if (obj instanceof Teacher) &#123; Teacher teacher = (Teacher) obj; if (teacher.name == this.name &amp;&amp; teacher.student.equals(this.student)) &#123; return true; &#125; return false; &#125; return false;&#125; 作如下测试：12345678910111213141516public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student("jack", 27); Teacher teacher = new Teacher("Ali", student); System.out.println("Teacher的内存地址：" + teacher); Teacher cloneTeacher = (Teacher) teacher.clone(); System.out.println("克隆Teacher的内存地址：" + cloneTeacher); System.out.println("克隆前后，Teacher对象是否相等：" + teacher.equals(cloneTeacher) + "\n"); System.out.println("++++++我只想修改克隆对象中的Student姓名为‘rose’++++++\n"); cloneTeacher.getStudent().setName("rose"); System.out.println("修改Student姓名后，Teacher的内存地址：" + teacher); System.out.println("修改Student姓名后，克隆Teacher的内存地址：" + cloneTeacher); System.out.println("修改Student姓名后，克隆前后，Teacher对象是否相等：" + teacher.equals(cloneTeacher)); &#125; 执行结果如下：123456789Teacher的内存地址：clone.Teacher@6c89db9a克隆Teacher的内存地址：clone.Teacher@4eb09321克隆前后，Teacher对象是否相等：true++++++我只想修改克隆对象中的Student姓名为‘rose’++++++修改Student姓名后，Teacher的内存地址：clone.Teacher@6c89db9a修改Student姓名后，克隆Teacher的内存地址：clone.Teacher@4eb09321修改Student姓名后，克隆前后，Teacher对象是否相等：true 我们可以看到： 克隆前后，内存地址发生了变化@6c89db9a=&gt;@4eb09321； 克隆前后以及修改了Student对象name属性值，对象没有变化，equals结果为true。 也就是说，不同的引用指向了同一个对象。因此，若我只想修改克隆对象的信息，这种情况下是做不到的。 但是若只是修改基本类型或者String字符串，却能满足需求，只会影响克隆后的对象。譬如：去掉：1cloneTeacher.getStudent().setName("rose"); 并增加：1cloneTeacher.setName("Alice"); equals结果：1修改Student姓名后，克隆前后，Teacher对象是否相等：false 最后别忘了重写下clone方法，修改修饰符为public:1234@Overridepublic Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 深度克隆深度克隆之所以有深度，是弥补了浅度克隆对于对象类型的属性克隆的不足。这里通过对象序列化和反序列化来实现深度克隆。 对象的序列化 把对象转换为字节序列的过程 对象的反序列化： 把字节序列恢复为对象的过程 如何实现：首先新建一个工具类，封装clone方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class CloneUtil &#123; private CloneUtil() &#123;&#125; @SuppressWarnings("unchecked") public static &lt;T extends Serializable&gt; T clone(T obj) &#123; ByteArrayOutputStream baos = null; ObjectOutputStream oos = null; ByteArrayInputStream bais = null; ObjectInputStream ois = null; try &#123; baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(obj); bais = new ByteArrayInputStream(baos.toByteArray()); ois = new ObjectInputStream(bais); return (T) ois.readObject(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException("Class not found.", e); &#125; catch (IOException e) &#123; throw new RuntimeException("Clone Object failed in IO.", e); &#125; finally &#123; try &#123; if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 说明： 调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义。这两个基于内存的流就能够释只要垃圾回收器清理对象放资源，这一点不同于对外部资源（如文件流）的释放。 修改Student代码如下：123456789101112public class Student implements Serializable&#123; private static final long serialVersionUID = 1L; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125; ... &#125; 修改Teacher代码如下：123456789101112public class Teacher implements Serializable &#123; private static final long serialVersionUID = 1L; @Override public String toString() &#123; return "Teacher [name=" + name + ", student=" + student + "]"; &#125; ... &#125; 替换main方法中测试代码：1Teacher cloneTeacher = (Teacher) teacher.clone(); 为序列化-反序列化克隆方法：1Teacher cloneTeacher = CloneUtil.clone(teacher); 执行结果：123456789Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]克隆Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]克隆前后，Teacher对象是否相等：false++++++我只想修改克隆对象中的Student姓名为‘rose’++++++修改Student姓名后，Teacher的的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]修改Student姓名后，克隆Teacher的的toString：Teacher [name=Ali, student=Student [name=rose, age=27]]修改Student姓名后，克隆前后，Teacher对象是否相等：false 明显可以看到，修改Student属性后，对克隆前的对象没有影响。 需要注意：CloneUtil类中的clone()长这样：123public static &lt;T extends Serializable&gt; T clone(T obj) &#123; ...&#125; 基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型&lt;T extends Serializable&gt;限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 当然，若是聚合对象如Teacher中的Student没有实现Serializable接口，还是会在运行时抛异常的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>浅度克隆</tag>
        <tag>深度克隆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射机制基础解析]]></title>
    <url>%2F2017%2F11%2F07%2Freflect-base%2F</url>
    <content type="text"><![CDATA[概念 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. 通俗来讲：反射就是把Class对象的各种成分映射成对应的Java类。 作用java反射机制其实就是将.class转化为.java，也即反编译。具体主要提供了以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法。 后面会围绕这几点具体展开。 重要API在java.lang.reflect包下提供类和接口，以获得关于类和对象的反射信息。这里简单罗列了与反射相关的几个重要的API，真正想学习反射机制，除了在项目中历练，API也是非常重要的手段。英语不好理解的话，就搜搜汉化后的API文档。 变量相关 含义 getField(String name) 返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 方法相关 含义 getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 构造方法相关 含义 getConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法 getConstructors() 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法 getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。 getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法 父类、父接口相关 含义 getInterfaces() 确定此对象所表示的类或接口实现的接口。 getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。 其他重要相关 含义 getModifiers() 以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符。 getName() 以 String 形式返回此 Method 对象表示的方法名称。 getReturnType() 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。 newInstance() 创建此 Class 对象所表示的类的一个新实例。 isInstance(Object obj) 判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。 具体功能实现下面通过例子分别讲述获取Class对象的3种方式，如何创建实例，如何获取构造器，如何获取方法，如何获取属性以及通过反射调用方法。 获取Class对象的3种方式例如新建一个类MyReflectTest，代码如下：123public class MyReflectTest &#123; &#125; 方式1：使用Class类的中静态forName()方法获得与字符串对应的Class对象12345678public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; clz = Class.forName("test.MyReflectTest"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 在数据库有关开发中，我们经常会用到这个方法，例如：1Class.forName("com.mysql.jdbc.Driver") 方式2： 利用对象的class属性123public static void main(String[] args) &#123; Class clz = MyReflectTest.class;&#125; 注意，在基本类型和包装类型中有，例如：1Integer.TYPE 等价于1int.class 是int的Class对象，不等价于1Integer.class 这是Integer的Class对象表示，看看源码就知道了。 方式3：调用对象的getClass()方法1234public static void main(String[] args) &#123; MyReflectTest myReflectTest = new MyReflectTest(); Class clz = myReflectTest.getClass();&#125; 创建实例获取到class对象后，调用newInstance()方法来创建Class对象对应的类实例，测试代码：1234public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Class clz = MyReflectTest.class; MyReflectTest newInstance = (MyReflectTest) clz.newInstance();&#125; 获取构造器获取类的所有构造器，测试代码：1234567891011public static void main(String[] args) &#123; // 获取类对象 Class clz = MyReflectTest.class; // 获取public构造器数组 Constructor[] cons = clz.getConstructors(); // 获取public，默认，protected，private构造器数组 Constructor[] declaredCons = clz.getDeclaredConstructors();&#125; 获取类中指定的某个构造器，测试代码：12345678910111213141516171819202122public MyReflectTest(String name) &#123; super(); this.name = name;&#125;MyReflectTest(String name, int age) &#123; super(); this.name = name; this.age = age;&#125;public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; // 获取public构造器，构造器参数类型为String Constructor con = clz.getConstructor(String.class); // 获取public，默认，protected，private构造器，构造器参数类型为String，int Constructor declaredCon = clz.getDeclaredConstructor(String.class, int.class);&#125; 获取方法新增两个方法:add()和get()。 12345678private void add(String name) &#123; System.out.println(name);&#125;public int get() &#123; System.out.println(age); return age;&#125; getDeclaredMethods()方法相关测试代码：1234567891011121314151617181920public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Method[] declaredMethods = clz.getDeclaredMethods(); for (Method method : declaredMethods) &#123; System.out.println("==============================="); // 访问修饰符 System.out.println(Modifier.toString(method.getModifiers())); // 返回类型 System.out.println(method.getReturnType()); // 方法名称 System.out.println(method.getName()); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (Class&lt;?&gt; param : parameterTypes) &#123; // 方法参数类型 System.out.println(param.getName()); &#125; &#125;&#125; 执行结果：1234567891011121314===============================public staticvoidmain[Ljava.lang.String; //"["表示数组对象===============================privatevoidaddjava.lang.String===============================publicintget 能获取私有的方法add()。看看另一个反射方法：getMethods()，代码和上面一个，基本没变化。测试代码：1234567891011121314151617public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Method[] methods = clz.getMethods(); for (Method method : methods) &#123; System.out.println("+++++++++++++++++++++++++++++++++"); System.out.println(Modifier.toString(method.getModifiers())); System.out.println(method.getReturnType()); System.out.println(method.getName()); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (Class&lt;?&gt; param : parameterTypes) &#123; System.out.println(param.getName()); &#125; &#125;&#125; 执行结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+++++++++++++++++++++++++++++++++public staticvoidmain[Ljava.lang.String;+++++++++++++++++++++++++++++++++publicintget+++++++++++++++++++++++++++++++++public finalvoidwaitlongint+++++++++++++++++++++++++++++++++public final nativevoidwaitlong+++++++++++++++++++++++++++++++++public finalvoidwait+++++++++++++++++++++++++++++++++publicbooleanequalsjava.lang.Object+++++++++++++++++++++++++++++++++publicclass java.lang.StringtoString+++++++++++++++++++++++++++++++++public nativeinthashCode+++++++++++++++++++++++++++++++++public final nativeclass java.lang.ClassgetClass+++++++++++++++++++++++++++++++++public final nativevoidnotify+++++++++++++++++++++++++++++++++public final nativevoidnotifyAll 对比上面的getDeclaredMethods()，少了一个私有的方法add()，但是多了好多不在本类的方法。由于每个类的超类都是Object类，很明显，这些方法都是来自超类，看看源码也能发现这个。也就是说： getDeclaredMethods()获取的是本类的方法，public、默认、protected、private； getMethods()获取的是本类和父类的所有的public的方法。 另外有获取指定某一个方法的反射方法。测试代码：123456789101112public String save(String name, int age) &#123; return "name: " + name + ", age: " + age;&#125;public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; // 第一个参数是“方法名”，后面的是方法的可变参数列表 Method method = clz.getMethod("save", String.class, int.class); System.out.println(Modifier.toString(method.getModifiers()));&#125; 执行结果：1public 其他的类似。 获取属性创建两个成员变量name，age，如下：123public String name;private int age; 测试代码：1234567891011121314151617181920public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Field[] fields = clz.getFields(); for (Field field : fields) &#123; System.out.println("+++++++++++++++++++++++++"); System.out.println(Modifier.toString(field.getModifiers())); System.out.println(field.getType()); System.out.println(field.getName()); &#125; Field[] declaredFields = clz.getDeclaredFields(); for (Field field : declaredFields) &#123; System.out.println("========================="); System.out.println(Modifier.toString(field.getModifiers())); System.out.println(field.getType()); System.out.println(field.getName()); &#125;&#125; 执行结果：123456789101112+++++++++++++++++++++++++publicclass java.lang.Stringname=========================publicclass java.lang.Stringname=========================privateintage 另外getField(String)，getDeclaredField(String)参数为方法名，和Method类似。 调用方法通过上面的一系列操作获取到某一方法后，我们可以利用invoke()方法来调用这个方法。测试代码：12345678910111213141516171819public String save(String name, int age) &#123; return "name: " + name + ", age: " + age;&#125;public static void main(String[] args) throws Exception &#123; // 获取类对象 Class&lt;MyReflectTest&gt; clz = MyReflectTest.class; // 获取对象实例 MyReflectTest reflect = (MyReflectTest) clz.newInstance(); // 获取save方法 Method method = clz.getMethod("save", String.class, int.class); // 第一个参数为对象实例，后面的为方法的参数 Object result = method.invoke(reflect, "jack", 27); System.out.println(result);&#125; 执行结果：1name: jack, age: 27 最后：反射在工作中其实用到的时候并不多，主要用来构建框架。譬如Spring中的IOC也即控制反转，其底层就是利用了反射。以后有时间再整理下这块。反射机制基础到这结束。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态static与非静态non-static(变量、方法、内部类)解析]]></title>
    <url>%2F2017%2F11%2F06%2Fstatic-and-non-static%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。 —— Java编程思想 &nbsp;&nbsp;&nbsp;&nbsp;一句话描述下：方便在对象没有创建的时候调用方法或变量。很显然，static依赖于类，只要类加载了，就可以使用，而不需要等对象实例化后再调用。 下面具体分析下。 变量静态变量 static修饰的变量，也叫类变量； 可以直接用类名.变量调用，也可以用对象名.变量调用； 所有对象的同一个类变量共享同一块内存空间。 实例变量 没有static修饰，也就对象变量； 只能通过对象调用； 所有对象的同一个类变量共享不同内存空间。 总结 静态变量是所有对象共有的，当某一个对象将它的值改变，此时其他对象去获取时，将得到改变后的值，因为它依赖于类； 实例变量是每一个对象私有的，当某一个对象将它的值改变，此时其他对象去获取时，得到的还是改变前的值，因为它依赖具体的实例； 举例静态变量和非静态变量举例代码如下：123456789101112131415161718192021222324252627282930public class StaticTest &#123; static int age = 1; int level = 1; public static void main(String[] args) &#123; System.out.println("静态变量：直接用‘类名.’调用: age = " + StaticTest.age); // 修改静态变量值 StaticTest.age = 2; // 实例化StaticTest对象 StaticTest staticTest = new StaticTest(); System.out.println("静态变量：通过‘实例化后的对象’调用：age = " + staticTest.age); System.out.println("实例变量：只能通过‘实例化后的对象’调用：level = " + staticTest.level); // 修改静态变量值 staticTest.age = 3; // 修改实例变量值 staticTest.level = 2; // 再实例化一个StaticTest对象 StaticTest staticTest1 = new StaticTest(); System.out.println("静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = " + staticTest1.age); System.out.println("实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = " + staticTest1.level); &#125;&#125; 执行结果：12345静态变量：直接用‘类名.’调用: age = 1静态变量：通过‘实例化后的对象’调用：age = 2实例变量：只能通过‘实例化后的对象’调用：level = 1静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = 3实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = 1 结果和前面分析的一致。 方法静态方法 static修饰的方法，属于类； 可以直接用类名.方法名调用，也可以用对象名.方法名调用； 在访问本类成员时，只允许访问静态变量和静态方法，不允许访问实例变量和实例方法； static块也即静态代码块，只能调用静态方法。 实例方法 没有static修饰，属于对象； 只能通过对象调用； 实例方法可以访问实例成员，也可访问静态成员； static块中不能调用实例方法。 举例123456789101112131415161718192021222324252627282930313233343536public class StaticTest &#123; static int age = 1; int level = 1; /** * 非静态方法 */ public void nonStaticMethod() &#123; System.out.println(this.level); System.out.println(age); staticMethod(); &#125; /** * 静态方法 */ public static void staticMethod() &#123; System.out.println(age); // 编译不通过 //System.out.println(level); System.out.println(new StaticTest().level); // 编译不通过 //nonStaticMethod(); new StaticTest().nonStaticMethod(); &#125;&#125; 总结&nbsp;&nbsp;&nbsp;&nbsp;静态方法在类加载时就创建了，但是非静态方法需要实例化后才能创建，因为先类加载，再实例化，所以静态方法中不能直接访问类的成员，只有类实例化后才能访问。 内部类 &nbsp;&nbsp;&nbsp;&nbsp;将一个类的定义放在另一个类的定义内部，就是内部类。 &nbsp;&nbsp;&nbsp;&nbsp;这里只分析普通内部类和静态内部类的区别，具体关于内部类知识暂时请参见详解内部类 普通内部类 不能有静态成员（静态方法，静态变量），否则编译不通过； 可以访问外部类的所有成员（方法，属性）； 实例化内部类方法： &nbsp;&nbsp;&nbsp;&nbsp;1). 先生成一个外部类的对象实例，如：1OutClass o = new OutClass(); &nbsp;&nbsp;&nbsp;&nbsp;2). 通过外部类的对象实例生成内部类对象，如：1OutClass.InnerClass no_static_i = o.new InnerClass(); 静态内部类 可以有静态和非静态成员； 只能访问外部类的静态成员； 实例化一个静态内部类方法： &nbsp;&nbsp;&nbsp;&nbsp;1). 不依赖外部类的实例，直接实例化内部类对象，如：1OutClass.InnerStaticClass static_i = new OutClass.InnerStaticClass(); &nbsp;&nbsp;&nbsp;&nbsp;2). 调用静态内部类的方法或变量，通过类名直接调用，如：12OutClass.InnerStaticClass.static_name;OutClass.InnerStaticClass.getName(); 举例及总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class OutClass &#123; private String outName = "OutClass.outName"; static String staticOutName = "OutClass.staticOutName"; public void getOutName() &#123; System.out.println(outName); System.out.println(staticOutName); &#125; public static void getOutStaticName() &#123; // 编译不通过，静态方法不能访问非静态成员 //System.out.println(outName); System.out.println(staticOutName); &#125; public static void main(String[] args) &#123; // 依赖外部类实例，创建非静态内部类 OutClass o = new OutClass(); OutClass.InnerClass no_static_i = o.new InnerClass(); no_static_i.getInnerName(); // 不依赖外部类实例，直接实例化静态内部类 OutClass.InnerStaticClass static_i = new OutClass.InnerStaticClass(); static_i.getInnerName(); // 通过静态内部类类名直接调用成员变量或方法 System.out.println(OutClass.InnerStaticClass.staticInnerName); OutClass.InnerStaticClass.getStaticInnerName(); &#125; /** * 非静态内部类 */ public class InnerClass &#123; // 编译不通过，普通静态内部类中不能有static变量 //static String staticInnerName = "InnerClass.staticInnerName"; // 编译不通过，普通静态内部类中不能有static方法 //public static void getStaticInnerName() &#123; // System.out.println(staticInnerName); //&#125; String innerName = "InnerClass.innerName"; public void getInnerName() &#123; System.out.println(innerName); // 直接访问外部类成员变量 System.out.println(outName); // 直接访问外部类静态成员变量 System.out.println(staticOutName); &#125; &#125; /** * 静态内部类 */ public static class InnerStaticClass &#123; static String staticInnerName = "InnerStaticClass.staticInnerName"; String innerName = "InnerStaticClass.innerName"; public static void getStaticInnerName() &#123; System.out.println(staticInnerName); &#125; public void getInnerName() &#123; System.out.println(innerName); // 编译不通过，不能直接反问外部类成员变量 //System.out.println(outName); // 只能访问外部类静态成员 System.out.println(staticOutName); &#125; &#125;&#125;]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>静态</tag>
        <tag>非静态</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译小工具：jad常用命令介绍]]></title>
    <url>%2F2017%2F11%2F06%2Fjad-cmd-introduce%2F</url>
    <content type="text"><![CDATA[jad是最简单的字节码.class反编译出源码.java的小工具。是jdk自带的，我的在‪D:\Java\jdk1.7.0_80\bin\jad.exe。 jad常用命令 -o 不提示，覆盖源文件，例如：1jad -o example.class 若当前目录下有example.jad文件（默认扩展名jad），执行该命令后会覆盖原example.jad文件 -s 指定输出文件的类型，例如：1jad -s java example.class 反编译结果以.java为扩展名。 -p 将反编译结果输出到cmd窗口，例如：1jad -p example.class 反编译结果直接在cmd界面显示。 &gt; 将反编译结果重定向到文件，例如：1jad -p example.class &gt; example1.java 在当前目录下，将example.class反编译后输出到example1.java文件中。 -d 指定反编译的输出文件目录，例如：1jad -d test example.class 在当前目录下会产生目录test，里面有example.jad文件 常用命令组合1jad -a -o -s java example.class 用JVM字节码格式来注解输出(-a)； 覆盖原文件（-o）； 以java扩展名输出example文件（-s java） jad帮助信息jad的帮助信息如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Options: //用JVM字节格式来注解输出 -a - generate JVM instructions as comments (annotate) //同 -a,但是注解的时候用全名称 -af - output fully qualified names when annotating //输出多于的括号 (e.g., if(a) &#123; b(); &#125;, default: no) -b - generate redundant braces (braces) //清除所有的前缀 -clear - clear all prefixes, including the default ones //指定输出文件的文件目录 -d &lt;dir&gt; - directory for output files //试图反编译代码的dead 部分(default: no) -dead - try to decompile dead parts of code (if there are any) //不用用字节码的方式反编译 (no JAVA source generated) -dis - disassembler only (disassembler) //输出整个的名字,无论是类还是方法 -f - generate fully qualified names (fullnames) //输出类的成员在方法之前 (default: after methods) -ff - output fields before methods (fieldsfirst) //输出所有的变量的缺省的最初值 -i - print default initializers for fields (definits) //将strings分割成指定数目的块的字符 (default: no) -l&lt;num&gt; - split strings into pieces of max &lt;num&gt; chars (splitstr) //将输出文件用行号来注解 (default: no) -lnc - output original line numbers as comments (lnc) //分割strings用新行字符 newline character (default: no) -nl - split strings on newline characters (splitstr) //不要转换java的定义符 (default: do) -noconv - don&apos;t convert Java identifiers into valid ones (noconv) //不要生成辅助文件 -nocast - don&apos;t generate auxiliary casts //不要生成方法的源代码 -nocode - don&apos;t generate the source code for methods //不允许空的构造器存在 -noctor - suppress the empty constructors //不要去检查class文件是否以dos方式写 (CR before NL, default: check) -nodos - turn off check for class files written in DOS mode //关掉对内部类的支持 (default: turn on) -noinner - turn off the support of inner classes //忽略局部变量的表信息 -nolvt - ignore Local Variable Table entries (nolvt) //不要输出一个新行在打开一个括号之前 (default: do) -nonlb - don&apos;t insert a newline before opening brace (nonlb) //无需确认直接覆盖输出 (default: no) -o - overwrite output files without confirmation //发送反编译代码到标准输出 STDOUT (e.g., for piping) -p - send all output to STDOUT (for piping) //在生成源代码时将所有的包加前缀 -pa &lt;pfx&gt;- prefix for all packages in generated source files //用数字名字给所有的类加前缀 (default: _cls) -pc &lt;pfx&gt;- prefix for classes with numerical names (default: _cls) //给没有用到的异常的名字加前缀 -pe &lt;pfx&gt;- prefix for unused exception names (default: _ex) //用数字名字给所有的成员变量加前缀 (default: _fld) -pf &lt;pfx&gt;- prefix for fields with numerical names (default: _fld) //在&lt;num&gt; 的导入之后将其他引用包裹成一行导入 (default: 3) -pi&lt;num&gt; - pack imports into one line using .* (packimports) //给局部变量用数字名字加前缀 (default: _lcl) -pl &lt;pfx&gt;- prefix for locals with numerical names (default: _lcl) //给方法用数字名字加前缀 (default: _mth) -pm &lt;pfx&gt;- prefix for methods with numerical names (default: _mth) //给方法的参数用数字名字加前缀 (default: _prm) -pp &lt;pfx&gt;- prefix for method parms with numerical names (default:_prm) //将同类型的成员包裹成一行 (default: no) -pv&lt;num&gt; - pack fields with the same types into one line (packfields) //恢复包的目录结构 -r - restore package directory structure //指定输出文件的类型 (by default &apos;.jad&apos;) -s &lt;ext&gt; - output file extension (default: .jad) //遇到关键字(if/for/while/etc)输出空格和表达式 (default: off) -space - output space between keyword (if, while, etc) and expression //显示所有的类，方法，成员变量的总数 -stat - show the total number of processed classes/methods/fields //用 &lt;num&gt;个的空格 (default: 4) -t&lt;num&gt; - use &lt;num&gt; spaces for indentation (default: 4) //用tabs代替空格对于边缘 -t - use tabs instead of spaces for indentation //正在反编译的时候 显示方法的名字 -v - show method names while decompiling //将 UNICODE strings 转换成 8-bit strings，用当前的 ANSI 码页 (Win32 only) -8 - convert Unicode strings into ANSI strings (ansi) //重新定向 STDERR to STDOUT (Win32 only) -&amp; - redirect STDERR to STDOUT]]></content>
      <categories>
        <category>小工具</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>jad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类（abstract class）和接口（interface）解析]]></title>
    <url>%2F2017%2F11%2F05%2Fabstract-and-interface%2F</url>
    <content type="text"><![CDATA[概念抽象类：包含抽象方法的类就称为 抽象类；接口： 抽象方法的集合，方法没有具体实现即不包含方法体。 两者异同相同点 都不能被实例化； 接口的实现类或抽象类的子类都必须实现接口或抽象类中的方法后才能被实例化 不同点 接口中的方法是高度抽象的，只有定义，没有具体的实现；抽象类中可以有定义也可以有实现； 接口中的方法默认为public abstract， 可以直接写public， 可以都省略不写；接口中方法修饰符不能是private， 接口需要实现，所以私有的方法没有意义；抽象类中的具体实现的方法和普通的类一样，而只有定义的方法必须用abstract修饰，不然编译不通过；而且抽象方法的修饰符不能是private，static，synchronized，native，能用默认的，public和protected。 接口中定义变量默认为public static final， 并且要赋予初始值，不然编译不通过；抽象类和普通的类一样，可以有自己的成员变量，可以重新赋值； 接口需要实现（implements）， 抽象类需要继承（extends），一个类可以实现多个接口，但是只能继承一个抽象类（单继承多实现）。 接口三问接口方法能否用private修饰 不能。因为接口是对外开放的，需要具体的类来实现其中的方法，私有的方法作用范围为本类，在接口中定义私有方法没有任何意义，编译不会通过。 接口方法能否用synchronized修饰 不能。synchronized是一种同步锁，在修饰方法时，需要具体逻辑，而接口只是定义，因为直接修饰接口中的方法没意义，可以用来修饰接口方法的具体实现。 接口方法能否用static修饰 这和jdk版本有关。jdk8之前：不能；jdk8新特性： 能。——参见JDK8新特性之接口的静态方法和默认方法 举例这里提供两种方式：jad反编译和反射来获取成员变量和方法的相关内容。 jad反编译下面先给出对应源码，再用jad反编译.class文件。反编译执行命令如下：1jad -a -o -s java 类名.class jad详细命令参见反编译小工具：jad常用命令介绍 接口.java源码MyInterface.java接口源码如下：123456public interface MyInterface &#123; String name = "MyInterface"; void add();&#125; 接口.class反编译MyInterface.class反编译结果如下：123456public interface MyInterface &#123; public abstract void add(); public static final String name = "MyInterface";&#125; 可以看到， 1.在成员变量（常量）中默认的修饰符是public static final;2.在方法中，默认的修饰符是public abstract 抽象类.java源码MyAbstract抽象类源码如下：1234567891011public abstract class MyAbstract &#123; public String name; void get() &#123; System.out.println("MyAbstract get() "); &#125; // 抽象类中的没有实现的方法必须是“abstract” abstract void delete();&#125; 抽象类.class反编译1234567891011121314public abstract class MyAbstract &#123; public MyAbstract() &#123; &#125; void get() &#123; System.out.println("MyAbstract get() "); &#125; abstract void delete(); public String name;&#125; 可以看到，成员方法和成员变量和普通类一样，是什么修饰就是什么。 反射获取这里新建一个MyTest类，继承抽象类MyAbstract，并且实现接口MyInterface 反射代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class MyTest extends MyAbstract implements MyInterface &#123; public static void main(String[] args) &#123; Field[] abstractFields = MyAbstract.class.getDeclaredFields(); Method[] abstractMethods = MyAbstract.class.getDeclaredMethods(); System.out.println("抽象类MyAbstract成员变量反射信息："); for (Field f : abstractFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("抽象类MyAbstract成员方法反射信息："); for (Method m : abstractMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType() + "\n"); &#125; Field[] interfaceFields = MyInterface.class.getDeclaredFields(); Method[] interfaceMethods = MyInterface.class.getDeclaredMethods(); System.out.println(); System.out.println("接口MyInterface成员变量反射信息："); for (Field f : interfaceFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("接口MyInterface成员方法反射信息："); for (Method m : interfaceMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType()); &#125; &#125; @Override public void add() &#123; &#125; @Override void delete() &#123; &#125;&#125; 运行结果1234567891011121314151617181920212223抽象类MyAbstract成员变量反射信息：变量名：name修饰符：public变量类型：class java.lang.String抽象类MyAbstract成员方法反射信息：方法名：get修饰符：返回类型：void方法名：delete修饰符：abstract返回类型：void接口MyInterface成员变量反射信息：变量名：name修饰符：public static final变量类型：class java.lang.String接口MyInterface成员方法反射信息：方法名：add修饰符：public abstract返回类型：void 可以看到，和jad反编译的结果是一样的。 具体的反射机制请参见另一篇博文反射机制基础解析]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk8新特性</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8新特性之接口的静态方法和默认方法]]></title>
    <url>%2F2017%2F11%2F05%2FJDK8-static-and-default%2F</url>
    <content type="text"><![CDATA[JDK8之前我们在接口中定义成员变量只能是public static final的，定义的成员方法只能是public abstract的，默认省略。JDK8前后这一概念等价。定义接口BeforeJDK8Interface如下：name和name1表述等价，getName()和getName1()表述等价。12345678910111213public interface BeforeJDK8Interface &#123; String name = "BeforeJDK8Interface"; //public、 static、 final 可以单独使用，也可以组合使用 public static final String name1 = "BeforeJDK8Interface"; void getName(); //public、 abstract 可以单独使用，也可以组合使用 public abstract void getName1();&#125; JDK8新增特性，允许我们在接口中定义default默认方法和static静态方法。定义接口JDK8Interface如下：1234567891011public interface JDK8Interface &#123; default void myDefaultMethod() &#123; System.out.println("JDK8新特性:接口中的默认方法"); &#125; static void myStaticMethod() &#123; System.out.println("JDK8新特性：接口中的静态方法"); &#125;&#125; 实现接口时，这里static方法由于static的原因，属于接口类，只能通过 接口类名直接调用；而default方法，需要 接口实现类实例化后调用。定义接口实现类JDK8InterfaceImpl如下：12345678public class JDK8InterfaceImpl implements JDK8Interface &#123; public static void main(String[] args) &#123; JDK8Interface.myStaticMethod(); JDK8InterfaceImpl jdk8Interface = new JDK8InterfaceImpl(); jdk8Interface.myDefaultMethod(); &#125;&#125; 由于static的原因，静态方法不能重写；但是default方法却可以，重写myDefaultMethod代码如下：123456789public class JDK8InterfaceImpl implements JDK8Interface &#123; ... @Override public void myDefaultMethod() &#123; System.out.println("接口中的default方法不满足需求，需要重写"); &#125;&#125; 这里稍注意下，JDK8Interface接口中default方法用了修饰符&quot;default&quot;，这里重写后修饰符是&quot;public&quot; 由于java实行的是单继承extends多实现implements，那JDK8新增特性中的两个方法有啥要求不？ 首先看看static方法，由于调用static方法时，用的是接口类名，不能的接口类名肯定不同，所以没影响； 对于default方法， 有于是实现类实例化后调用，若该类有多个接口且接口中有相同名称的default方法，这时候编译器就没办法区分了，会报错，必须重写default方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk8新特性</tag>
        <tag>静态方法</tag>
        <tag>默认方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载（Overload）和重写（Override）解析]]></title>
    <url>%2F2017%2F11%2F02%2Foverload-and-override%2F</url>
    <content type="text"><![CDATA[方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 概念重载Overload 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。 访问修饰符：重载与访问修饰符无关 返回类型： 重载与返回值无关 方法名： 重载方法名需完全一致 参数列表： 重载参数列表需完全不同 重写Override 发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。 访问修饰符：子类的访问修饰符权限 &gt;= 父类的访问修饰符权限 返回类型： 子类的返回类型 &lt;= 父类的返回类型 方法名： 方法名应完全一致 参数列表： 参数列表应完全一致 举例String类重载例子String类的构造器重载：1234567public String() &#123; this.value = new char[0];&#125;public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; String类的valueOf()方法的重载：1234567public static String valueOf(char data[]) &#123; return new String(data); &#125; public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; 重写例子ArrayList继承了AbstractList类1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; AbstractList类中有方法add()：1234public boolean add(E e) &#123; add(size(), e); return true;&#125; ArrayList类中有重写了add()方法：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 多态面向对象编程有三大特性：封装、继承、多态。 概念 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding）多态存在的三个必要条件 1. 要有继承； 2. 要有重写； 3. 父类引用指向子类对象。 根据何时确定执行多态方法中的哪一个，多态分为两种情况：编译时多态和运行时多态。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。 编译时多态重载都是编译时多态，从上面的分析可以看到，只要确定了方法参数的数据类型,个数,次序就能确定调用哪一个方法。 运行时多态重写有两种多态性，当对象引用本类实例，此时为编译时多态，能在编译期确定调用哪个方法；否则为运行时多态。 举例分析123456789101112131415package test;public class Test &#123; &#125;class Animal&#123; public String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String getName() &#123; return "Dog"; &#125;&#125; 1.执行下面的main方法123456public static void main(String[] args) &#123; Animal animal = new Animal(); Dog dog = new Dog(); System.out.println(animal.getName()); System.out.println(dog.getName());&#125; 输出结果：12AnimalDog Animal和Dog引用的都是本类的实例12Animal animal = new Animal();Dog dog = new Dog(); 2.若是这样呢？输入结果是多少1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName());&#125; 此时输出：1Dog 程序在运行时，会从实例所属的类开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照继承关系逐层向上查找，直到超级父类Object类。该例子animal.getName()执行过程是： 3.修改Animal类, 空类12class Animal&#123;&#125; 此时执行方法：1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(((Dog) animal).getName());&#125; 需要显示地转换下((Dog) animal).getName(),因为Animal类中没有定义getName()方法。 4.修改Animal,Dog类的getName()方法为静态方法,并增加一成员变量name1234567891011121314class Animal &#123; public String name = "a"; public static String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String name = "d"; public static String getName() &#123; return "Dog"; &#125; 执行main方法：12345public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName()); System.out.println(animal.name);&#125; 输出结果为：12Animala 结果解释：1.重写只使用于实例方法，不能用于静态方法，对于static方法，只能隐藏,重载,继承；2.在利用引用animal访问对象的属性name或静态方法getName()时，是引用类型决定了实际上访问的是哪个对象（Animal）的成员，而不是当前引用代表的那个类（new Dog()）;由此可知，子类静态方法并不能重写（覆盖）父类的静态方法;故而输出的结果都是父类的成员结果。 为什么不能根据返回类型来区分重载假设下面的重载方法update能编译通过123456789public class Test &#123; public void update() &#123; &#125; public int update() &#123; return 0; &#125;&#125; 当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。方法的返回值,只能作为方法运行之后得一个状态，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的标示。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
        <tag>多态</tag>
        <tag>编译时多态</tag>
        <tag>运行时多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和Integer解析]]></title>
    <url>%2F2017%2F11%2F02%2Fint-and-Integer%2F</url>
    <content type="text"><![CDATA[Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 两个常见的面试例子先看两个常见的例子，后面会针对例子加以分析。例11234567public static void main(String[] args) &#123; Integer a = new Integer(8); Integer b = 8; int c = 8; System.out.println(a == b); System.out.println(a == c); &#125; 1执行结果： false, true 例2 12345public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 250, f4 = 250; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125; 1执行结果： true, false 知识点一：自动拆箱与自动包装概念1.自动拆箱： 自动将包装器类型转换为基本数据类型； 2.自动包装： 自动将基本数据类型转换为包装器类型。 具体分析例1中1234Integer b = 8; //自动装箱//Integer a = new Integer(8);//int c = 8;System.out.println(a == c) // 自动拆箱 注意：Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是intValue()方法。 对例1反编译看看(这里用jad来反编译), Test是例子中的类名。下面命令将输出带字节码注释和源码 -a表示用JVM字节格式来注解输出; -o表示无需确认直接覆盖输出; -s表示定义输出文件的扩展名,默认的扩展名是jad; java表示我们想要的反编译后输出java格式文件 jad详细命令参见反编译小工具：jad常用命令介绍1jad -a -o -s java Test.class 反编译结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package test;import java.io.PrintStream;public class Test &#123; public Test() &#123; // 0 0:aload_0 // 1 1:invokespecial #8 &lt;Method void Object()&gt; // 2 4:return &#125; public static void main(String args[]) &#123; Integer a = new Integer(8); // 0 0:new #16 &lt;Class Integer&gt; // 1 3:dup // 2 4:bipush 8 // 3 6:invokespecial #18 &lt;Method void Integer(int)&gt; // 4 9:astore_1 Integer b = Integer.valueOf(8); // 5 10:bipush 8 // 6 12:invokestatic #21 &lt;Method Integer Integer.valueOf(int)&gt; // 7 15:astore_2 int c = 8; // 8 16:bipush 8 // 9 18:istore_3 System.out.println(a == b); // 10 19:getstatic #25 &lt;Field PrintStream System.out&gt; // 11 22:aload_1 // 12 23:aload_2 // 13 24:if_acmpne 31 // 14 27:iconst_1 // 15 28:goto 32 // 16 31:iconst_0 // 17 32:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; System.out.println(a.intValue() == c); // 18 35:getstatic #25 &lt;Field PrintStream System.out&gt; // 19 38:aload_1 // 20 39:invokevirtual #37 &lt;Method int Integer.intValue()&gt; // 21 42:iload_3 // 22 43:icmpne 50 // 23 46:iconst_1 // 24 47:goto 51 // 25 50:iconst_0 // 26 51:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; // 27 54:return &#125;&#125; 可以看到第20, 22行，调用了Integer方法.valueOf(int)自动装箱：1Integer b = 8; 1Integer b = Integer.valueOf(8); 第36行,调用了Integer方法.intValue()自动拆箱：1System.out.println(a == c); 1System.out.println(a.intValue() == c); 所以：a == c的结果为true 例1中123Integer a = new Integer(8);Integer b = 8;System.out.println(a == b); 结果为何为false？ 刚讲到了1Integer b = 8; 调用了Integer方法.valueOf(int)自动装箱，我们来看下.valueOf(int)源码实现：123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 也就是说最后会new出来一个Integer对象或者返回缓存中的数据。注意： ==符号在比较对象时，比较的是内存地址; 对于原始数据类型(如上面a == c)直接比对的是数据值。 这里又涉及到了堆栈内存了，需要清楚2点： new出来的对象或创建的数组会在堆中开辟内存空间； 对象的引用（即对象在堆内存中的地址，如a）和基本数据类型存储在栈中； 由此可知a,b引用指向的对象不是同一个，所以结果是false 知识点二：Integer缓存在上面的.valueOf(int)源码中我们能看到IntegerCache类，看名称就知道是和缓存有关。我们来看下Integer类的静态内部类IntegerCache源码实现：1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125; 该类中有一个静态数组：1static final Integer cache[]; 还有一个静态代码块:1static &#123;...&#125; 既然是在static静态类的静态代码快中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到静态代码快主要是向静态数组中添加了[-128,127],也就要是说，调用方法.valueOf(int)传入的int值在[-128,127]这个范围内时，直接从IntegerCache的缓存数组中获取， 不会去在堆内存中new。 [-128,127]期间的数字比较常用，这一行为有助于节省内存、提高性能。 12if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; 所以在例2中：1.自动装箱调用方法Integer.valueOf(int)12345678910111213141516171819public static void main(String args[]) &#123; Integer f1 = Integer.valueOf(100); // 0 0:bipush 100 // 1 2:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 2 5:astore_1 Integer f2 = Integer.valueOf(100); // 3 6:bipush 100 // 4 8:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 5 11:astore_2 Integer f3 = Integer.valueOf(250); // 6 12:sipush 250 // 7 15:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 8 18:astore_3 Integer f4 = Integer.valueOf(250); // 9 19:sipush 250 // 10 22:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 11 25:astore 4 &#125; 2.通过Integer.valueOf(int)内部调用IntegerCache类实现。由于f1,f2对应的基本值在[-128,127]之间，结果返回true;而f3,f4对应的基本值不在范围内，结果返回false 其他的包装类型也可以类似分析，回头再总结。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
        <tag>包装类型</tag>
        <tag>自动包装</tag>
        <tag>自动拆箱</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
