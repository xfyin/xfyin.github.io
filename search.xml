<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试题2：重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？]]></title>
    <url>%2F2017%2F11%2F02%2F%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%E9%87%8D%E8%BD%BD%E7%9A%84%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E6%A0%B9%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 概念重载Overload 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。 访问修饰符：重载与访问修饰符无关 返回类型： 重载与返回值无关 方法名： 重载方法名需完全一致 参数列表： 重载参数列表需完全不同 重写Override 发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。 访问修饰符：子类的访问修饰符权限 &gt;= 父类的访问修饰符权限 返回类型： 子类的返回类型 &lt;= 父类的返回类型 方法名： 方法名应完全一致 参数列表： 参数列表应完全一致 举例String类重载例子String类的构造器重载：1234567public String() &#123; this.value = new char[0];&#125;public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; String类的valueOf()方法的重载：1234567public static String valueOf(char data[]) &#123; return new String(data); &#125; public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; 重写例子ArrayList继承了AbstractList类1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; AbstractList类中有方法add()：1234public boolean add(E e) &#123; add(size(), e); return true;&#125; ArrayList类中有重写了add()方法：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 多态面向对象编程有三大特性：封装、继承、多态。 概念 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding）多态存在的三个必要条件 1. 要有继承； 2. 要有重写； 3. 父类引用指向子类对象。 根据何时确定执行多态方法中的哪一个，多态分为两种情况：编译时多态和运行时多态。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。 编译时多态重载都是编译时多态，从上面的分析可以看到，只要确定了方法参数的数据类型,个数,次序就能确定调用哪一个方法。 运行时多态重写有两种多态性，当对象引用本类实例，此时为编译时多态，能在编译期确定调用哪个方法；否则为运行时多态。 举例分析123456789101112131415package test;public class Test &#123; &#125;class Animal&#123; public String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String getName() &#123; return "Dog"; &#125;&#125; 1.执行下面的main方法123456public static void main(String[] args) &#123; Animal animal = new Animal(); Dog dog = new Dog(); System.out.println(animal.getName()); System.out.println(dog.getName());&#125; 输出结果：12AnimalDog Animal和Dog引用的都是本类的实例12Animal animal = new Animal();Dog dog = new Dog(); 2.若是这样呢？输入结果是多少1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName());&#125; 此时输出：1Dog 程序在运行时，会从实例所属的类开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照继承关系逐层向上查找，直到超级父类Object类。该例子animal.getName()执行过程是： 3.修改Animal类, 空类12class Animal&#123;&#125; 此时执行方法：1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(((Dog) animal).getName());&#125; 需要显示地转换下((Dog) animal).getName(),因为Animal类中没有定义getName()方法。 4.修改Animal,Dog类的getName()方法为静态方法,并增加一成员变量name1234567891011121314class Animal &#123; public String name = "a"; public static String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String name = "d"; public static String getName() &#123; return "Dog"; &#125; 执行main方法：12345public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName()); System.out.println(animal.name);&#125; 输出结果为：12Animala 结果解释：1.重写只使用于实例方法，不能用于静态方法，对于static方法，只能隐藏,重载,继承；2.在利用引用animal访问对象的属性name或静态方法getName()时，是引用类型决定了实际上访问的是哪个对象（Animal）的成员，而不是当前引用代表的那个类（new Dog()）;由此可知，子类静态方法并不能重写（覆盖）父类的静态方法;故而输出的结果都是父类的成员结果。 为什么不能根据返回类型来区分重载假设下面的重载方法update能编译通过123456789public class Test &#123; public void update() &#123; &#125; public int update() &#123; return 0; &#125;&#125; 当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。方法的返回值,只能作为方法运行之后得一个状态，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的标示。]]></content>
      <categories>
        <category>面试题分析</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
        <tag>多态</tag>
        <tag>编译时多态</tag>
        <tag>运行时多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题1：int和Integer有什么区别？]]></title>
    <url>%2F2017%2F11%2F02%2F%E9%9D%A2%E8%AF%95%E9%A2%981%EF%BC%9Aint%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 两个常见的面试例子先看两个常见的例子，后面会针对例子加以分析。例11234567public static void main(String[] args) &#123; Integer a = new Integer(8); Integer b = 8; int c = 8; System.out.println(a == b); System.out.println(a == c); &#125; 1执行结果： false, true 例2 12345public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 250, f4 = 250; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125; 1执行结果： true, false 知识点一：自动拆箱与自动包装概念1.自动拆箱： 自动将包装器类型转换为基本数据类型； 2.自动包装： 自动将基本数据类型转换为包装器类型。 具体分析例1中1234Integer b = 8; //自动装箱//Integer a = new Integer(8);//int c = 8;System.out.println(a == c) // 自动拆箱 注意：Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是intValue()方法。 对例1反编译看看(这里用jad来反编译), Test是例子中的类名。下面命令将输出带字节码注释和源码 -a表示用JVM字节格式来注解输出; -o表示无需确认直接覆盖输出; -s表示定义输出文件的扩展名,默认的扩展名是jad; java表示我们想要的反编译后输出java格式文件 1jad -a -o -s java Test.class 反编译结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package test;import java.io.PrintStream;public class Test &#123; public Test() &#123; // 0 0:aload_0 // 1 1:invokespecial #8 &lt;Method void Object()&gt; // 2 4:return &#125; public static void main(String args[]) &#123; Integer a = new Integer(8); // 0 0:new #16 &lt;Class Integer&gt; // 1 3:dup // 2 4:bipush 8 // 3 6:invokespecial #18 &lt;Method void Integer(int)&gt; // 4 9:astore_1 Integer b = Integer.valueOf(8); // 5 10:bipush 8 // 6 12:invokestatic #21 &lt;Method Integer Integer.valueOf(int)&gt; // 7 15:astore_2 int c = 8; // 8 16:bipush 8 // 9 18:istore_3 System.out.println(a == b); // 10 19:getstatic #25 &lt;Field PrintStream System.out&gt; // 11 22:aload_1 // 12 23:aload_2 // 13 24:if_acmpne 31 // 14 27:iconst_1 // 15 28:goto 32 // 16 31:iconst_0 // 17 32:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; System.out.println(a.intValue() == c); // 18 35:getstatic #25 &lt;Field PrintStream System.out&gt; // 19 38:aload_1 // 20 39:invokevirtual #37 &lt;Method int Integer.intValue()&gt; // 21 42:iload_3 // 22 43:icmpne 50 // 23 46:iconst_1 // 24 47:goto 51 // 25 50:iconst_0 // 26 51:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; // 27 54:return &#125;&#125; 可以看到第20, 22行，调用了Integer方法.valueOf(int)自动装箱：1Integer b = 8; 1Integer b = Integer.valueOf(8); 第36行,调用了Integer方法.intValue()自动拆箱：1System.out.println(a == c); 1System.out.println(a.intValue() == c); 所以：a == c的结果为true 例1中123Integer a = new Integer(8);Integer b = 8;System.out.println(a == b); 结果为何为false？ 刚讲到了1Integer b = 8; 调用了Integer方法.valueOf(int)自动装箱，我们来看下.valueOf(int)源码实现：123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 也就是说最后会new出来一个Integer对象或者返回缓存中的数据。注意： ==符号在比较对象时，比较的是内存地址; 对于原始数据类型(如上面a == c)直接比对的是数据值。 这里又涉及到了堆栈内存了，需要清楚2点： new出来的对象或创建的数组会在堆中开辟内存空间； 对象的引用（即对象在堆内存中的地址，如a）和基本数据类型存储在栈中； 由此可知a,b引用指向的对象不是同一个，所以结果是false 知识点二：Integer缓存在上面的.valueOf(int)源码中我们能看到IntegerCache类，看名称就知道是和缓存有关。我们来看下Integer类的静态内部类IntegerCache源码实现：1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125; 该类中有一个静态数组：1static final Integer cache[]; 还有一个静态代码块:1static &#123;...&#125; 既然是在static静态类的静态代码快中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到静态代码快主要是向静态数组中添加了[-128,127],也就要是说，调用方法.valueOf(int)传入的int值在[-128,127]这个范围内时，直接从IntegerCache的缓存数组中获取， 不会去在堆内存中new。 [-128,127]期间的数字比较常用，这一行为有助于节省内存、提高性能。 12if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; 所以在例2中：1.自动装箱调用方法Integer.valueOf(int)12345678910111213141516171819public static void main(String args[]) &#123; Integer f1 = Integer.valueOf(100); // 0 0:bipush 100 // 1 2:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 2 5:astore_1 Integer f2 = Integer.valueOf(100); // 3 6:bipush 100 // 4 8:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 5 11:astore_2 Integer f3 = Integer.valueOf(250); // 6 12:sipush 250 // 7 15:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 8 18:astore_3 Integer f4 = Integer.valueOf(250); // 9 19:sipush 250 // 10 22:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 11 25:astore 4 &#125; 2.通过Integer.valueOf(int)内部调用IntegerCache类实现。由于f1,f2对应的基本值在[-128,127]之间，结果返回true;而f3,f4对应的基本值不在范围内，结果返回false 其他的包装类型也可以类似分析，回头再总结。]]></content>
      <categories>
        <category>面试题分析</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
        <tag>包装类型</tag>
        <tag>自动包装</tag>
        <tag>自动拆箱</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
