<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何使用Maven搭建SpringMVC项目]]></title>
    <url>%2F2017%2F12%2F23%2Fmaven-and-springmvc%2F</url>
    <content type="text"><![CDATA[创建一个Maven Project右键 -&gt; New -&gt; Other... -&gt; 搜索‘maven’ -&gt; 选择‘Maven Project’ -&gt; Next 创建一个简单项目勾选：Create a simple project（自动创建约定的项目目录结构，即不使用骨架）-&gt; Next 确定唯一标示填写如截图中的内容 -&gt; Nex -&gt; Finish Group id: 组织id，域名倒写； Artifact id：项目、模块id； Version： 版本； Packaging: 该元素决定了项目的打包方式，有3种，jar，war，pom（比如是一个父模块）；Maven为jar项目调用了maven-jar-plugin，为war项目调用了maven-war-plugin，换言之，packaging直接影响Maven的构建生命周期 由于packing是war包，那么下面也就多出了webapp的目录 转换为dynamic web project由于我们的项目要使用eclipse发布到tomcat下面，这里我们需要先把项目转成 dynamic web project。在我们的项目上点击 右键，选择 Properties 并找到 Project Facets ，并点击Convert to faceted form... 将maven项目转换为Dynamic Web项目，勾选 Dynamic Web Module， 并点击 Further configuration available... 勾选生成web项目需要的部署描述符文件 web.xml， 然后点击 OK -&gt; OK 接下来观察我们的项目结构，多了一个WebContent目录 META-INF相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。MANIFEST.MF文件，在用jar打包时自动生成。 转为标准的Maven项目结构虽然此时我们可以发布到tomcat中，但这不符合maven的结构，“约定优于配置”，转为标准的maven项目结构。我们还要做如下修改：把上图 WebContent 下面两个目录 META-INF，WEB-INF 直接剪切到 src/main/webapp 目录下，并删掉 WebContent 目录，那么现在的项目结构如下图： 修改发布规则需要修改发布规则，右键点击项目，选择 Properties ， 选择 Deployment Assembly 选择 WebContent，把它 Remove 测试类我们也不需要发布， test 的两个目录页可以 Remove 因为是基于Maven项目，需要把Maven依赖库也添加到发布路径，点击 Add ， 选择 Java Build Path Entries, Next，选择 Maven Dependencies， Finish， OK 此处列表是，部署项目时，文件发布的路径 至此一个基于maven的webapp就建立好了，并可以直接从eclipse中发布到tomcat中。 导入我们的Spring MVC依赖jar包在 pom.xml 文件中写入下面的依赖，maven会自动为我们下载需要依赖的jar包，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;artifactId&gt;springmvc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 集中定义依赖版本号 --&gt; &lt;properties&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-net.version&gt;3.3&lt;/commons-net.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jsp-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Apache工具组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-net.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 此时工程目录下多了 Maven Dependencies 库 在上面的步骤中，我们在 pom.xml 文件中加入了好多东西，简单说说。12345678910&lt;!-- 集中定义依赖版本号 --&gt;&lt;properties&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-net.version&gt;3.3&lt;/commons-net.version&gt;&lt;/properties&gt; 在大型项目或者比较复杂的项目，例如聚合项目中，为了统一规定版本号，可以在父类工程中集中定义依赖版本号，这样在子类工程中就不许要考虑版本号问题了。从这里也可以看出该文件中有3大类依赖，spring，jsp以及工具类。 123456&lt;!-- Spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 在 &lt;properties&gt; 节点中集中定义了依赖版本号后，具体的依赖中就可以如上面直接用花括号的形式引用版本号了，当然要是再父类工程定义了版本号，子类想要用父类定义好的版本号，需要引入父类工程，如12345&lt;parent&gt; &lt;artifactId&gt;springmvc-parent&lt;/artifactId&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; 后面的 build 节点中集成了Tomcat7 插件，这样在运行项目时，只需要 项目右键 -&gt; Run as -&gt; Run Configurations...， 在 Goals 中填入 tomcat7:run 就可以自动部署项目到tomcat下运行了。123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 根据部署描述符(web.xml)中的默认欢迎页面，我们在webapp下新建一个 index.jsp 页面123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 项目右键 -&gt; Run as -&gt; Run Configurations...， 在 Goals 中填入 tomcat7:run，单击 Run，项目运行。控制台中会输出下面的信息123[INFO] Running war on http://localhost:8081/[INFO] Creating Tomcat server configuration at D:\workspace_springmvc\springmvc\target\tomcat[INFO] create webapp with contextPath: 在浏览器中输入 http://localhost:8081，回车 自此，基于maven搭建的web项目能正常访问了。我们再看下项目结构，多了个 target 文件夹，这个是哪来的？ 如图可知，java编译后的字节码文件就存在 target/classes 下 下一步，就是集成SpringMVC。 集成SpringMVC我们在 在src/main/java 下新建包：控制层（mvc.controller），业务逻辑层（mvc.service），数据访问层（mvc.dao），还有实体层（mvc.entity）； 在src/main/resources下新建spingmvc所需要的配置文件/mvc/config/springmvc.xml； 在WEB-INF下新建文件夹: css，js，jsp，用于存放资源文件和页面等 在部署描述符（web.xml）中，我们加入如下内容 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc/config/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 拦截所有的请求，包括WEB-INF下资源文件请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 在新建的 springmvc.xml 文件中，我们需要加入下面的内容： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- spring基于扫描机制找到应用程序中所有基于注解的控制器类和业务逻辑层 --&gt; &lt;context:component-scan base-package="mvc.controller" /&gt; &lt;context:component-scan base-package="mvc.service" /&gt; &lt;!-- 由于在`web.xml`中，会拦截所有的请求'/'，包括 `WEB-INF`下的资源文件：css，js等，而在`WEB-INF` 下的文件又不能直接访问，这里需要特殊处理下--&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:resources location="/WEB-INF/css/" mapping="/css/**"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources location="/WEB-INF/js/" mapping="/js/**"&gt;&lt;/mvc:resources&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 下面是一系列源码，很简单，就不解说了，文章最后附有完整的项目工程。实体类 Book.java1234567891011121314151617181920212223public class Book implements Serializable &#123; private static final long serialVersionUID = 1520961851058396786L; private long id; private String isbn; private String title; private Category category; private String author; public Book() &#123; &#125; public Book(long id, String isbn, String title, Category category, String author) &#123; this.id = id; this.isbn = isbn; this.title = title; this.category = category; this.author = author; &#125; // getter and setter&#125; 实体类 Category.java123456789101112131415public class Category implements Serializable &#123; private static final long serialVersionUID = 5658716793957904104L; private int id; private String name; public Category() &#123; &#125; public Category(int id, String name) &#123; this.id = id; this.name = name; &#125; // getter and setter&#125; 这里忽略数据访问层DAO业务逻辑层接口类 BookService.java12345678910public interface BookService &#123; List&lt;Category&gt; getAllCategories(); Category getCategory(int id); List&lt;Book&gt; getAllBooks(); Book save(Book book); Book update(Book book); Book get(long id); long getNextId();&#125; 业务逻辑层接口实现类 BookServiceImpl.java1234567891011121314151617181920212223242526272829303132333435@Servicepublic class BookServiceImpl implements BookService &#123; /* * this implementation is not thread-safe */ private List&lt;Category&gt; categories; private List&lt;Book&gt; books; public BookServiceImpl() &#123; categories = new ArrayList&lt;Category&gt;(); Category category1 = new Category(1, "Computing"); Category category2 = new Category(2, "Travel"); Category category3 = new Category(3, "Health"); categories.add(category1); categories.add(category2); categories.add(category3); books = new ArrayList&lt;Book&gt;(); books.add(new Book(1L, "9780980839623", "Servlet &amp; JSP: A Tutorial", category1, "Budi Kurniawan")); books.add(new Book(2L, "9780980839630", "C#: A Beginner's Tutorial", category1, "Jayden Ky")); &#125; @Override public List&lt;Book&gt; getAllBooks() &#123; return books; &#125; ...&#125; 最后控制层类 BookController.java1234567891011121314151617@Controllerpublic class BookController &#123; @Autowired private BookService bookService; private static final Log logger = LogFactory.getLog(BookController.class); @RequestMapping(value = "/book_list") public String listBooks(Model model) &#123; logger.info("book_list"); List&lt;Book&gt; books = bookService.getAllBooks(); model.addAttribute("books", books); return "BookList"; &#125; ...&#125; 页面 BookList.jsp12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Book List&lt;/title&gt;&lt;style type="text/css"&gt;@IMPORT url("./css/main.css");&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="global"&gt; &lt;h1&gt;Book List&lt;/h1&gt; &lt;a href="&lt;c:url value='/book_input'/&gt;"&gt;Add Book&lt;/a&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Category&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;ISBN&lt;/th&gt; &lt;th&gt;Author&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;books&#125;" var="book"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.category.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.title &#125;&lt;/td&gt; &lt;td&gt;$&#123;book.isbn &#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="book_edit/$&#123;book.id &#125;"&gt;Edit&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由于我在pom.xml 文件中配置的 项目访问路径是 “/”，所以直接在浏览器中输入：1http://localhost:8081/book_list 自此，用Maven搭建SpringMVC项目就讲完了，还有很多细节需要处理，需要不断学习。 完整工程下载链接：https://pan.baidu.com/s/1hrQdCwc 密码：kifh]]></content>
      <categories>
        <category>spring</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven入门介绍]]></title>
    <url>%2F2017%2F12%2F16%2Fintroduction-to-maven%2F</url>
    <content type="text"><![CDATA[项目依赖管理在项目合作开的时，我们是如何进行项目依赖管理的呢？我们通常会在新建项目的时候，同时建立一个lib目录，在其中放着项目所依赖的各方类库，这样提交到SVN之后， 每个开发人员检出项目到本地，得到项目的工作副本，这样所有开发人员就会持有统一的项目依赖了。这样有2个比较明显的问题。 管理中的问题依赖冗余随着项目的增多，模块的增多，这种方式就会有问题。很多模块都会引用相同的依赖，当每个模块都把自己的依赖提交到SVN，那么相同的依赖就会占用服务器SVN的Repository很大的空间，造成空间浪费。 版本问题同时，如果一个项目中依赖的版本和另一个项目依赖的版本不一致。比如这个项目依赖hibernate2.x，而另一个可能依赖hibernate3.x， 当合并两个项目发布的时候， 可能因为这种依赖类库详细版本信息的缺失，造成问题。 解决办法为了解决以上依赖管理过程中出现的问题以及我们项目中遇到的其他类似问题， 我们寻求出一途径：各个项目只要通过统一的依赖描述文件（pom.xml）来指定自己需要的依赖就可以， 而不用自己来管理真正的依赖库，因为所有的项目都使用同一个中央依赖库(中央仓库)， 所以即使各个项目中有相同的依赖， 也不会出现依赖冗余的问题。Maven正是我们寻求的，能解决此问题的工具。 Maven是什么基本概念Maven是基于POM(project object model，即项目对象模型)的跨平台的项目管理工具，主要服务于基于JAVA平台的项目构建，依赖管理和项目信息管理。 项目构建清理、编译、测试、报告、打包、部署； 依赖管理自动下载，统一依赖管理； 信息管理项目名称描述，开发人员信息，开发者信息。 PS: 测试报告存放在target文件夹下。 优势如果没有Maven，你可能不得不经历下面的过程： 使用jar包时，需要去官网下载，譬如：如果使用了spring，去spring的官网下载jar包； 当某些jar包有依赖的时候，还要去下载对应的依赖jar包； 当jar包依赖有冲突时，不得不一个一个的排查； 执行构建时，需要使用ant写出很多重复的任务代码； 当新人加入开发时，需要拷贝大量的jar包，然后重复进行构建。 而maven的优势就是： 项目jar包的依赖管理：仅仅通过jar包的几个属性，就能确定唯一的jar包，在指定的文件pom.xml中，只要写入这些依赖属性，就会自动下载并管理jar包； 项目自动化编译部署：清理—&gt;编译—&gt;测试—&gt;打包—&gt;部署； 项目的插件管理。 Maven的配置文件如果使用过Ant都知道Ant是通过build.xml执行构建任务的，Maven中是通过pom.xml来执行任务.POM，project object model，即项目对象模型，它通过这个pom.xml 描述一个项目的构建以及信息。1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.h3c&lt;/groupId&gt; &lt;artifactId&gt;mavenLearning&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;xxxx&lt;/name&gt; &lt;packaging&gt;war&lt;/packaging&gt;&lt;/project&gt; 第一行指定了文档的XML版本和编码;第二行即每个pom.xml的核心元素——project;project下面有几个子元素，这几个子元素一般是每个项目都会使用到的： modelVersion这个元素指定了POM的版本（Maven2或者Maven3 都只能是4.0.0）； groupId 是项目组的ID，一般是com.公司组织名.项目名； artifactId 是该项目在项目组中ID，比如当前的项目是项目组的一个服务链项目，就可以叫做serviceChain； version 是项目的版本号，用于维护项目的升级和发布； name 一般没有实际的用处，只是用于标识该项目； packaging项目打包方式，常有jar，war，pom等，缺省下为jar比较重要的参数是 groupId、artifactId、version，这三个属性确定唯一的一个项目。 Maven如何管理jar包Jar包坐标关于jar包的坐标，maven是通过groupId，artifactId，以及version确定一个唯一的jar包。例如，最常使用的Junit的声明就是如下：123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;scope&gt;这是声明的范围，不同的生命周期所要求的范围是不一样的。 Maven仓库在Maven中会涉及到几种仓库： 工作空间，即我们的项目工程，这里面放着pom.xml文件，这个pom.xml就是maven的配置文件； 本地仓库，本地仓库用于存放jar包，其实Jar包并不是直接放入工作空间的，它是存放在本地仓库，然后在执行发布打包的时候，添加依赖路径； 私库：私库是使用者自己搭建的maven仓库，用于缓解频繁从外网下载jar包资源的压力。而且使用私库作为缓存层，也相对安全一些； 共享仓库：一般所说的中央仓库或者一些常用的镜像网站都属于这种，国内比较著名的oschina以及163都是不错的maven仓库。 Maven下载jar包的过程当我们在pom中声明了依赖关系后，参考上面的图： Maven在执行相关的任务时，会先去本地仓库查看是否有该资源，如果有的话，判断版本是否正确，如果一切都没问题则直接使用；否则，执行下一步； Maven会去配置的共享仓库中查找，如果找到就拷贝到本地仓库中；找不到则会给出相关的提示； Maven在本地如果搭建了私库，则会去私库中查找，找到就拷贝到本地仓库；找不到就会去共享仓库中查找，然后放入私库和本地库。有了私库，局域网内的开发者可以共享依赖，就不用每个人都去外网下载jar包，浪费带宽了。 Maven的目录结构介绍 bin：该目录下同JDK一样，主要是Maven的运行脚本，这些脚本用来配置Java命令，准备好classpath和相关Java系统属性，然后执行Java命令。mvn.bat是基于Windows的脚本。在CMD中每次输入一条MVN的命令都是在调用并执行这些脚本。该目录还有一个文件名为m2.conf，它是classworlds的配置文件。boot：该目录只有一个文件plexus-classworlds-2.5.1.jar。他是一个类加载器的框架，相对于JDK中的类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架架在自己的类库。conf：该目录包含了一个非常重要的文件setting.xml。配置该文件就能在Project中定制Maven的行为。lib：包含了所有Maven运行时需要的Java类库以及用到的第三方以来。LICENSE：记录了Maven的软件许可证。NOTICE.txt：记录了Maven所包含的第三方软件。README.txt：包含了Maven的简介以及简要指令等. 代理配置我们没有搭建私服（私库），Maven工程需要的jar包需要联网下载，在setting.xml配置文件中配置代理，即可下载需要的jar包。123456789101112&lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;xxxx&lt;/username&gt; &lt;password&gt;xxxx&lt;/password&gt; &lt;host&gt;xxx&lt;/host&gt; &lt;port&gt;xxx&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt;&lt;/proxies&gt; 在&lt;settings&gt;标签中添加如上代码，说明如下： proxies中可以配置多个proxy，但是默认第一个proxy生效。 active中的TRUE表示该代理目前生效状态。 http协议、主机地址、端口不在赘述。 用户名密码按需配置即可。 nonProxyHost表示不需要代理访问的地址。中间的竖线分隔多个地址，此处可以使用星号作为通配符号。 本地仓库配置本地仓库，顾名思义，就是Maven在本地存储构件的地方。注：maven的本地仓库，在安装maven后并不会创建，它是在第一次执行maven命令的时候才被创建maven本地仓库的默认位置：无论是Windows还是Linux，在用户的目录下都有一个.m2/repository/的仓库目录，这就是Maven仓库的默认位置如何更改maven默认的本地仓库的位置：这里要引入一个新的元素：localRepository。1&lt;localRepository&gt;E:\MAVEN&lt;/localRepository&gt; 远程仓库配置远程仓库中最核心的中央仓库（还有私服和其它公共库），中央仓库是默认的远程仓库，maven在安装的时候，自带的就是中央仓库的配置。所有的maven项目都会继承超级pom，具体的说，包含了下面配置的pom我们就称之为超级pom。中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; Maven的生命周期及阶段生命周期Maven中有三大生命周期，他们相互独立，分别是： clean 清理； default 构建； site 建站； 一般来说，clean和default比较常用。 阶段每个生命周期又有不同的阶段，阶段按顺序执行，并且可以指定执行结束的阶段。构建的时候，会依次从最上面的阶段执行到指定的那个阶段。比如，clean有3个阶段： pre-clean 执行清理前要完成的工作 clean 清理上一次构建生成的文件 post-clean 执行清理后需要完成的工作 当我们输入mvn clean的时候，执行的是pre-clean和clean两个阶段。 default的阶段比较多： validate initialize generate-sources process-sources generate-resources process-resources compile process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile process-test-classes tet prepare-package package pre-integration-test integration-test post-integration-test verify install deploy 看名字大概就能理解，当执行mvn install的时候，实际会执行validate -&gt; initialize -&gt;… -&gt; verify-&gt; install等二十几个阶段。为了操作方便，不同的生命周期可以在一起执行，比如mvn clean install，会先执行clean的阶段，再执行install的阶段。在IDE开发环境中，当我们Run as的时候，就可以执行maven clean进行清理，或者执行maven install进行构建，也可以执行maven build同时执行clean和install两个任务. Maven工程结构介绍一般的Maven项目会包含这样一个目录树： project|-src–main–java–你的源代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–main–resource：资源文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–test–java–单元测试代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–test– resource–单元测试代码相关资源文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–target–编译出的文件和jar包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–pom.xml–项目信息以及任务定义 “约定优于配置（Convention over Configuration）”，maven提供了约定的项目的目录结构，自动创建项目目录，提高开发效率。 Maven 集成Tomcat7插件Maven Tomcat插件现在主要有两个版本，tomcat-maven-plugin和tomcat7-maven-plugin，使用方式基本相同。在pom.xml中加入节点：123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;9090&lt;/port&gt; &lt;path&gt;/mavenLearningTest&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; path 是访问应用的路径。 port 是tomcat的端口号（一般在tomcat—conf-- server.xml中修改）。 uriEncoding URL按UTF-8进行编码，这样就解决了中文参数乱码。 Server 指定tomcat名称。 选择pom.xml文件，击右键——&gt;选择 Run As——&gt; Maven build，在Goals中填写：tomcat7:run（若填的是tomcat:run,默认调用的是tomcat-maven-plugin，此时pom配置文件中也得修改） 几个常用的Goal 命令 描述 tomcat7:deploy 部署一个web war包 tomcat7:reload 重新加载web war包 tomcat7:start 启动tomcat tomcat7:stop 停止tomcat tomcat7:undeploy 停止一个war包 tomcat7:run 启动嵌入式tomcat ，并运行当前项目 下一篇中将介绍下如何使用Maven搭建SpringMVC项目]]></content>
      <categories>
        <category>项目构建</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC基本介绍]]></title>
    <url>%2F2017%2F12%2F12%2Fintroduction-to-springmvc%2F</url>
    <content type="text"><![CDATA[对SpringMVC的了解来自实际项目以及在项目过程遇到问题是，查找相关资料，并没有系统地学习这些。很多会用，但是不太清楚具体原理，最新重新学习SpringMVC，开头一章系统的介绍，让我有所顿悟。对于这些知识的学习，让我对SpringMVC基本配置认识更加深刻，特此将重要的知识点摘录下来。 依赖注入 有两个组件A和B，A依赖于B。现在假定A是一个类，且A有方法methodA()，该方法中获取B，代码如下：12345678public class A &#123; public void methodA() &#123; B b = ...// get an instance of B b.methodB(); ... &#125; ...&#125; 要使用B，类A必须先获取组件B的实例引用。若B是一个具体的类，则可以通过new关键字直接创建B的实例。但是，如果B是接口，且有多个实现，则问题就复杂了。我们固然可以任意选择接口B的一个实现类，但这也意味着A的可重用性大大降低，因为无法采用B的其他实现。依赖注入是这样处理此类情景：接管对象的创建工作，并将该对象的引用注入需要该对象的组件。对于上面的例子，依赖注入框架会分别创建对象A和对象B，并将对象B注入到对象A中。为了能让框架进行依赖注入，我们需要编写特定的setter方法或构造方法。setter方法依赖注入实例：12345678910public class A &#123; private B b; public void methodA() &#123; b.methodB(); ... &#125; public void setB(B b) &#123; this.b = b; &#125;&#125; 修改后的类A新增了一个set方法，Spring会先创建B的实例，框架会调用该方法，并注入创建好的B的实例，因此在methodA()中调用B的methodB()方法前，不需要获取B的实例，构造器方法依赖注入实例：1234567891011public class A &#123; private B b; public A(B b) &#123; this.b = b; &#125; public void methodA() &#123; b.methodB(); ... &#125;&#125; Sping会先创建B的实例，再创建A的实例，然后把B注入到实例A中。 注：Spring管理的对象称为beans。 从1.0版本开始，Spring同时支持上述两种方式依赖注入：setter方式和构造器方式；从2.5版本开始，可以通过AutoWired注解，Spring支持基于field方式依赖注入。缺点是会引入org.springframework.beans.factory.annotation.Autowired，这对Spring产生了依赖，这样程序无法直接迁移到另一个依赖注入容器间。以上是依赖注入的最后实现的两种方式。往前一点，Spring支持两种方式来支持这种依赖注入：XML配置方式和注解配置方式。此外，需要创建一个ApplicationContext对象，代表一个Spring控制反转容器，org.springframework.context.ApplicationContext接口有多个实现，包括ClassPathXmlApplicationContext和FileSystemXmlApplicationContext。这两个实现都需要至少包含一个beans信息的XML文件。ClassPathXmlApplicationContext尝试在类加载路径中加载配置文件，而FileSystemXmlApplicationContext从文件系统中加载。下面为从类路径中加载config1.xml和config2.xml的ApplicationContext创建的一个代码示例。1ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"config1.xml", "config2.xml"&#125;); 然后通过调用ApplicationContext的getBean方法获得对象。1Product product = context.getBean("product", Product.class); getBean方法会查询id为product且类型为Product的bean对象。 注：理想情况下，我们仅需要在测试代码中创建一个ApplicationContext，应用程序本身无需处理。对于Spring MVC应用，可以通过一个Spring Servlet来处理ApplicationContext，而无需直接处理。 XML配置文件介绍配置文件的根元素通常为：123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; ...&lt;/beans&gt; 若需要更强的Spring配置能力，可以在schemaLocation属性中添加相应的schema。如：123456789101112131415xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd" 配置文件可以是一份也可以是多份，支持模块化配置。ApplicationContext的实现类支持读取多份配置文件，如上面例子中的：1ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"config1.xml", "config2.xml"&#125;); 另一种选择是，通过一个主配置文件，将其他配置文件导入在主配置文件中，直接读取主配置文件，如：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;import resource="config1.xml/&gt; &lt;import resource="module/config2.xml/&gt; &lt;import resource="resource/config2.xml/&gt; ...&lt;/beans&gt; Spring控制反转容器的使用通过构造器创建一个bean实例前面通过调用ApplicationContext的getBean方法来获取到一个bean的实例。下面的配置文件中定义了一个名为product的bean。123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean name="product" class="myspring.bean.Product"/&gt;&lt;/beans&gt; 该bean的定义告诉Spring通过默认无参构造器来初始化Product类。如果不存在该构造器（若类作者重载了构造器，但是没有显示声明默认构造器），Spring将抛出异常。 注意：应采用id或者name属性标示一个bean。 为了让Spring创建一个Product实例，应将bean定义的name值“product”（具体实践中也可以是id值）和Product类型作为参数传递给ApplicationContext的getBean方法。12ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"spring-contig.xml"&#125;);Product product = context.getBean("product", Product.class); 通过工厂方法创建一个bean实例Spring还支持通过调用一个工厂的方法来初始化类。下面的bean定义展示了通过工厂方法来实例化java.util.Calendar。1&lt;bean id="calendar" class="java.util.Calendar" factory-method="getInstance"/&gt; 该类中有方法：12345public static Calendar getInstance() &#123; Calendar localCalendar = createCalendar(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT)); localCalendar.sharedZone = true; return localCalendar;&#125; 本例子采用了id属性，而非name属性来表示bean，采用getBean方法来获取Calendar实例。12ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"spring-contig.xml"&#125;);Calendar calendar = context.getBean("calendar", Calendar.class); Destory Method 的使用有时候我们希望在类被销毁前还做点什么，这次我们可以在bean定义中配置 destroy-method 属性，来指定在销毁前要被执行的方法。下面的例子中，我们配置Spring通过 java.util.concurrent.Executors 的静态方法newCachedThreadPool 来创建一个 java.util.concurrent.ExecutorService 实例，并指定了 destroy-method 属性值为 shutdown 方法。这样，Spring会在销毁 ExecutorService 实例前，调用其 shutdown 方法。12&lt;bean id="executorService" class=".util.concurrent.ExecutorService" factory-method="newCachedThreadPool" destroy-method="shutdown"/&gt;]]></content>
      <categories>
        <category>spring</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try catch finally return 的执行顺序]]></title>
    <url>%2F2017%2F12%2F03%2Fthe%20order%20of%20the%20try-catch-finally-return%2F</url>
    <content type="text"><![CDATA[结论： 不管有没有异常，finally中的代码一定会执行； try 和 catch 中有 return 时，finally也会执行； finally是在return后面的表达式运算后执行的，因此函数返回值是在finally执行前确定； finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值，是finally中return返回的值。 说明：对于第3点，return后面的表达式运算后先把要返回的值保存起来，然后执行finally中的代码（这里不包含return，否则就是第4点了），再将之前保存的值取出，并返回。 下面会列出几种情况并通过具体代码验证上面的结论。 情况1：1try&#123;&#125; catch()&#123;&#125;finally&#123;&#125; return; 举例代码如下，这里不会发生异常：123456789101112131415public static void main(String[] args) &#123; System.out.println("main:" + test1());&#125;public static int test1() &#123; try &#123; System.out.println("try..."); &#125; catch (Exception e) &#123; System.out.println("catch..."); &#125; finally &#123; System.out.println("finally..."); &#125; System.out.println("return..."); return 0;&#125; 执行结果：1234try...finally...return...main:0 显然按顺序执行。 情况2:1try&#123; return; &#125;catch()&#123;&#125; finally&#123;&#125; return; try中有return，举例代码如下：12345678910111213141516public static void main(String[] args) &#123; System.out.println("main:" + test2());&#125;public static int test2() &#123; try &#123; System.out.println("try...return1+1"); return 1 + 1; &#125; catch (Exception e) &#123; System.out.println("catch..."); &#125; finally &#123; System.out.println("finally..."); &#125; System.out.println("return0..."); return 0;&#125; 执行结果：123try...return1+1finally...main:2 这里程序先执行try块中return之前已经return语句中表达式运算代码，再执行finally块，最后执行try中的return；而finally块后的return语句，因为在try块中已经return了，所以后面的就不执行了。 情况3：1try&#123; &#125; catch()&#123;return;&#125; finally&#123;&#125; return; catch中有return，在try中造一个异常，举例代码如下：1234567891011121314151617public static void main(String[] args) &#123; System.out.println("main:" + test3());&#125;public static int test3() &#123; try &#123; System.out.println("try..."); int i = 1 / 0; &#125; catch (Exception e) &#123; System.out.println("catch...return2"); return 2; &#125; finally &#123; System.out.println("finally..."); &#125; System.out.println("return0..."); return 0;&#125; 执行结果：1234try...catch...return2finally...main:2 程序先执行try块中的代码，因为try块中有异常，然后执行catch中return之前及return语句中表达式运算代码，最后执行finally块中的代码。 情况4：1try&#123; return; &#125;catch()&#123;&#125; finally&#123;return;&#125; try块和finally块中均有return，举例如下：123456789101112131415public static void main(String[] args) &#123; System.out.println("main:" + test3());&#125;public static int test3() &#123; try &#123; System.out.println("try...return1"); return 1; &#125; catch (Exception e) &#123; System.out.println("catch..."); &#125; finally &#123; System.out.println("finally...return3"); return 3; &#125;&#125; 执行结果：123try...return1finally...return3main:3 程序还是先执行try块中包括return之前已经return本身表达式运算代码，此时会将返回值存起来；这里没有异常，再接着执行finally块中的语句，由于finally块中有return，所以提前结果程序。finally中有return时，此时编译器也会给出警告：1finally block does not complete normally 情况5：1try&#123;&#125; catch()&#123;return;&#125;finally&#123;return;&#125; catch块和finally块中有return，举例如下：12345678910111213141516public static void main(String[] args) &#123; System.out.println("main:" + test5());&#125;public static int test5() &#123; try &#123; System.out.println("try..."); int i = 1 / 0; &#125; catch (Exception e) &#123; System.out.println("catch...return2"); return 2; &#125; finally &#123; System.out.println("finally...return3"); return 3; &#125;&#125; 执行结果：1234try...catch...return2finally...return3main:3 程序首先执行try块，遇到了异常执行catch块，此时执行catch中return之前以及return中包含的表达式运算代码，将结果作为返回值保存起来；接着执行finally中的代码，由于finally块中有return，前面保存的返回值将丢弃，返回finally中的return值，程序退出。 情况6：1try&#123; return;&#125;catch()&#123;return;&#125; finally&#123;return;&#125; try、catch、finally块中均有return，并且try中会发生异常，举例如下：1234567891011121314151617public static void main(String[] args) &#123; System.out.println("main:" + test6());&#125;public static int test6() &#123; try &#123; System.out.println("try...return1"); int i = 1 / 0; return 1; &#125; catch (Exception e) &#123; System.out.println("catch...return2"); return 2; &#125; finally &#123; System.out.println("finally...return3"); return 3; &#125;&#125; 执行结果：1234try...return1catch...return2finally...return3main:3 程序先执行try中代码，若没有异常将执行return之前以及return中表达式运算并将结果存起，执行finally中的代码；这里try块中有异常，接着执行catch中的代码，并执行return之前以及return中表达式运算并将结果存起，然后执行finally中的代码，由于finally中有return，将丢弃前面保存的，程序提前结束。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>try-catch-finally-return</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现字符串反转的三种方法]]></title>
    <url>%2F2017%2F11%2F24%2Freverse-string%2F</url>
    <content type="text"><![CDATA[递归反转123456public static String reverse1(String str) &#123; if (str == null || str.length() &lt;= 1) &#123; return str; &#125; return reverse1(str.substring(1)) + str.charAt(0);&#125; 字符串的substring(1)方法返回下标为1及后面所有的字符，如1System.out.println("abcdef".substring(1)); 执行结果为：1bcdef 字符串的charAt(0)方法返回下标为0的字符，如1System.out.println("abcdef".charAt(0)); 执行结果为：1a 注意：在用递归编写程序是，需要明确两点： 递归公式 收敛条件（即：何时结束递归） 否则会出现异常，甚至栈溢出，如下面的递归。12345public class StackOverflowErrorTest &#123; public static void main(String[] args) &#123; main(null); &#125;&#125; 运行结果：1234Exception in thread "main" java.lang.StackOverflowError at com.h3c.imc.campus.commgroup.StackOverflowErrorTest.main(StackOverflowErrorTest.java:5) at com.h3c.imc.campus.commgroup.StackOverflowErrorTest.main(StackOverflowErrorTest.java:5) ... reverse方法反转StringBuffer/StringBuilder中自带方法reverse()能实现字符串反转。1234567public static String reverse2(String str) &#123; if (str == null || str.length() &lt;= 1) &#123; return str; &#125; StringBuilder sb = new StringBuilder(str); return sb.reverse().toString();&#125; 循环反转第一种思路：循环递减遍历该字符串，从最后一位开始取，每次取一个字符，最后拼接在一起。1234567891011public static String reverse3(String str) &#123; int length = str.length(); if (str == null || length &lt;= 1) &#123; return str; &#125; StringBuilder sb = new StringBuilder(); for (int i = length - 1; i &gt;= 0; i--) &#123; sb.append(str.charAt(i)); &#125; return sb.toString();&#125; 第二种思路：循环递增遍历该字符串，从首位开始取，字符拼接时，已经取出的拼接在后面，新的在前面。1234567891011public static String reverse3(String str) &#123; int length = str.length(); if (str == null || length &lt;= 1) &#123; return str; &#125; String reverse = ""; for (int i = 0; i &lt; length; i++) &#123; reverse = str.charAt(i) + reverse; &#125; return reverse;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm加载class文件的原理机制分析]]></title>
    <url>%2F2017%2F11%2F21%2Fjvm-classloader%2F</url>
    <content type="text"><![CDATA[案例分析A、B类中均包含静态代码块，非静态代码块以及构造器，A类是B类的父类。1234567891011121314public class A &#123; static &#123; System.out.print("A中静态代码块&gt;&gt;&gt;"); &#125; &#123; System.out.print("A中非静态代码块&gt;&gt;&gt;"); &#125; public A() &#123; System.out.print("A中构造器&gt;&gt;&gt;"); &#125;&#125; 12345678910111213public class B extends A&#123; static &#123; System.out.print("B中静态代码块&gt;&gt;&gt;"); &#125; &#123; System.out.print("B中非静态代码块&gt;&gt;&gt;"); &#125; public B() &#123; System.out.print("B中构造器&gt;&gt;&gt;"); &#125;&#125; 那么看看下面代码的运行结果。1234567public class ABTest &#123; public static void main(String[] args) &#123; A ab = new B(); System.out.println("\n==========================\n"); ab = new B(); &#125;&#125; 执行结果：1234A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt;A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt;==========================A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt; 总结： 同一类中：静态代码块 =&gt; 非静态代码块 =&gt; 构造器 父子类中：父类 =&gt; 子类； 静态代码块只在第一次实例化（new）执行了，非静态代码块在每次实例化都执行。 看执行结果，上面的3条总结都没问题，对于第3点，需要注意下：静态代码块其实不是跟着实例走的，而是跟着类走。看如下测试，通过Class.forName()动态加载类：123public static void main(String[] args) throws ClassNotFoundException &#123; Class.forName("B");&#125; 执行结果：1A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt; 这里并没有执行实例化过程，但是静态代码块却执行了，这也证明了静态static代码块并不是跟着实例走。下面将简单介绍下类加载相关概念及过程，介绍完后再看看上面的例子，印象会更深刻。首先得了解下几个比较重要的JVM的内存概念。 jvm的几个重要内存概念方法区 专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域。 常量池 是方法区的一部分，主要用来存放常量和类中的符号引用等信息。 堆区 用于存放类的对象实例，如new、数组对象。 栈区 由一个个栈帧组成的后进先出的结构，主要存放方法运行时产生的局部变量、方法出口等信息。 java类的生命周期我们编写完一个.java结尾的源文件后，经过编译后生成对应的一个或多个.class后缀结尾的文件。该文件也称为字节码文件，能在java虚拟机中运行。而类的生命周期正是：从类（.class文件）被加载到虚拟机内存，到从内存中卸载为止。整个周期一共分为7个阶段： 加载，验证，准备，解析，初始化，使用，卸载 其中 验证，准备，解析统称为连接； 加载，验证，准备，初始化，卸载，这5个的顺序是确定的。 值得注意的是，通常我们所说的类加载指的是：加载，验证，准备，解析，初始化，这5个阶段。 加载该阶段虚拟机的任务主要是找到需要加载的类，并把类的信息加载到jvm的方法区中，然后堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。 连接连接阶段有三个阶段：验证，准备，解析。主要任务是加载后的验证工作以及一些初始化前的准备工作。 验证当一个类被加载后，需要验证下该类是否合法，以保证加载的类能在虚拟机中正常运行。 准备该阶段主要是为类的静态变量分配内存并设置为jvm默认的初始值；对于非静态变量，则不会为它们分配内存。这里静态变量的初始值，不是由我们指定的，是jvm默认的。 基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0； 引用类型默认值是null； 常量的默认值为我们设定的值。比如我们定义final static int a = 1000，则在准备阶段中a的初始值就是1000。 解析这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，jvm会将所有的类、接口名、字段名、方法名等转换为具体的内存地址。譬如：我们要在内存中找到一个类里面的一个叫call的方法，显然做不到，但是该阶段，由于jvm已经将call这个名字转换为指向方法区中的一块内存地址了，也就是说我们通过call这个方法名会得到具体的内存地址，也就找到了call在内存中的位置了。 初始化有且仅有 5种情况必须立即对类进行“初始化”： 使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已经在编译器把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候； 使用java.lang.reflect包的方法进行反射调用时，若类没有进行初始化，需要先触发其初始化； 当初始化一个类时，若其父类还没有进行初始化，则需要先触发其父类的初始化； 执行main方法，虚拟机会先初始化其包含的那个主类； 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化（这一点不是很懂）。 在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。（这正好解释了案例中第3点结论） 使用初始化阶段的5种情况用了很强烈的限定词：有且仅有，这5种行为称为对一个类进行“主动引用”。其他所有引用类的方法（行为）都不会对类进行初始化，称之为“被动引用”。 《学习深入Java虚拟机》一书中列举了3个被动引用例子，我验证了下，确实如此，不过还得到了新的启发。这里列出其中的2个例子，如下： 例子1：通过子类引用父类的静态字段，不会导致子类初始化123456789package classloading;public class SuperClass &#123; static &#123; System.out.println("SuperClass init!"); &#125; public static int value = 123;&#125; 12345678package classloading;public class SubClass extends SuperClass&#123; static &#123; System.out.println("SubClass init!"); &#125;&#125; 1234567package classloading;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 执行结果：12SuperClass init!123 结论：通过子类SubClass来引用父类SuperClass的静态字段value，初始化的只是父类，并不会触发子类的初始化。 例子2：常量在编译阶段会存入调用类的常量池中，不会触发定义常量的类的初始化123456789package classloading;public class ConstClass &#123; static &#123; System.out.println("ConstClass init!"); &#125; public static final String HELLO_WORLD = "hello world";&#125; 1234567package classloading;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLO_WORLD); &#125;&#125; 执行结果：1hello world 结论：从打印的结果可以看到，并没有初始化ConstClass类；但是从源码上看是引用了ConstClass类的常量。因为在NotInitialization类的编译期中，通过常量优化，已经将常量 &quot;hello world&quot;存储到了NotInitialization类的常量池中了。也就是说，NotInitialization中引用ConstClass.HELLO_WORLD其实是对自身常量池中常量引用。 卸载在使用完类后，需满足下面，类将被卸载： 该类所有的实例都已经被回收，也就是java队中不存在该类的任何实例； 加载该类的ClassLoader已经被回收了； 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 当上面三个条件都满足后，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程本质上就是在方法区中清空类信息，结束整个类的生命周期。 jvm加载class文件的原理机制面试题中经常会问到JVM加载Class文件的原理机制，结合上面的分析，引用下面网上的分析，更加容易理解。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：&nbsp;&nbsp;1)&nbsp;&nbsp;如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；&nbsp;&nbsp;2)&nbsp;&nbsp;如果类中存在初始化语句，就依次执行这些初始化语句。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。 下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈java对象浅度克隆和深度克隆]]></title>
    <url>%2F2017%2F11%2F12%2Fshallow-and-deep-clone%2F</url>
    <content type="text"><![CDATA[需要克隆的原因在工作中我们有时会遇到这样的需求： A对象包含一些有用信息，这时候需要一个和A完全相同的B对象。拿到B对象后，只需要稍微调整下就ok。A和B是两个独立的对象，只是B的初始值来自于A。而A/B对象中包含了比较复杂的数据结构。此时通过简单的赋值，并不能满足这种需求。 我之前做过一个需求： 定时任务——自动新建XX产品：XX产品包含了很多信息，有基本类型数据也有复杂结构对象。已经上线的产品通过修改某些属性值就可以初始化形成新的XX产品，然后等待上线。这里就用到了克隆。 克隆的实现方式浅度克隆首先，定义一个Student类，包含两成员变量：name，age，并且实现Cloneable接口，代码如下：12345678910111213141516171819202122232425262728public class Student implements Cloneable&#123; private String name; private int age; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 再，定义一个Teacher类，也是两字段：一个name，一个聚合对象student，并且实现Cloneable接口，代码如下：12345678910111213141516171819202122232425262728public class Teacher implements Cloneable &#123; private String name; private Student student; public Teacher(String name, Student student) &#123; super(); this.name = name; this.student = student; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125;&#125; 需要clone的类为什么要实现Cloneable接口？我们先看看该接口的源码： 1234567891011121314151617181920212223242526272829package java.lang;/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object's clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; * By convention, classes that implement this interface should override * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method. * See &#123;@link java.lang.Object#clone()&#125; for details on overriding this * method. * &lt;p&gt; * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method. * Therefore, it is not possible to clone an object merely by virtue of the * fact that it implements this interface. Even if the clone method is invoked * reflectively, there is no guarantee that it will succeed. * * @author unascribed * @see java.lang.CloneNotSupportedException * @see java.lang.Object#clone() * @since JDK1.0 */public interface Cloneable &#123;&#125; 这是一个“标示接口”，即：没有任何方法和属性的接口。这个标示仅针对java.lang.Object#clone()方法。注释中：第一段可以看到：我们调用的clone()方法是Obejct类的方法；第二段中：若调用这个Object.clone()方法，但是不实现Cloneable接口(not implement Cloneable)的话，会抛CloneNotSupportedException异常。 我们来测试下，修改Student方法，去掉实现。代码修改如下：123456789public class Student &#123; ... public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student("jack", 27); Student cloneStudent = (Student) student.clone(); &#125;&#125; 执行结果如下：123Exception in thread "main" java.lang.CloneNotSupportedException: clone.Student at java.lang.Object.clone(Native Method) at clone.Student.main(Student.java:38) 第三段中说：按照惯例，对于Object.clone()方法，我们需要是重写。我们看下该方法源码：1protected native Object clone() throws CloneNotSupportedException; 是个native方法，一般来说native方法的效率要高于非native方法，因此比那种new出新对象再把旧对象的信息赋值到新对象的效率要高。该方法还是个protected方法，也就是说外部程序想调用有局限性，因此需要重写修饰符设置为public。 下面再看一个Teacher相关的例子，这里先重写下equals()方法：123456789101112131415161718@Overridepublic boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (this == obj) &#123; return true; &#125; if (obj instanceof Teacher) &#123; Teacher teacher = (Teacher) obj; if (teacher.name == this.name &amp;&amp; teacher.student.equals(this.student)) &#123; return true; &#125; return false; &#125; return false;&#125; 作如下测试：12345678910111213141516public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student("jack", 27); Teacher teacher = new Teacher("Ali", student); System.out.println("Teacher的内存地址：" + teacher); Teacher cloneTeacher = (Teacher) teacher.clone(); System.out.println("克隆Teacher的内存地址：" + cloneTeacher); System.out.println("克隆前后，Teacher对象是否相等：" + teacher.equals(cloneTeacher) + "\n"); System.out.println("++++++我只想修改克隆对象中的Student姓名为‘rose’++++++\n"); cloneTeacher.getStudent().setName("rose"); System.out.println("修改Student姓名后，Teacher的内存地址：" + teacher); System.out.println("修改Student姓名后，克隆Teacher的内存地址：" + cloneTeacher); System.out.println("修改Student姓名后，克隆前后，Teacher对象是否相等：" + teacher.equals(cloneTeacher)); &#125; 执行结果如下：123456789Teacher的内存地址：clone.Teacher@6c89db9a克隆Teacher的内存地址：clone.Teacher@4eb09321克隆前后，Teacher对象是否相等：true++++++我只想修改克隆对象中的Student姓名为‘rose’++++++修改Student姓名后，Teacher的内存地址：clone.Teacher@6c89db9a修改Student姓名后，克隆Teacher的内存地址：clone.Teacher@4eb09321修改Student姓名后，克隆前后，Teacher对象是否相等：true 我们可以看到： 克隆前后，内存地址发生了变化@6c89db9a=&gt;@4eb09321； 克隆前后以及修改了Student对象name属性值，对象没有变化，equals结果为true。 也就是说，不同的引用指向了同一个对象。因此，若我只想修改克隆对象的信息，这种情况下是做不到的。 但是若只是修改基本类型或者String字符串，却能满足需求，只会影响克隆后的对象。譬如：去掉：1cloneTeacher.getStudent().setName("rose"); 并增加：1cloneTeacher.setName("Alice"); equals结果：1修改Student姓名后，克隆前后，Teacher对象是否相等：false 最后别忘了重写下clone方法，修改修饰符为public:1234@Overridepublic Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 深度克隆深度克隆之所以有深度，是弥补了浅度克隆对于对象类型的属性克隆的不足。这里通过对象序列化和反序列化来实现深度克隆。 对象的序列化 把对象转换为字节序列的过程 对象的反序列化： 把字节序列恢复为对象的过程 如何实现：首先新建一个工具类，封装clone方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class CloneUtil &#123; private CloneUtil() &#123;&#125; @SuppressWarnings("unchecked") public static &lt;T extends Serializable&gt; T clone(T obj) &#123; ByteArrayOutputStream baos = null; ObjectOutputStream oos = null; ByteArrayInputStream bais = null; ObjectInputStream ois = null; try &#123; baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(obj); bais = new ByteArrayInputStream(baos.toByteArray()); ois = new ObjectInputStream(bais); return (T) ois.readObject(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException("Class not found.", e); &#125; catch (IOException e) &#123; throw new RuntimeException("Clone Object failed in IO.", e); &#125; finally &#123; try &#123; if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 说明： 调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义。这两个基于内存的流就能够释只要垃圾回收器清理对象放资源，这一点不同于对外部资源（如文件流）的释放。 修改Student代码如下：123456789101112public class Student implements Serializable&#123; private static final long serialVersionUID = 1L; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125; ... &#125; 修改Teacher代码如下：123456789101112public class Teacher implements Serializable &#123; private static final long serialVersionUID = 1L; @Override public String toString() &#123; return "Teacher [name=" + name + ", student=" + student + "]"; &#125; ... &#125; 替换main方法中测试代码：1Teacher cloneTeacher = (Teacher) teacher.clone(); 为序列化-反序列化克隆方法：1Teacher cloneTeacher = CloneUtil.clone(teacher); 执行结果：123456789Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]克隆Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]克隆前后，Teacher对象是否相等：false++++++我只想修改克隆对象中的Student姓名为‘rose’++++++修改Student姓名后，Teacher的的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]修改Student姓名后，克隆Teacher的的toString：Teacher [name=Ali, student=Student [name=rose, age=27]]修改Student姓名后，克隆前后，Teacher对象是否相等：false 明显可以看到，修改Student属性后，对克隆前的对象没有影响。 需要注意：CloneUtil类中的clone()长这样：123public static &lt;T extends Serializable&gt; T clone(T obj) &#123; ...&#125; 基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型&lt;T extends Serializable&gt;限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 当然，若是聚合对象如Teacher中的Student没有实现Serializable接口，还是会在运行时抛异常的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>浅度克隆</tag>
        <tag>深度克隆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射机制基础解析]]></title>
    <url>%2F2017%2F11%2F07%2Freflect-base%2F</url>
    <content type="text"><![CDATA[概念 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. 通俗来讲：反射就是把Class对象的各种成分映射成对应的Java类。 作用java反射机制其实就是将.class转化为.java，也即反编译。具体主要提供了以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法。 后面会围绕这几点具体展开。 重要API在java.lang.reflect包下提供类和接口，以获得关于类和对象的反射信息。这里简单罗列了与反射相关的几个重要的API，真正想学习反射机制，除了在项目中历练，API也是非常重要的手段。英语不好理解的话，就搜搜汉化后的API文档。 变量相关 含义 getField(String name) 返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 方法相关 含义 getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 构造方法相关 含义 getConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法 getConstructors() 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法 getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。 getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法 父类、父接口相关 含义 getInterfaces() 确定此对象所表示的类或接口实现的接口。 getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。 其他重要相关 含义 getModifiers() 以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符。 getName() 以 String 形式返回此 Method 对象表示的方法名称。 getReturnType() 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。 newInstance() 创建此 Class 对象所表示的类的一个新实例。 isInstance(Object obj) 判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。 具体功能实现下面通过例子分别讲述获取Class对象的3种方式，如何创建实例，如何获取构造器，如何获取方法，如何获取属性以及通过反射调用方法。 获取Class对象的3种方式例如新建一个类MyReflectTest，代码如下：123public class MyReflectTest &#123; &#125; 方式1：使用Class类的中静态forName()方法获得与字符串对应的Class对象12345678public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; clz = Class.forName("test.MyReflectTest"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 在数据库有关开发中，我们经常会用到这个方法，例如：1Class.forName("com.mysql.jdbc.Driver") 方式2： 利用对象的class属性123public static void main(String[] args) &#123; Class clz = MyReflectTest.class;&#125; 注意，在基本类型和包装类型中有，例如：1Integer.TYPE 等价于1int.class 是int的Class对象，不等价于1Integer.class 这是Integer的Class对象表示，看看源码就知道了。 方式3：调用对象的getClass()方法1234public static void main(String[] args) &#123; MyReflectTest myReflectTest = new MyReflectTest(); Class clz = myReflectTest.getClass();&#125; 创建实例获取到class对象后，调用newInstance()方法来创建Class对象对应的类实例，测试代码：1234public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Class clz = MyReflectTest.class; MyReflectTest newInstance = (MyReflectTest) clz.newInstance();&#125; 获取构造器获取类的所有构造器，测试代码：1234567891011public static void main(String[] args) &#123; // 获取类对象 Class clz = MyReflectTest.class; // 获取public构造器数组 Constructor[] cons = clz.getConstructors(); // 获取public，默认，protected，private构造器数组 Constructor[] declaredCons = clz.getDeclaredConstructors();&#125; 获取类中指定的某个构造器，测试代码：12345678910111213141516171819202122public MyReflectTest(String name) &#123; super(); this.name = name;&#125;MyReflectTest(String name, int age) &#123; super(); this.name = name; this.age = age;&#125;public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; // 获取public构造器，构造器参数类型为String Constructor con = clz.getConstructor(String.class); // 获取public，默认，protected，private构造器，构造器参数类型为String，int Constructor declaredCon = clz.getDeclaredConstructor(String.class, int.class);&#125; 获取方法新增两个方法:add()和get()。 12345678private void add(String name) &#123; System.out.println(name);&#125;public int get() &#123; System.out.println(age); return age;&#125; getDeclaredMethods()方法相关测试代码：1234567891011121314151617181920public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Method[] declaredMethods = clz.getDeclaredMethods(); for (Method method : declaredMethods) &#123; System.out.println("==============================="); // 访问修饰符 System.out.println(Modifier.toString(method.getModifiers())); // 返回类型 System.out.println(method.getReturnType()); // 方法名称 System.out.println(method.getName()); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (Class&lt;?&gt; param : parameterTypes) &#123; // 方法参数类型 System.out.println(param.getName()); &#125; &#125;&#125; 执行结果：1234567891011121314===============================public staticvoidmain[Ljava.lang.String; //"["表示数组对象===============================privatevoidaddjava.lang.String===============================publicintget 能获取私有的方法add()。看看另一个反射方法：getMethods()，代码和上面一个，基本没变化。测试代码：1234567891011121314151617public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Method[] methods = clz.getMethods(); for (Method method : methods) &#123; System.out.println("+++++++++++++++++++++++++++++++++"); System.out.println(Modifier.toString(method.getModifiers())); System.out.println(method.getReturnType()); System.out.println(method.getName()); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (Class&lt;?&gt; param : parameterTypes) &#123; System.out.println(param.getName()); &#125; &#125;&#125; 执行结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+++++++++++++++++++++++++++++++++public staticvoidmain[Ljava.lang.String;+++++++++++++++++++++++++++++++++publicintget+++++++++++++++++++++++++++++++++public finalvoidwaitlongint+++++++++++++++++++++++++++++++++public final nativevoidwaitlong+++++++++++++++++++++++++++++++++public finalvoidwait+++++++++++++++++++++++++++++++++publicbooleanequalsjava.lang.Object+++++++++++++++++++++++++++++++++publicclass java.lang.StringtoString+++++++++++++++++++++++++++++++++public nativeinthashCode+++++++++++++++++++++++++++++++++public final nativeclass java.lang.ClassgetClass+++++++++++++++++++++++++++++++++public final nativevoidnotify+++++++++++++++++++++++++++++++++public final nativevoidnotifyAll 对比上面的getDeclaredMethods()，少了一个私有的方法add()，但是多了好多不在本类的方法。由于每个类的超类都是Object类，很明显，这些方法都是来自超类，看看源码也能发现这个。也就是说： getDeclaredMethods()获取的是本类的方法，public、默认、protected、private； getMethods()获取的是本类和父类的所有的public的方法。 另外有获取指定某一个方法的反射方法。测试代码：123456789101112public String save(String name, int age) &#123; return "name: " + name + ", age: " + age;&#125;public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; // 第一个参数是“方法名”，后面的是方法的可变参数列表 Method method = clz.getMethod("save", String.class, int.class); System.out.println(Modifier.toString(method.getModifiers()));&#125; 执行结果：1public 其他的类似。 获取属性创建两个成员变量name，age，如下：123public String name;private int age; 测试代码：1234567891011121314151617181920public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Field[] fields = clz.getFields(); for (Field field : fields) &#123; System.out.println("+++++++++++++++++++++++++"); System.out.println(Modifier.toString(field.getModifiers())); System.out.println(field.getType()); System.out.println(field.getName()); &#125; Field[] declaredFields = clz.getDeclaredFields(); for (Field field : declaredFields) &#123; System.out.println("========================="); System.out.println(Modifier.toString(field.getModifiers())); System.out.println(field.getType()); System.out.println(field.getName()); &#125;&#125; 执行结果：123456789101112+++++++++++++++++++++++++publicclass java.lang.Stringname=========================publicclass java.lang.Stringname=========================privateintage 另外getField(String)，getDeclaredField(String)参数为方法名，和Method类似。 调用方法通过上面的一系列操作获取到某一方法后，我们可以利用invoke()方法来调用这个方法。测试代码：12345678910111213141516171819public String save(String name, int age) &#123; return "name: " + name + ", age: " + age;&#125;public static void main(String[] args) throws Exception &#123; // 获取类对象 Class&lt;MyReflectTest&gt; clz = MyReflectTest.class; // 获取对象实例 MyReflectTest reflect = (MyReflectTest) clz.newInstance(); // 获取save方法 Method method = clz.getMethod("save", String.class, int.class); // 第一个参数为对象实例，后面的为方法的参数 Object result = method.invoke(reflect, "jack", 27); System.out.println(result);&#125; 执行结果：1name: jack, age: 27 最后：反射在工作中其实用到的时候并不多，主要用来构建框架。譬如Spring中的IOC也即控制反转，其底层就是利用了反射。以后有时间再整理下这块。反射机制基础到这结束。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态static与非静态non-static(变量、方法、内部类)解析]]></title>
    <url>%2F2017%2F11%2F06%2Fstatic-and-non-static%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。 —— Java编程思想 &nbsp;&nbsp;&nbsp;&nbsp;一句话描述下：方便在对象没有创建的时候调用方法或变量。很显然，static依赖于类，只要类加载了，就可以使用，而不需要等对象实例化后再调用。 下面具体分析下。 变量静态变量 static修饰的变量，也叫类变量； 可以直接用类名.变量调用，也可以用对象名.变量调用； 所有对象的同一个类变量共享同一块内存空间。 实例变量 没有static修饰，也就对象变量； 只能通过对象调用； 所有对象的同一个类变量共享不同内存空间。 总结 静态变量是所有对象共有的，当某一个对象将它的值改变，此时其他对象去获取时，将得到改变后的值，因为它依赖于类； 实例变量是每一个对象私有的，当某一个对象将它的值改变，此时其他对象去获取时，得到的还是改变前的值，因为它依赖具体的实例； 举例静态变量和非静态变量举例代码如下：123456789101112131415161718192021222324252627282930public class StaticTest &#123; static int age = 1; int level = 1; public static void main(String[] args) &#123; System.out.println("静态变量：直接用‘类名.’调用: age = " + StaticTest.age); // 修改静态变量值 StaticTest.age = 2; // 实例化StaticTest对象 StaticTest staticTest = new StaticTest(); System.out.println("静态变量：通过‘实例化后的对象’调用：age = " + staticTest.age); System.out.println("实例变量：只能通过‘实例化后的对象’调用：level = " + staticTest.level); // 修改静态变量值 staticTest.age = 3; // 修改实例变量值 staticTest.level = 2; // 再实例化一个StaticTest对象 StaticTest staticTest1 = new StaticTest(); System.out.println("静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = " + staticTest1.age); System.out.println("实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = " + staticTest1.level); &#125;&#125; 执行结果：12345静态变量：直接用‘类名.’调用: age = 1静态变量：通过‘实例化后的对象’调用：age = 2实例变量：只能通过‘实例化后的对象’调用：level = 1静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = 3实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = 1 结果和前面分析的一致。 方法静态方法 static修饰的方法，属于类； 可以直接用类名.方法名调用，也可以用对象名.方法名调用； 在访问本类成员时，只允许访问静态变量和静态方法，不允许访问实例变量和实例方法； static块也即静态代码块，只能调用静态方法。 实例方法 没有static修饰，属于对象； 只能通过对象调用； 实例方法可以访问实例成员，也可访问静态成员； static块中不能调用实例方法。 举例123456789101112131415161718192021222324252627282930313233343536public class StaticTest &#123; static int age = 1; int level = 1; /** * 非静态方法 */ public void nonStaticMethod() &#123; System.out.println(this.level); System.out.println(age); staticMethod(); &#125; /** * 静态方法 */ public static void staticMethod() &#123; System.out.println(age); // 编译不通过 //System.out.println(level); System.out.println(new StaticTest().level); // 编译不通过 //nonStaticMethod(); new StaticTest().nonStaticMethod(); &#125;&#125; 总结&nbsp;&nbsp;&nbsp;&nbsp;静态方法在类加载时就创建了，但是非静态方法需要实例化后才能创建，因为先类加载，再实例化，所以静态方法中不能直接访问类的成员，只有类实例化后才能访问。 内部类 &nbsp;&nbsp;&nbsp;&nbsp;将一个类的定义放在另一个类的定义内部，就是内部类。 &nbsp;&nbsp;&nbsp;&nbsp;这里只分析普通内部类和静态内部类的区别，具体关于内部类知识暂时请参见详解内部类 普通内部类 不能有静态成员（静态方法，静态变量），否则编译不通过； 可以访问外部类的所有成员（方法，属性）； 实例化内部类方法： &nbsp;&nbsp;&nbsp;&nbsp;1). 先生成一个外部类的对象实例，如：1OutClass o = new OutClass(); &nbsp;&nbsp;&nbsp;&nbsp;2). 通过外部类的对象实例生成内部类对象，如：1OutClass.InnerClass no_static_i = o.new InnerClass(); 静态内部类 可以有静态和非静态成员； 只能访问外部类的静态成员； 实例化一个静态内部类方法： &nbsp;&nbsp;&nbsp;&nbsp;1). 不依赖外部类的实例，直接实例化内部类对象，如：1OutClass.InnerStaticClass static_i = new OutClass.InnerStaticClass(); &nbsp;&nbsp;&nbsp;&nbsp;2). 调用静态内部类的方法或变量，通过类名直接调用，如：12OutClass.InnerStaticClass.static_name;OutClass.InnerStaticClass.getName(); 举例及总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class OutClass &#123; private String outName = "OutClass.outName"; static String staticOutName = "OutClass.staticOutName"; public void getOutName() &#123; System.out.println(outName); System.out.println(staticOutName); &#125; public static void getOutStaticName() &#123; // 编译不通过，静态方法不能访问非静态成员 //System.out.println(outName); System.out.println(staticOutName); &#125; public static void main(String[] args) &#123; // 依赖外部类实例，创建非静态内部类 OutClass o = new OutClass(); OutClass.InnerClass no_static_i = o.new InnerClass(); no_static_i.getInnerName(); // 不依赖外部类实例，直接实例化静态内部类 OutClass.InnerStaticClass static_i = new OutClass.InnerStaticClass(); static_i.getInnerName(); // 通过静态内部类类名直接调用成员变量或方法 System.out.println(OutClass.InnerStaticClass.staticInnerName); OutClass.InnerStaticClass.getStaticInnerName(); &#125; /** * 非静态内部类 */ public class InnerClass &#123; // 编译不通过，普通静态内部类中不能有static变量 //static String staticInnerName = "InnerClass.staticInnerName"; // 编译不通过，普通静态内部类中不能有static方法 //public static void getStaticInnerName() &#123; // System.out.println(staticInnerName); //&#125; String innerName = "InnerClass.innerName"; public void getInnerName() &#123; System.out.println(innerName); // 直接访问外部类成员变量 System.out.println(outName); // 直接访问外部类静态成员变量 System.out.println(staticOutName); &#125; &#125; /** * 静态内部类 */ public static class InnerStaticClass &#123; static String staticInnerName = "InnerStaticClass.staticInnerName"; String innerName = "InnerStaticClass.innerName"; public static void getStaticInnerName() &#123; System.out.println(staticInnerName); &#125; public void getInnerName() &#123; System.out.println(innerName); // 编译不通过，不能直接反问外部类成员变量 //System.out.println(outName); // 只能访问外部类静态成员 System.out.println(staticOutName); &#125; &#125;&#125;]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>静态</tag>
        <tag>非静态</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译小工具：jad常用命令介绍]]></title>
    <url>%2F2017%2F11%2F06%2Fjad-cmd-introduce%2F</url>
    <content type="text"><![CDATA[jad是最简单的字节码.class反编译出源码.java的小工具。是jdk自带的，我的在‪D:\Java\jdk1.7.0_80\bin\jad.exe。 jad常用命令 -o 不提示，覆盖源文件，例如：1jad -o example.class 若当前目录下有example.jad文件（默认扩展名jad），执行该命令后会覆盖原example.jad文件 -s 指定输出文件的类型，例如：1jad -s java example.class 反编译结果以.java为扩展名。 -p 将反编译结果输出到cmd窗口，例如：1jad -p example.class 反编译结果直接在cmd界面显示。 &gt; 将反编译结果重定向到文件，例如：1jad -p example.class &gt; example1.java 在当前目录下，将example.class反编译后输出到example1.java文件中。 -d 指定反编译的输出文件目录，例如：1jad -d test example.class 在当前目录下会产生目录test，里面有example.jad文件 常用命令组合1jad -a -o -s java example.class 用JVM字节码格式来注解输出(-a)； 覆盖原文件（-o）； 以java扩展名输出example文件（-s java） jad帮助信息jad的帮助信息如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Options: //用JVM字节格式来注解输出 -a - generate JVM instructions as comments (annotate) //同 -a,但是注解的时候用全名称 -af - output fully qualified names when annotating //输出多于的括号 (e.g., if(a) &#123; b(); &#125;, default: no) -b - generate redundant braces (braces) //清除所有的前缀 -clear - clear all prefixes, including the default ones //指定输出文件的文件目录 -d &lt;dir&gt; - directory for output files //试图反编译代码的dead 部分(default: no) -dead - try to decompile dead parts of code (if there are any) //不用用字节码的方式反编译 (no JAVA source generated) -dis - disassembler only (disassembler) //输出整个的名字,无论是类还是方法 -f - generate fully qualified names (fullnames) //输出类的成员在方法之前 (default: after methods) -ff - output fields before methods (fieldsfirst) //输出所有的变量的缺省的最初值 -i - print default initializers for fields (definits) //将strings分割成指定数目的块的字符 (default: no) -l&lt;num&gt; - split strings into pieces of max &lt;num&gt; chars (splitstr) //将输出文件用行号来注解 (default: no) -lnc - output original line numbers as comments (lnc) //分割strings用新行字符 newline character (default: no) -nl - split strings on newline characters (splitstr) //不要转换java的定义符 (default: do) -noconv - don&apos;t convert Java identifiers into valid ones (noconv) //不要生成辅助文件 -nocast - don&apos;t generate auxiliary casts //不要生成方法的源代码 -nocode - don&apos;t generate the source code for methods //不允许空的构造器存在 -noctor - suppress the empty constructors //不要去检查class文件是否以dos方式写 (CR before NL, default: check) -nodos - turn off check for class files written in DOS mode //关掉对内部类的支持 (default: turn on) -noinner - turn off the support of inner classes //忽略局部变量的表信息 -nolvt - ignore Local Variable Table entries (nolvt) //不要输出一个新行在打开一个括号之前 (default: do) -nonlb - don&apos;t insert a newline before opening brace (nonlb) //无需确认直接覆盖输出 (default: no) -o - overwrite output files without confirmation //发送反编译代码到标准输出 STDOUT (e.g., for piping) -p - send all output to STDOUT (for piping) //在生成源代码时将所有的包加前缀 -pa &lt;pfx&gt;- prefix for all packages in generated source files //用数字名字给所有的类加前缀 (default: _cls) -pc &lt;pfx&gt;- prefix for classes with numerical names (default: _cls) //给没有用到的异常的名字加前缀 -pe &lt;pfx&gt;- prefix for unused exception names (default: _ex) //用数字名字给所有的成员变量加前缀 (default: _fld) -pf &lt;pfx&gt;- prefix for fields with numerical names (default: _fld) //在&lt;num&gt; 的导入之后将其他引用包裹成一行导入 (default: 3) -pi&lt;num&gt; - pack imports into one line using .* (packimports) //给局部变量用数字名字加前缀 (default: _lcl) -pl &lt;pfx&gt;- prefix for locals with numerical names (default: _lcl) //给方法用数字名字加前缀 (default: _mth) -pm &lt;pfx&gt;- prefix for methods with numerical names (default: _mth) //给方法的参数用数字名字加前缀 (default: _prm) -pp &lt;pfx&gt;- prefix for method parms with numerical names (default:_prm) //将同类型的成员包裹成一行 (default: no) -pv&lt;num&gt; - pack fields with the same types into one line (packfields) //恢复包的目录结构 -r - restore package directory structure //指定输出文件的类型 (by default &apos;.jad&apos;) -s &lt;ext&gt; - output file extension (default: .jad) //遇到关键字(if/for/while/etc)输出空格和表达式 (default: off) -space - output space between keyword (if, while, etc) and expression //显示所有的类，方法，成员变量的总数 -stat - show the total number of processed classes/methods/fields //用 &lt;num&gt;个的空格 (default: 4) -t&lt;num&gt; - use &lt;num&gt; spaces for indentation (default: 4) //用tabs代替空格对于边缘 -t - use tabs instead of spaces for indentation //正在反编译的时候 显示方法的名字 -v - show method names while decompiling //将 UNICODE strings 转换成 8-bit strings，用当前的 ANSI 码页 (Win32 only) -8 - convert Unicode strings into ANSI strings (ansi) //重新定向 STDERR to STDOUT (Win32 only) -&amp; - redirect STDERR to STDOUT]]></content>
      <categories>
        <category>小工具</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>jad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类（abstract class）和接口（interface）解析]]></title>
    <url>%2F2017%2F11%2F05%2Fabstract-and-interface%2F</url>
    <content type="text"><![CDATA[概念抽象类：包含抽象方法的类就称为 抽象类；接口： 抽象方法的集合，方法没有具体实现即不包含方法体。 两者异同相同点 都不能被实例化； 接口的实现类或抽象类的子类都必须实现接口或抽象类中的方法后才能被实例化 不同点 接口中的方法是高度抽象的，只有定义，没有具体的实现；抽象类中可以有定义也可以有实现； 接口中的方法默认为public abstract， 可以直接写public， 可以都省略不写；接口中方法修饰符不能是private， 接口需要实现，所以私有的方法没有意义；抽象类中的具体实现的方法和普通的类一样，而只有定义的方法必须用abstract修饰，不然编译不通过；而且抽象方法的修饰符不能是private，static，synchronized，native，能用默认的，public和protected。 接口中定义变量默认为public static final， 并且要赋予初始值，不然编译不通过；抽象类和普通的类一样，可以有自己的成员变量，可以重新赋值； 接口需要实现（implements）， 抽象类需要继承（extends），一个类可以实现多个接口，但是只能继承一个抽象类（单继承多实现）。 接口三问接口方法能否用private修饰 不能。因为接口是对外开放的，需要具体的类来实现其中的方法，私有的方法作用范围为本类，在接口中定义私有方法没有任何意义，编译不会通过。 接口方法能否用synchronized修饰 不能。synchronized是一种同步锁，在修饰方法时，需要具体逻辑，而接口只是定义，因为直接修饰接口中的方法没意义，可以用来修饰接口方法的具体实现。 接口方法能否用static修饰 这和jdk版本有关。jdk8之前：不能；jdk8新特性： 能。——参见JDK8新特性之接口的静态方法和默认方法 举例这里提供两种方式：jad反编译和反射来获取成员变量和方法的相关内容。 jad反编译下面先给出对应源码，再用jad反编译.class文件。反编译执行命令如下：1jad -a -o -s java 类名.class jad详细命令参见反编译小工具：jad常用命令介绍 接口.java源码MyInterface.java接口源码如下：123456public interface MyInterface &#123; String name = "MyInterface"; void add();&#125; 接口.class反编译MyInterface.class反编译结果如下：123456public interface MyInterface &#123; public abstract void add(); public static final String name = "MyInterface";&#125; 可以看到， 1.在成员变量（常量）中默认的修饰符是public static final;2.在方法中，默认的修饰符是public abstract 抽象类.java源码MyAbstract抽象类源码如下：1234567891011public abstract class MyAbstract &#123; public String name; void get() &#123; System.out.println("MyAbstract get() "); &#125; // 抽象类中的没有实现的方法必须是“abstract” abstract void delete();&#125; 抽象类.class反编译1234567891011121314public abstract class MyAbstract &#123; public MyAbstract() &#123; &#125; void get() &#123; System.out.println("MyAbstract get() "); &#125; abstract void delete(); public String name;&#125; 可以看到，成员方法和成员变量和普通类一样，是什么修饰就是什么。 反射获取这里新建一个MyTest类，继承抽象类MyAbstract，并且实现接口MyInterface 反射代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class MyTest extends MyAbstract implements MyInterface &#123; public static void main(String[] args) &#123; Field[] abstractFields = MyAbstract.class.getDeclaredFields(); Method[] abstractMethods = MyAbstract.class.getDeclaredMethods(); System.out.println("抽象类MyAbstract成员变量反射信息："); for (Field f : abstractFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("抽象类MyAbstract成员方法反射信息："); for (Method m : abstractMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType() + "\n"); &#125; Field[] interfaceFields = MyInterface.class.getDeclaredFields(); Method[] interfaceMethods = MyInterface.class.getDeclaredMethods(); System.out.println(); System.out.println("接口MyInterface成员变量反射信息："); for (Field f : interfaceFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("接口MyInterface成员方法反射信息："); for (Method m : interfaceMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType()); &#125; &#125; @Override public void add() &#123; &#125; @Override void delete() &#123; &#125;&#125; 运行结果1234567891011121314151617181920212223抽象类MyAbstract成员变量反射信息：变量名：name修饰符：public变量类型：class java.lang.String抽象类MyAbstract成员方法反射信息：方法名：get修饰符：返回类型：void方法名：delete修饰符：abstract返回类型：void接口MyInterface成员变量反射信息：变量名：name修饰符：public static final变量类型：class java.lang.String接口MyInterface成员方法反射信息：方法名：add修饰符：public abstract返回类型：void 可以看到，和jad反编译的结果是一样的。 具体的反射机制请参见另一篇博文反射机制基础解析]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk8新特性</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8新特性之接口的静态方法和默认方法]]></title>
    <url>%2F2017%2F11%2F05%2FJDK8-static-and-default%2F</url>
    <content type="text"><![CDATA[JDK8之前我们在接口中定义成员变量只能是public static final的，定义的成员方法只能是public abstract的，默认省略。JDK8前后这一概念等价。定义接口BeforeJDK8Interface如下：name和name1表述等价，getName()和getName1()表述等价。12345678910111213public interface BeforeJDK8Interface &#123; String name = "BeforeJDK8Interface"; //public、 static、 final 可以单独使用，也可以组合使用 public static final String name1 = "BeforeJDK8Interface"; void getName(); //public、 abstract 可以单独使用，也可以组合使用 public abstract void getName1();&#125; JDK8新增特性，允许我们在接口中定义default默认方法和static静态方法。定义接口JDK8Interface如下：1234567891011public interface JDK8Interface &#123; default void myDefaultMethod() &#123; System.out.println("JDK8新特性:接口中的默认方法"); &#125; static void myStaticMethod() &#123; System.out.println("JDK8新特性：接口中的静态方法"); &#125;&#125; 实现接口时，这里static方法由于static的原因，属于接口类，只能通过 接口类名直接调用；而default方法，需要 接口实现类实例化后调用。定义接口实现类JDK8InterfaceImpl如下：12345678public class JDK8InterfaceImpl implements JDK8Interface &#123; public static void main(String[] args) &#123; JDK8Interface.myStaticMethod(); JDK8InterfaceImpl jdk8Interface = new JDK8InterfaceImpl(); jdk8Interface.myDefaultMethod(); &#125;&#125; 由于static的原因，静态方法不能重写；但是default方法却可以，重写myDefaultMethod代码如下：123456789public class JDK8InterfaceImpl implements JDK8Interface &#123; ... @Override public void myDefaultMethod() &#123; System.out.println("接口中的default方法不满足需求，需要重写"); &#125;&#125; 这里稍注意下，JDK8Interface接口中default方法用了修饰符&quot;default&quot;，这里重写后修饰符是&quot;public&quot; 由于java实行的是单继承extends多实现implements，那JDK8新增特性中的两个方法有啥要求不？ 首先看看static方法，由于调用static方法时，用的是接口类名，不能的接口类名肯定不同，所以没影响； 对于default方法， 有于是实现类实例化后调用，若该类有多个接口且接口中有相同名称的default方法，这时候编译器就没办法区分了，会报错，必须重写default方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk8新特性</tag>
        <tag>静态方法</tag>
        <tag>默认方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载（Overload）和重写（Override）解析]]></title>
    <url>%2F2017%2F11%2F02%2Foverload-and-override%2F</url>
    <content type="text"><![CDATA[方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 概念重载Overload 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。 访问修饰符：重载与访问修饰符无关 返回类型： 重载与返回值无关 方法名： 重载方法名需完全一致 参数列表： 重载参数列表需完全不同 重写Override 发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。 访问修饰符：子类的访问修饰符权限 &gt;= 父类的访问修饰符权限 返回类型： 子类的返回类型 &lt;= 父类的返回类型 方法名： 方法名应完全一致 参数列表： 参数列表应完全一致 举例String类重载例子String类的构造器重载：1234567public String() &#123; this.value = new char[0];&#125;public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; String类的valueOf()方法的重载：1234567public static String valueOf(char data[]) &#123; return new String(data); &#125; public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; 重写例子ArrayList继承了AbstractList类1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; AbstractList类中有方法add()：1234public boolean add(E e) &#123; add(size(), e); return true;&#125; ArrayList类中有重写了add()方法：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 多态面向对象编程有三大特性：封装、继承、多态。 概念 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding）多态存在的三个必要条件 1. 要有继承； 2. 要有重写； 3. 父类引用指向子类对象。 根据何时确定执行多态方法中的哪一个，多态分为两种情况：编译时多态和运行时多态。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。 编译时多态重载都是编译时多态，从上面的分析可以看到，只要确定了方法参数的数据类型,个数,次序就能确定调用哪一个方法。 运行时多态重写有两种多态性，当对象引用本类实例，此时为编译时多态，能在编译期确定调用哪个方法；否则为运行时多态。 举例分析123456789101112131415package test;public class Test &#123; &#125;class Animal&#123; public String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String getName() &#123; return "Dog"; &#125;&#125; 1.执行下面的main方法123456public static void main(String[] args) &#123; Animal animal = new Animal(); Dog dog = new Dog(); System.out.println(animal.getName()); System.out.println(dog.getName());&#125; 输出结果：12AnimalDog Animal和Dog引用的都是本类的实例12Animal animal = new Animal();Dog dog = new Dog(); 2.若是这样呢？输入结果是多少1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName());&#125; 此时输出：1Dog 程序在运行时，会从实例所属的类开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照继承关系逐层向上查找，直到超级父类Object类。该例子animal.getName()执行过程是： 3.修改Animal类, 空类12class Animal&#123;&#125; 此时执行方法：1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(((Dog) animal).getName());&#125; 需要显示地转换下((Dog) animal).getName(),因为Animal类中没有定义getName()方法。 4.修改Animal,Dog类的getName()方法为静态方法,并增加一成员变量name1234567891011121314class Animal &#123; public String name = "a"; public static String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String name = "d"; public static String getName() &#123; return "Dog"; &#125; 执行main方法：12345public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName()); System.out.println(animal.name);&#125; 输出结果为：12Animala 结果解释：1.重写只使用于实例方法，不能用于静态方法，对于static方法，只能隐藏,重载,继承；2.在利用引用animal访问对象的属性name或静态方法getName()时，是引用类型决定了实际上访问的是哪个对象（Animal）的成员，而不是当前引用代表的那个类（new Dog()）;由此可知，子类静态方法并不能重写（覆盖）父类的静态方法;故而输出的结果都是父类的成员结果。 为什么不能根据返回类型来区分重载假设下面的重载方法update能编译通过123456789public class Test &#123; public void update() &#123; &#125; public int update() &#123; return 0; &#125;&#125; 当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。方法的返回值,只能作为方法运行之后得一个状态，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的标示。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
        <tag>多态</tag>
        <tag>编译时多态</tag>
        <tag>运行时多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和Integer解析]]></title>
    <url>%2F2017%2F11%2F02%2Fint-and-Integer%2F</url>
    <content type="text"><![CDATA[Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 两个常见的面试例子先看两个常见的例子，后面会针对例子加以分析。例11234567public static void main(String[] args) &#123; Integer a = new Integer(8); Integer b = 8; int c = 8; System.out.println(a == b); System.out.println(a == c); &#125; 1执行结果： false, true 例2 12345public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 250, f4 = 250; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125; 1执行结果： true, false 知识点一：自动拆箱与自动包装概念1.自动拆箱： 自动将包装器类型转换为基本数据类型； 2.自动包装： 自动将基本数据类型转换为包装器类型。 具体分析例1中1234Integer b = 8; //自动装箱//Integer a = new Integer(8);//int c = 8;System.out.println(a == c) // 自动拆箱 注意：Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是intValue()方法。 对例1反编译看看(这里用jad来反编译), Test是例子中的类名。下面命令将输出带字节码注释和源码 -a表示用JVM字节格式来注解输出; -o表示无需确认直接覆盖输出; -s表示定义输出文件的扩展名,默认的扩展名是jad; java表示我们想要的反编译后输出java格式文件 jad详细命令参见反编译小工具：jad常用命令介绍1jad -a -o -s java Test.class 反编译结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package test;import java.io.PrintStream;public class Test &#123; public Test() &#123; // 0 0:aload_0 // 1 1:invokespecial #8 &lt;Method void Object()&gt; // 2 4:return &#125; public static void main(String args[]) &#123; Integer a = new Integer(8); // 0 0:new #16 &lt;Class Integer&gt; // 1 3:dup // 2 4:bipush 8 // 3 6:invokespecial #18 &lt;Method void Integer(int)&gt; // 4 9:astore_1 Integer b = Integer.valueOf(8); // 5 10:bipush 8 // 6 12:invokestatic #21 &lt;Method Integer Integer.valueOf(int)&gt; // 7 15:astore_2 int c = 8; // 8 16:bipush 8 // 9 18:istore_3 System.out.println(a == b); // 10 19:getstatic #25 &lt;Field PrintStream System.out&gt; // 11 22:aload_1 // 12 23:aload_2 // 13 24:if_acmpne 31 // 14 27:iconst_1 // 15 28:goto 32 // 16 31:iconst_0 // 17 32:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; System.out.println(a.intValue() == c); // 18 35:getstatic #25 &lt;Field PrintStream System.out&gt; // 19 38:aload_1 // 20 39:invokevirtual #37 &lt;Method int Integer.intValue()&gt; // 21 42:iload_3 // 22 43:icmpne 50 // 23 46:iconst_1 // 24 47:goto 51 // 25 50:iconst_0 // 26 51:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; // 27 54:return &#125;&#125; 可以看到第20, 22行，调用了Integer方法.valueOf(int)自动装箱：1Integer b = 8; 1Integer b = Integer.valueOf(8); 第36行,调用了Integer方法.intValue()自动拆箱：1System.out.println(a == c); 1System.out.println(a.intValue() == c); 所以：a == c的结果为true 例1中123Integer a = new Integer(8);Integer b = 8;System.out.println(a == b); 结果为何为false？ 刚讲到了1Integer b = 8; 调用了Integer方法.valueOf(int)自动装箱，我们来看下.valueOf(int)源码实现：123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 也就是说最后会new出来一个Integer对象或者返回缓存中的数据。注意： ==符号在比较对象时，比较的是内存地址; 对于原始数据类型(如上面a == c)直接比对的是数据值。 这里又涉及到了堆栈内存了，需要清楚2点： new出来的对象或创建的数组会在堆中开辟内存空间； 对象的引用（即对象在堆内存中的地址，如a）和基本数据类型存储在栈中； 由此可知a,b引用指向的对象不是同一个，所以结果是false 知识点二：Integer缓存在上面的.valueOf(int)源码中我们能看到IntegerCache类，看名称就知道是和缓存有关。我们来看下Integer类的静态内部类IntegerCache源码实现：1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125; 该类中有一个静态数组：1static final Integer cache[]; 还有一个静态代码块:1static &#123;...&#125; 既然是在static静态类的静态代码快中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到静态代码快主要是向静态数组中添加了[-128,127],也就要是说，调用方法.valueOf(int)传入的int值在[-128,127]这个范围内时，直接从IntegerCache的缓存数组中获取， 不会去在堆内存中new。 [-128,127]期间的数字比较常用，这一行为有助于节省内存、提高性能。 12if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; 所以在例2中：1.自动装箱调用方法Integer.valueOf(int)12345678910111213141516171819public static void main(String args[]) &#123; Integer f1 = Integer.valueOf(100); // 0 0:bipush 100 // 1 2:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 2 5:astore_1 Integer f2 = Integer.valueOf(100); // 3 6:bipush 100 // 4 8:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 5 11:astore_2 Integer f3 = Integer.valueOf(250); // 6 12:sipush 250 // 7 15:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 8 18:astore_3 Integer f4 = Integer.valueOf(250); // 9 19:sipush 250 // 10 22:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 11 25:astore 4 &#125; 2.通过Integer.valueOf(int)内部调用IntegerCache类实现。由于f1,f2对应的基本值在[-128,127]之间，结果返回true;而f3,f4对应的基本值不在范围内，结果返回false 其他的包装类型也可以类似分析，回头再总结。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
        <tag>包装类型</tag>
        <tag>自动包装</tag>
        <tag>自动拆箱</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
