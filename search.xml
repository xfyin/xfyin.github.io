<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[反编译小工具：jad常用命令介绍]]></title>
    <url>%2F2017%2F11%2F06%2Fjad-cmd-introduce%2F</url>
    <content type="text"><![CDATA[jad是最简单的字节码.class反编译出源码.java的小工具。是jdk自带的，我的在‪D:\Java\jdk1.7.0_80\bin\jad.exe。 jad常用命令 -o 不提示，覆盖源文件，例如：1jad -o example.class 若当前目录下有example.jad文件（默认扩展名jad），执行该命令后会覆盖原example.jad文件 -s 指定输出文件的类型，例如：1jad -s java example.class 反编译结果以.java为扩展名。 -p 将反编译结果输出到cmd窗口，例如：1jad -p example.class 反编译结果直接在cmd界面显示。 &gt; 将反编译结果重定向到文件，例如：1jad -p example.class &gt; example1.java 在当前目录下，将example.class反编译后输出到example1.java文件中。 -d 指定反编译的输出文件目录，例如：1jad -d test example.class 在当前目录下会产生目录test，里面有example.jad文件 常用命令组合1jad -a -o -s java example.class 用JVM字节码格式来注解输出(-a)； 覆盖原文件（-o）； 以java扩展名输出example文件（-s java） jad帮助信息jad的帮助信息如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Options: //用JVM字节格式来注解输出 -a - generate JVM instructions as comments (annotate) //同 -a,但是注解的时候用全名称 -af - output fully qualified names when annotating //输出多于的括号 (e.g., if(a) &#123; b(); &#125;, default: no) -b - generate redundant braces (braces) //清除所有的前缀 -clear - clear all prefixes, including the default ones //指定输出文件的文件目录 -d &lt;dir&gt; - directory for output files //试图反编译代码的dead 部分(default: no) -dead - try to decompile dead parts of code (if there are any) //不用用字节码的方式反编译 (no JAVA source generated) -dis - disassembler only (disassembler) //输出整个的名字,无论是类还是方法 -f - generate fully qualified names (fullnames) //输出类的成员在方法之前 (default: after methods) -ff - output fields before methods (fieldsfirst) //输出所有的变量的缺省的最初值 -i - print default initializers for fields (definits) //将strings分割成指定数目的块的字符 (default: no) -l&lt;num&gt; - split strings into pieces of max &lt;num&gt; chars (splitstr) //将输出文件用行号来注解 (default: no) -lnc - output original line numbers as comments (lnc) //分割strings用新行字符 newline character (default: no) -nl - split strings on newline characters (splitstr) //不要转换java的定义符 (default: do) -noconv - don&apos;t convert Java identifiers into valid ones (noconv) //不要生成辅助文件 -nocast - don&apos;t generate auxiliary casts //不要生成方法的源代码 -nocode - don&apos;t generate the source code for methods //不允许空的构造器存在 -noctor - suppress the empty constructors //不要去检查class文件是否以dos方式写 (CR before NL, default: check) -nodos - turn off check for class files written in DOS mode //关掉对内部类的支持 (default: turn on) -noinner - turn off the support of inner classes //忽略局部变量的表信息 -nolvt - ignore Local Variable Table entries (nolvt) //不要输出一个新行在打开一个括号之前 (default: do) -nonlb - don&apos;t insert a newline before opening brace (nonlb) //无需确认直接覆盖输出 (default: no) -o - overwrite output files without confirmation //发送反编译代码到标准输出 STDOUT (e.g., for piping) -p - send all output to STDOUT (for piping) //在生成源代码时将所有的包加前缀 -pa &lt;pfx&gt;- prefix for all packages in generated source files //用数字名字给所有的类加前缀 (default: _cls) -pc &lt;pfx&gt;- prefix for classes with numerical names (default: _cls) //给没有用到的异常的名字加前缀 -pe &lt;pfx&gt;- prefix for unused exception names (default: _ex) //用数字名字给所有的成员变量加前缀 (default: _fld) -pf &lt;pfx&gt;- prefix for fields with numerical names (default: _fld) //在&lt;num&gt; 的导入之后将其他引用包裹成一行导入 (default: 3) -pi&lt;num&gt; - pack imports into one line using .* (packimports) //给局部变量用数字名字加前缀 (default: _lcl) -pl &lt;pfx&gt;- prefix for locals with numerical names (default: _lcl) //给方法用数字名字加前缀 (default: _mth) -pm &lt;pfx&gt;- prefix for methods with numerical names (default: _mth) //给方法的参数用数字名字加前缀 (default: _prm) -pp &lt;pfx&gt;- prefix for method parms with numerical names (default:_prm) //将同类型的成员包裹成一行 (default: no) -pv&lt;num&gt; - pack fields with the same types into one line (packfields) //恢复包的目录结构 -r - restore package directory structure //指定输出文件的类型 (by default &apos;.jad&apos;) -s &lt;ext&gt; - output file extension (default: .jad) //遇到关键字(if/for/while/etc)输出空格和表达式 (default: off) -space - output space between keyword (if, while, etc) and expression //显示所有的类，方法，成员变量的总数 -stat - show the total number of processed classes/methods/fields //用 &lt;num&gt;个的空格 (default: 4) -t&lt;num&gt; - use &lt;num&gt; spaces for indentation (default: 4) //用tabs代替空格对于边缘 -t - use tabs instead of spaces for indentation //正在反编译的时候 显示方法的名字 -v - show method names while decompiling //将 UNICODE strings 转换成 8-bit strings，用当前的 ANSI 码页 (Win32 only) -8 - convert Unicode strings into ANSI strings (ansi) //重新定向 STDERR to STDOUT (Win32 only) -&amp; - redirect STDERR to STDOUT]]></content>
      <categories>
        <category>小工具</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>jad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题： 抽象类（abstract class）和接口（interface）解析]]></title>
    <url>%2F2017%2F11%2F05%2Fabstract-and-interface%2F</url>
    <content type="text"><![CDATA[概念抽象类：包含抽象方法的类就称为 抽象类；接口： 抽象方法的集合，方法没有具体实现即不包含方法体。 两者异同相同点 都不能被实例化； 接口的实现类或抽象类的子类都必须实现接口或抽象类中的方法后才能被实例化 不同点 接口中的方法是高度抽象的，只有定义，没有具体的实现；抽象类中可以有定义也可以有实现； 接口中的方法默认为public abstract， 可以直接写public， 可以都省略不写；接口中方法修饰符不能是private， 接口需要实现，所以私有的方法没有意义；抽象类中的具体实现的方法和普通的类一样，而只有定义的方法必须用abstract修饰，不然编译不通过；而且抽象方法的修饰符不能是private，static，synchronized，native，能用默认的，public和protected。 接口中定义变量默认为public static final， 并且要赋予初始值，不然编译不通过；抽象类和普通的类一样，可以有自己的成员变量，可以重新赋值； 接口需要实现（implements）， 抽象类需要继承（extends），一个类可以实现多个接口，但是只能继承一个抽象类（单继承多实现）。 接口三问接口方法能否用private修饰 不能。因为接口是对外开放的，需要具体的类来实现其中的方法，私有的方法作用范围为本类，在接口中定义私有方法没有任何意义，编译不会通过。 接口方法能否用synchronized修饰 不能。synchronized是一种同步锁，在修饰方法时，需要具体逻辑，而接口只是定义，因为直接修饰接口中的方法没意义，可以用来修饰接口方法的具体实现。 接口方法能否用static修饰 这和jdk版本有关。jdk8之前：不能；jdk8新特性： 能。——参见JDK8新特性之接口的静态方法和默认方法 举例这里提供两种方式：jad反编译和反射来获取成员变量和方法的相关内容。 jad反编译下面先给出对应源码，再用jad反编译.class文件。反编译执行命令如下：1jad -a -o -s java 类名.class jad命令参见反编译小工具：jad常用命令介绍 接口.java源码MyInterface.java接口源码如下：123456public interface MyInterface &#123; String name = "MyInterface"; void add();&#125; 接口.class反编译MyInterface.class反编译结果如下：123456public interface MyInterface &#123; public abstract void add(); public static final String name = "MyInterface";&#125; 可以看到， 1.在成员变量（常量）中默认的修饰符是public static final;2.在方法中，默认的修饰符是public abstract 抽象类.java源码MyAbstract抽象类源码如下：1234567891011public abstract class MyAbstract &#123; public String name; void get() &#123; System.out.println("MyAbstract get() "); &#125; // 抽象类中的没有实现的方法必须是“abstract” abstract void delete();&#125; 抽象类.class反编译1234567891011121314public abstract class MyAbstract &#123; public MyAbstract() &#123; &#125; void get() &#123; System.out.println("MyAbstract get() "); &#125; abstract void delete(); public String name;&#125; 可以看到，成员方法和成员变量和普通类一样，是什么修饰就是什么。 反射获取这里新建一个MyTest类，继承抽象类MyAbstract，并且实现接口MyInterface 反射代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class MyTest extends MyAbstract implements MyInterface &#123; public static void main(String[] args) &#123; Field[] abstractFields = MyAbstract.class.getDeclaredFields(); Method[] abstractMethods = MyAbstract.class.getDeclaredMethods(); System.out.println("抽象类MyAbstract成员变量反射信息："); for (Field f : abstractFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("抽象类MyAbstract成员方法反射信息："); for (Method m : abstractMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType() + "\n"); &#125; Field[] interfaceFields = MyInterface.class.getDeclaredFields(); Method[] interfaceMethods = MyInterface.class.getDeclaredMethods(); System.out.println(); System.out.println("接口MyInterface成员变量反射信息："); for (Field f : interfaceFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("接口MyInterface成员方法反射信息："); for (Method m : interfaceMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType()); &#125; &#125; @Override public void add() &#123; &#125; @Override void delete() &#123; &#125;&#125; 运行结果1234567891011121314151617181920212223抽象类MyAbstract成员变量反射信息：变量名：name修饰符：public变量类型：class java.lang.String抽象类MyAbstract成员方法反射信息：方法名：get修饰符：返回类型：void方法名：delete修饰符：abstract返回类型：void接口MyInterface成员变量反射信息：变量名：name修饰符：public static final变量类型：class java.lang.String接口MyInterface成员方法反射信息：方法名：add修饰符：public abstract返回类型：void 可以看到，和jad反编译的结果是一样的。 具体的反射机制请参见另一篇博文简单聊聊反射机制]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>反射</tag>
        <tag>jdk8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8新特性之接口的静态方法和默认方法]]></title>
    <url>%2F2017%2F11%2F05%2FJDK8-static-and-default%2F</url>
    <content type="text"><![CDATA[JDK8之前我们在接口中定义成员变量只能是public static final的，定义的成员方法只能是public abstract的，默认省略。JDK8前后这一概念等价。定义接口BeforeJDK8Interface如下：name和name1表述等价，getName()和getName1()表述等价。12345678910111213public interface BeforeJDK8Interface &#123; String name = "BeforeJDK8Interface"; //public、 static、 final 可以单独使用，也可以组合使用 public static final String name1 = "BeforeJDK8Interface"; void getName(); //public、 abstract 可以单独使用，也可以组合使用 public abstract void getName1();&#125; JDK8新增特性，允许我们在接口中定义default默认方法和static静态方法。定义接口JDK8Interface如下：1234567891011public interface JDK8Interface &#123; default void myDefaultMethod() &#123; System.out.println("JDK8新特性:接口中的默认方法"); &#125; static void myStaticMethod() &#123; System.out.println("JDK8新特性：接口中的静态方法"); &#125;&#125; 实现接口时，这里static方法由于static的原因，属于接口类，只能通过 接口类名直接调用；而default方法，需要 接口实现类实例化后调用。定义接口实现类JDK8InterfaceImpl如下：12345678public class JDK8InterfaceImpl implements JDK8Interface &#123; public static void main(String[] args) &#123; JDK8Interface.myStaticMethod(); JDK8InterfaceImpl jdk8Interface = new JDK8InterfaceImpl(); jdk8Interface.myDefaultMethod(); &#125;&#125; 由于static的原因，静态方法不能重写；但是default方法却可以，重写myDefaultMethod代码如下：123456789public class JDK8InterfaceImpl implements JDK8Interface &#123; ... @Override public void myDefaultMethod() &#123; System.out.println("接口中的default方法不满足需求，需要重写"); &#125;&#125; 这里稍注意下，JDK8Interface接口中default方法用了修饰符&quot;default&quot;，这里重写后修饰符是&quot;public&quot; 由于java实行的是单继承extends多实现implements，那JDK8新增特性中的两个方法有啥要求不？ 首先看看static方法，由于调用static方法时，用的是接口类名，不能的接口类名肯定不同，所以没影响； 对于default方法， 有于是实现类实例化后调用，若该类有多个接口且接口中有相同名称的default方法，这时候编译器就没办法区分了，会报错，必须重写default方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDK8新特</tag>
        <tag>静态方法</tag>
        <tag>默认方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题：重载（Overload）和重写（Override）解析]]></title>
    <url>%2F2017%2F11%2F02%2Foverload-and-override%2F</url>
    <content type="text"><![CDATA[方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 概念重载Overload 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。 访问修饰符：重载与访问修饰符无关 返回类型： 重载与返回值无关 方法名： 重载方法名需完全一致 参数列表： 重载参数列表需完全不同 重写Override 发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。 访问修饰符：子类的访问修饰符权限 &gt;= 父类的访问修饰符权限 返回类型： 子类的返回类型 &lt;= 父类的返回类型 方法名： 方法名应完全一致 参数列表： 参数列表应完全一致 举例String类重载例子String类的构造器重载：1234567public String() &#123; this.value = new char[0];&#125;public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; String类的valueOf()方法的重载：1234567public static String valueOf(char data[]) &#123; return new String(data); &#125; public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; 重写例子ArrayList继承了AbstractList类1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; AbstractList类中有方法add()：1234public boolean add(E e) &#123; add(size(), e); return true;&#125; ArrayList类中有重写了add()方法：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 多态面向对象编程有三大特性：封装、继承、多态。 概念 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding）多态存在的三个必要条件 1. 要有继承； 2. 要有重写； 3. 父类引用指向子类对象。 根据何时确定执行多态方法中的哪一个，多态分为两种情况：编译时多态和运行时多态。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。 编译时多态重载都是编译时多态，从上面的分析可以看到，只要确定了方法参数的数据类型,个数,次序就能确定调用哪一个方法。 运行时多态重写有两种多态性，当对象引用本类实例，此时为编译时多态，能在编译期确定调用哪个方法；否则为运行时多态。 举例分析123456789101112131415package test;public class Test &#123; &#125;class Animal&#123; public String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String getName() &#123; return "Dog"; &#125;&#125; 1.执行下面的main方法123456public static void main(String[] args) &#123; Animal animal = new Animal(); Dog dog = new Dog(); System.out.println(animal.getName()); System.out.println(dog.getName());&#125; 输出结果：12AnimalDog Animal和Dog引用的都是本类的实例12Animal animal = new Animal();Dog dog = new Dog(); 2.若是这样呢？输入结果是多少1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName());&#125; 此时输出：1Dog 程序在运行时，会从实例所属的类开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照继承关系逐层向上查找，直到超级父类Object类。该例子animal.getName()执行过程是： 3.修改Animal类, 空类12class Animal&#123;&#125; 此时执行方法：1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(((Dog) animal).getName());&#125; 需要显示地转换下((Dog) animal).getName(),因为Animal类中没有定义getName()方法。 4.修改Animal,Dog类的getName()方法为静态方法,并增加一成员变量name1234567891011121314class Animal &#123; public String name = "a"; public static String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String name = "d"; public static String getName() &#123; return "Dog"; &#125; 执行main方法：12345public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName()); System.out.println(animal.name);&#125; 输出结果为：12Animala 结果解释：1.重写只使用于实例方法，不能用于静态方法，对于static方法，只能隐藏,重载,继承；2.在利用引用animal访问对象的属性name或静态方法getName()时，是引用类型决定了实际上访问的是哪个对象（Animal）的成员，而不是当前引用代表的那个类（new Dog()）;由此可知，子类静态方法并不能重写（覆盖）父类的静态方法;故而输出的结果都是父类的成员结果。 为什么不能根据返回类型来区分重载假设下面的重载方法update能编译通过123456789public class Test &#123; public void update() &#123; &#125; public int update() &#123; return 0; &#125;&#125; 当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。方法的返回值,只能作为方法运行之后得一个状态，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的标示。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
        <tag>多态</tag>
        <tag>编译时多态</tag>
        <tag>运行时多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题：int和Integer解析]]></title>
    <url>%2F2017%2F11%2F02%2Fint-and-Integer%2F</url>
    <content type="text"><![CDATA[Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 两个常见的面试例子先看两个常见的例子，后面会针对例子加以分析。例11234567public static void main(String[] args) &#123; Integer a = new Integer(8); Integer b = 8; int c = 8; System.out.println(a == b); System.out.println(a == c); &#125; 1执行结果： false, true 例2 12345public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 250, f4 = 250; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125; 1执行结果： true, false 知识点一：自动拆箱与自动包装概念1.自动拆箱： 自动将包装器类型转换为基本数据类型； 2.自动包装： 自动将基本数据类型转换为包装器类型。 具体分析例1中1234Integer b = 8; //自动装箱//Integer a = new Integer(8);//int c = 8;System.out.println(a == c) // 自动拆箱 注意：Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是intValue()方法。 对例1反编译看看(这里用jad来反编译), Test是例子中的类名。下面命令将输出带字节码注释和源码 -a表示用JVM字节格式来注解输出; -o表示无需确认直接覆盖输出; -s表示定义输出文件的扩展名,默认的扩展名是jad; java表示我们想要的反编译后输出java格式文件 jad详细命令参见反编译小工具：jad常用命令介绍1jad -a -o -s java Test.class 反编译结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package test;import java.io.PrintStream;public class Test &#123; public Test() &#123; // 0 0:aload_0 // 1 1:invokespecial #8 &lt;Method void Object()&gt; // 2 4:return &#125; public static void main(String args[]) &#123; Integer a = new Integer(8); // 0 0:new #16 &lt;Class Integer&gt; // 1 3:dup // 2 4:bipush 8 // 3 6:invokespecial #18 &lt;Method void Integer(int)&gt; // 4 9:astore_1 Integer b = Integer.valueOf(8); // 5 10:bipush 8 // 6 12:invokestatic #21 &lt;Method Integer Integer.valueOf(int)&gt; // 7 15:astore_2 int c = 8; // 8 16:bipush 8 // 9 18:istore_3 System.out.println(a == b); // 10 19:getstatic #25 &lt;Field PrintStream System.out&gt; // 11 22:aload_1 // 12 23:aload_2 // 13 24:if_acmpne 31 // 14 27:iconst_1 // 15 28:goto 32 // 16 31:iconst_0 // 17 32:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; System.out.println(a.intValue() == c); // 18 35:getstatic #25 &lt;Field PrintStream System.out&gt; // 19 38:aload_1 // 20 39:invokevirtual #37 &lt;Method int Integer.intValue()&gt; // 21 42:iload_3 // 22 43:icmpne 50 // 23 46:iconst_1 // 24 47:goto 51 // 25 50:iconst_0 // 26 51:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; // 27 54:return &#125;&#125; 可以看到第20, 22行，调用了Integer方法.valueOf(int)自动装箱：1Integer b = 8; 1Integer b = Integer.valueOf(8); 第36行,调用了Integer方法.intValue()自动拆箱：1System.out.println(a == c); 1System.out.println(a.intValue() == c); 所以：a == c的结果为true 例1中123Integer a = new Integer(8);Integer b = 8;System.out.println(a == b); 结果为何为false？ 刚讲到了1Integer b = 8; 调用了Integer方法.valueOf(int)自动装箱，我们来看下.valueOf(int)源码实现：123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 也就是说最后会new出来一个Integer对象或者返回缓存中的数据。注意： ==符号在比较对象时，比较的是内存地址; 对于原始数据类型(如上面a == c)直接比对的是数据值。 这里又涉及到了堆栈内存了，需要清楚2点： new出来的对象或创建的数组会在堆中开辟内存空间； 对象的引用（即对象在堆内存中的地址，如a）和基本数据类型存储在栈中； 由此可知a,b引用指向的对象不是同一个，所以结果是false 知识点二：Integer缓存在上面的.valueOf(int)源码中我们能看到IntegerCache类，看名称就知道是和缓存有关。我们来看下Integer类的静态内部类IntegerCache源码实现：1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125; 该类中有一个静态数组：1static final Integer cache[]; 还有一个静态代码块:1static &#123;...&#125; 既然是在static静态类的静态代码快中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到静态代码快主要是向静态数组中添加了[-128,127],也就要是说，调用方法.valueOf(int)传入的int值在[-128,127]这个范围内时，直接从IntegerCache的缓存数组中获取， 不会去在堆内存中new。 [-128,127]期间的数字比较常用，这一行为有助于节省内存、提高性能。 12if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; 所以在例2中：1.自动装箱调用方法Integer.valueOf(int)12345678910111213141516171819public static void main(String args[]) &#123; Integer f1 = Integer.valueOf(100); // 0 0:bipush 100 // 1 2:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 2 5:astore_1 Integer f2 = Integer.valueOf(100); // 3 6:bipush 100 // 4 8:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 5 11:astore_2 Integer f3 = Integer.valueOf(250); // 6 12:sipush 250 // 7 15:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 8 18:astore_3 Integer f4 = Integer.valueOf(250); // 9 19:sipush 250 // 10 22:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 11 25:astore 4 &#125; 2.通过Integer.valueOf(int)内部调用IntegerCache类实现。由于f1,f2对应的基本值在[-128,127]之间，结果返回true;而f3,f4对应的基本值不在范围内，结果返回false 其他的包装类型也可以类似分析，回头再总结。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
        <tag>包装类型</tag>
        <tag>自动包装</tag>
        <tag>自动拆箱</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
