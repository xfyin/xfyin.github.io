<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我所理解的虚拟机类加载机制]]></title>
    <url>%2F2018%2F04%2F01%2Fclassloader-of-jvm%2F</url>
    <content type="text"><![CDATA[引言工作中，绝大多数我们多只关心业务逻辑实现，对于实现业务的类的生命周期并没有怎么关注。在我们实现业务逻辑时，不知不觉用到最多的就是类的生命周期中的“使用”阶段。 曾经我也试着去看关于类加载的一些博客或者虚拟机相关的书籍，初看时一知半解，文字上能懂得七七八八，但是真正的含义却知甚微。经过对基础知识的积累，再次回头看，一阵顿悟。虽然有些还是不能完全理解，但确实感觉到了很大的进步，特此记录。若有理解错误之处，请指出。 类加载机制的含义首先，关于虚拟机的类加载机制的含义。 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、准备、解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 这句话不长，以前看这句话时，眼前只有文字，脑子里没有画面。现在看时，仿佛看到了一幅动态图。我们知道，编写的是以.java结尾的源文件。但虚拟机并不能直接读这个源文件，这就需要编译器将其编译成字节码文件.class。 我们知道java有个著名的宣传口号：一次编译，到处运行。这是因为各种不同的虚拟机和平台都统一使用程序存储格式——字节码（ByteCode），而虚拟机执行的正是这种字节码。 下面的讲解，其实都是围绕虚拟机的类加载机制展开的。 类加载过程从类被加载到内存，直到被卸载出内存，类的生命周期包括这7个阶段：加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析又被统称为连接。 首先要明确一点，“加载”只是“类加载”其中一个阶段，类加载包括了加载、验证、准备、解析以及初始化这5几个阶段，下面以这5个阶段展开。 加载通过虚拟机类加载机制的含义可以知道，这个阶段就是“虚拟机把描述类的数据从Class文件加载到内存”。那么加载阶段具体做了些什么呢？ 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。 在我们进行传统的JDBC编程时，我们注册驱动时，会通过下面的代码实现：1Class.forName("com.mysql.jdbc.Driver"); 相必大家都知道这个是用来注册mysql的驱动，这是JDBC编程的第一步，至于这里面做了啥，貌似都不怎么清楚。 具体分析下： 我们看上面第1点说到的“类的全限定名”，这里“com.mysql.jdbc.Driver”就是mysql驱动的全限定名；而“二进制字节流”可以认为是Class文件存在的一种形式； java源文件中存在的类变量，也就是static修饰的变量，经过编译后的Class文件，现在存在于字节流中，此时转化为方法区的运行时数据结构了。我们经常听说，静态变量存储于方法区中，就是这时候处理的，是不是有点顿悟的感觉？（可能JVM又有了新的规定，但不在考虑范围内） 关于第3点，我们在利用反射获取对象信息时，（可参见：反射机制基础解析）一般这么处理过： 12345678910public static void main(String[] args) throws Exception &#123; // 获取Class对象 Class&lt;?&gt; clz = Class.forName("test.MyReflectTest"); // 获取实例 Object o = clz.newInstance(); // 获取构造器 Constructor[] cons = clz.getConstructors(); // 获取方法 Method[] methods = clz.getMethods();&#125; 生成了一个Class对象，并且这个对象是个入口，能获取实例，构造器、方法等等。这就是类加载的第一个阶段，我算是明白很多了。 验证验证阶段是连接的第一步，验证也就是校验，看看是否合法。也就是为了确保加载进来的Class文件的字节流中包含的信息是否符合当前虚拟机的要求，这和我们平时写程序时，对传入的参数进行校验道理是一样的。 校验的内容有很多：文件格式、元数据、字节码、符号引用等。要想了解详情，看书吧。 准备先看个例子，别看答案，这两种情况下将输出什么结果，猜猜吧！1234567891011121314151617181920package com.example;public class StaticTest &#123; public static Test t = new Test(); // #0 public static int numOne = 0; // #1 public static int numTwo; // #2 public static void main(String[] arg) &#123; System.out.println(StaticTest.numOne); System.out.println(StaticTest.numTwo); &#125;&#125;class Test &#123; public Test() &#123; StaticTest.numOne++; StaticTest.numTwo++; &#125;&#125; 稍稍改动下：#2处变动为：1public static int numTwo = 2; // #2 &nbsp;想&nbsp;好&nbsp;答&nbsp;案&nbsp;了&nbsp;么&nbsp;？&nbsp;答&nbsp;案&nbsp;即&nbsp;将&nbsp;揭&nbsp;晓&nbsp;.&nbsp;.&nbsp;.修改前输出的结果：10 1 修改后输出的结果：10 2 准备阶段之前，只进行2个动作： 将Class文件加载到内存； 对Class文件进行校验。 而这一阶段主要是：为类变量（static）分配内存并设置类变量初始值。 分配内存没什么好说的，在加载阶段的第2步中， 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。 既然已经放到方法区，自然要给它们存储的空间吧，所以为类变量分配所需要的内存。 设置类变量初始值。这里要注意，这里设置的是虚拟机内数据类型的零值。 下表中的是基本数据类型的零值。 数据类型 零值 数据类型 零值 int 0 boolean false long 0L float 0.0f short (short)0 double 0.0d char ‘\u0000’ reference null byte (byte)0 上面的例子中： 1public static int numTwo = 2; // #2 在这个“准备阶段”，numTwo设置的初始值就是0了，而numTwo = 2这个赋值动作，在这个阶段并没有进行，而是在程序编译后，存放在一个叫&lt; clinit&gt;()方法的类构造器中，在后面的初始化阶段才会执行。既然要涉及到初始化阶段，等讲到了初始化时，再分析下这个例子，先挂起。 解析这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，jvm会将所有的类、接口名、字段名、方法名等转换为具体的内存地址。 譬如：我们要在内存中找到一个类里面的一个叫call的方法，显然做不到，但是该阶段，由于jvm已经将call这个名字转换为指向方法区中的一块内存地址了，也就是说我们通过call这个方法名会得到具体的内存地址，也就找到了call在内存中的位置了。 主要包括解析内容有：类或接口的解析，字段的解析，类方法的解析以及接口方法的解析。 初始化初始化，是类加载的最后一步了。虚拟机规范中有严格的规定：有且仅有5种 情况必须立即对类进行“初始化”： 使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已经在编译器把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候； 使用java.lang.reflect包的方法进行反射调用时，若类没有进行初始化，需要先触发其初始化； 当初始化一个类时，若其父类还没有进行初始化，则需要先触发其父类的初始化； 执行main方法，虚拟机会先初始化其包含的那个主类； 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。 我们见到最常见的一种情形就是第1点了。 我们在“准备”阶段提到过类构造器&lt; clinit&gt;()方法，这一阶段的主要操作就是：执行类构造器&lt; clinit&gt;()方法的过程。1public static int numTwo = 2; // #2 准备阶段 赋予 numTwo 初始值为“0”，此阶段会将赋值（初始化）为“2”。 我们对前面的例子debug一下，看看debug的运行路线：我们观察下，左边红框区域。有两个方法&lt; init&gt;、&lt; clinit&gt;，分别 是实例初始化方法 和 类与接口初始化方法。 你可以亲自debug下，会发现很有意思的情况。其实和上面讲的，对于int数据类型：numOne、numTwo，在准备阶段的值是 0；reference数据类型：t，在准备阶段的值是 null，和前面提到的吻合。 在 3个debug 处，先出现的 第三处，也就是 Test类的构造器 处（准备阶段已经执行完毕了）。我们知道main()方法是程序的入口，这个debug模式也是：右键 =&gt; ‘StaticTest.main’，但是main()方法中的代码却没有立即执行。换句话说， 这时候还是类加载的过程，也可以说是执行前的准备阶段。 为啥先出现的是第三处debug，前面提到“有且仅有5种”必须立即“初始化”的情况之一：当发生了new动作，读取或设置静态字段。 所以在Test类的构造器中通过 “++”， 将 numOne、numTwo 的值设置为“1， 1”，然后经过第3处，numOne的值初始化为 0， 而 numTwo因为没有显示设置初始值，所以这里还是 1，结果就是“0 1”了。 而修改后由于 numTwo 显示地设置了初始值为“2”，所以结果就成了“0 2”。 我们再稍微调整下代码的顺序，其他不变;123public static int numOne = 0; // #1public static int numTwo = 2; // #2public static Test t = new Test(); // #0 结果是啥？应该不难判断11 3 这里想说的是，&lt; clinit&gt;方法是由编译器自动收集类中的所有类变量的赋值动作（numTwo = 2）和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。所以这里执行的顺序是： #1 =&gt; #2 =&gt; #0。 类加载器在上面的类生命周期的第一阶段：加载，提到： 通过一个类的全限定名来获取定义此类的二进制字节流 实现这个动作的代码模块称之为“类加载器”。 我们在比较两个类是否相等时，前提是这两个类是用同一个类加载器加载进来的，这个在逻辑上还是很好理解的。 分类从Java虚拟机的角度来讲，分为两类类加载器： 启动类加载器（Bootstrap ClassLoader），由C++语言实现，是虚拟机自身的一部分； 其他类加载器，由Java语言实现，独立于虚拟机外部，并且都 继承自抽象类java.lang.ClassLoader。 从我们开发人员角度来看，一般把类加载器分为4种：启动类加载器、扩展类加载器、应用程序类加载器和自定义类加载器。 启动类加载器（Bootstrap ClassLoader），负责将&lt; JAVA_HOME&gt;\lib目录下的，或者被 -Xbootclasspath参数指定的路径，并且是虚拟机识别的类库加载到虚拟机内存中； 扩展类加载器（Extension ClassLoader），负责将&lt; JAVA_HOME&gt;\lib\ext目录下的，或者被java.ext.dirs系统变量指定的类库； 应用程序类加载器（Application ClassLoader），由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此也称之为 系统类加载器；负责加载用户类路径（ClassPath）上指定的类库；一般这个就是程序中默认的类加载器。 自定义类加载器，若需要自定义一个类加载器，只需要模仿前面的类加载器，继承自抽象类java.lang.ClassLoader，并覆盖findClass方法即可。 双亲委派模式原理 双亲委派模式要求，除了顶层的启动类加载器外，其他的类加载器都应该有自己的父类加载器。 工作过程： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，依次向上。按照模型图，最后都会委派到启动类加载器那。若父类加载器在它的搜索范围内，没有找到这个类时，会向下反馈无法完成这个委派请求，此时子类加载器才会尝试自己去加载。 之所以这么做，有一个很明显的好处。我们都知道 java.lang.Object是所有类的父类，也即 超类，它放在lib\rt.jar中。无论编写的是哪一个类，都需要去加载这个超类，这时候都委派给顶层的启动类加载器去加载，因此这个Object类在各种类加载器环境中都是同一个类。若不采用双亲委派模型，那么我们自己编写这样一个Object类，放在ClassPath中，这样就会出现多个Object类，就乱了。 模型实现12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); // #1 if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); // #2 &#125; else &#123; c = findBootstrapClassOrNull(name); // #3 &#125; &#125; catch (ClassNotFoundException e) &#123; // #4 // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // #5 // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 这段代码主要讲： #1 先检查是够已经被加载过；#2 若没有加载则调用父加载器的loadClass()方法；#3 若父加载器为空，则默认使用启动类加载器作为父类加载器加载；#4 若父类加载失败了，抛出异常ClassNotFoundException；#5 再调用自身的findClass()方法来加载。 这些就是我所理解的虚拟机类加载机制，还有很多细节需要再研究研究，未完待续… 参考：《深入理解java虚拟机》]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>类加载</tag>
        <tag>双亲委派模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式：静态内部类]]></title>
    <url>%2F2018%2F03%2F24%2Fsingleteon-inner-class%2F</url>
    <content type="text"><![CDATA[下面的代码时用静态内部类实现的单例模式。1234567891011121314151617public class Singleton &#123; // 私有构造器，不允许外界通过new来获取实例 private Singleton() &#123; &#125; // 静态内部类 private static class InnerClassSingleton &#123; // 当类被加载的时候，static成员变量就会被初始化 private static Singleton singleton = new Singleton(); &#125; // 提供对外获取类的实例 public static Singleton getSingleton() &#123; return InnerClassSingleton.singleton; &#125;&#125; 简单分析下，为什么这种方式好。首先，当外界需要获取这个类的实例时候时，只需要调用下面的一行代码就可以获取，不能通过new的方式，这个和一般的单例写法是一致的。1Singleton singleton = Singleton.getSingleton(); 再者，当多线程访问时，也能保证只有一个实例。怎么保证的？我们知道，静态内部类在外部类实例化时，是不会被加载(初始化)的，具体请看下一篇文章：我所理解的虚拟机类加载机制 我们看个例子：1234567891011121314151617181920212223public class OutClass &#123; static &#123; System.out.println("loading OutClass..."); &#125; static class InnerClass&#123; static &#123; System.out.println("loading InnerClass..."); &#125; static void innerMethod() &#123; System.out.println("invoke innerMethod"); &#125; &#125; public static void main(String[] args) &#123; OutClass out = new OutClass(); System.err.println("================"); OutClass.InnerClass.innerMethod(); &#125;&#125; 执行结果：1234loading OutClass...================loading InnerClass...invoke innerMethod 通过debug模式，看下程序运行过程： 由于是静态，只会实例化一次：1private static Singleton singleton = new Singleton(); 所以，静态内部类的单例模式，实现了懒加载，又由JVM保证了多线程并发访问的正确性。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>静态内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式：双重检查 + synchronized关键字 + volitle关键字]]></title>
    <url>%2F2018%2F03%2F18%2Fsingleteon-doublecheck-syn-volitle%2F</url>
    <content type="text"><![CDATA[实现单例模式，有3个要点： 某个类只能有一个实例； 这个实例只能本类自己创建； 创建的这个实例必须向整个系统开放。 为了满足这3个要点，单例模式必须： 在本类中实例化； 构造器必须私有，外界不能通过调用构造器创建对象； 必须对外提供一个静态的方法供外界获取该类的实例。 一个完整的双重检查 + synchronized关键字 + volitle关键字单例模式如下：123456789101112131415161718public class Singleton &#123; private static volatile Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这里面有3个关键点： 1. 用到了关键字volatile；2. 用到了关键字synchronized；3. 用到了双重检查if (singleton == null) 来来来，我们给这个单例模式加点料，来分析下，注意在 #0 中，去掉了 volatile：1234567891011121314151617181920212223242526272829303132333435package com.example;public class Singleton &#123; // 去掉了volatile关键字 private static Singleton singleton = null; //#0 public static int count_0 = 0; public static int count_1 = 0; public static int count_2 = 0; public static int count_3 = 0; public static int count_3_1 = 0; private Singleton() &#123; &#125; public static Singleton getSingleton() &#123; count_0++; if (singleton == null) &#123; // #1 count_1++; synchronized (Singleton.class) &#123; // #2 count_2++; if (singleton == null) &#123; // #3 count_3++; singleton = new Singleton(); // #4 System.err.println(Thread.class.getName() + "Singleton is null, it is being instantiated"); // #5 &#125; else &#123; count_3_1++; System.err.println(Thread.class.getName() + "Singleton is not null, because it has been instantiated"); // #6 &#125; &#125; &#125; return singleton; &#125;&#125; 测试类：1234567891011121314151617181920212223242526272829package com.example;public class SingletonTest &#123; public static void main(String[] args) throws InterruptedException &#123; int count = 0; for (int i = 0; i &lt; 5000; i++) &#123; count++; new Thread(new SingleThread(), "thread" + i + 1).start(); &#125; Thread.sleep(2000); System.err.println("count:" + count); System.err.println("count_0: " + Singleton.count_0); System.err.println("count_1: " + Singleton.count_1); System.err.println("count_2: " + Singleton.count_2); System.err.println("count_3: " + Singleton.count_3); System.err.println("count_3_1: " + Singleton.count_3_1); &#125; static class SingleThread implements Runnable &#123; @Override public void run() &#123; Singleton.getSingleton(); &#125; &#125;&#125; 运行结果：123456789java.lang.ThreadSingleton is null, it is being instantiatedjava.lang.ThreadSingleton is not null, because it has been instantiatedjava.lang.ThreadSingleton is not null, because it has been instantiatedcount:5000count_0: 4992count_1: 3count_2: 3count_3: 1count_3_1: 2 运行的结果并不唯一，现在以上面的结果分析下，#1处检测Singleton实例是否非空，从count_1 = 3，可以看出在这5000个线程中，有3个线程在获取Singleton实例时，实例还没有创建。在#2处，对这个类加锁synchronized，有1个线程获得了锁执行#2后面的代码，另外2个被阻塞在#2外面。获得锁的这个线程于是走过#3 #4 #5 创建了Singleton实例，然后释放了锁。剩下的2个线程中的1个此时获得了锁，另1个依旧阻塞，获得锁的在#3处检测Singleton实例是否非空，由于前面一个线程已经创建了实例，此时来到了#6处，释放锁；最后1个线程也一样。 一切看起来很正常，平常我们也是这么处理单例模式的，双重检查 + synchronized关键字，那为啥要有个volitle关键字呢？ 其实上面的程序运行，还可能出现类似这样的情况：123java.lang.ThreadSingleton is null, it is being instantiatedjava.lang.ThreadSingleton is null, it is being instantiatedjava.lang.ThreadSingleton is not null, because it has been instantiated 也即Singleton对象被实例化两（多）次，虽然我试着运行好几分钟，也没有出现这种情况，但是理论上是会出现的，为什么？注意到count_0这个变量，开启了5000个线程，理论上应该和count的结果是一样5000。而实际的结果值却是4992。我们知道成员变量存在堆内存中，静态成员变量存在于方法区中（java.8以后使用了元空间（meta space）来实现jvm的方法区定义），而堆内存和方法区都是共享的，能被多线程访问，这就涉及到多线程下的安全性问题了。而并发访问涉及到三个重要的概念：原子性、可见性、有序性。 原子性：在一个或多个操作中，要么全部执行且执行的过程不会被打断，要么全部不执行；可见性：在多线程访问共享变量时，一个线程对变量的修改，其他的线程会立即感知；有序性：程序的执行顺序是按照代码的顺序执行。 需要知道一点：在并发访问下，必须同时满足上面三个条件才行，缺一不可。 对于count_0++，这个自增动作： 不是原子性操作。包括读取变量，赋值，写入等动作。这又涉及到了java内存模型Java Memorry Model(JMM)这里就不深入了。 也不具备可见性。譬如count_0的原值是0，线程1读到count_0的值为0，并执行 ++动作，结果为1，还没来得及更新到主内存；此时线程2也读到了count_0的值为0，并没有立即读到线程1执行的结果，结果也为1。最后两个线程执行后更新到主内存的count_0的值是1，这就导致上面的count_0和count结果不一致的原因了。 同理，#0处的静态成员变量singleton也是线程不安全的。1Singleton singleton = new Singleton()； 不具备原子性和可见性。 那volatile关键字就具备了原子性、可见性和有序性么？我们先看下加上后的运行结果，修改代码，在变量count_0前面加上关键字volatile：1public static volatile int count_0 = 0; 运行结果：12345678java.lang.ThreadSingleton is null, it is being instantiatedjava.lang.ThreadSingleton is not null, because it has been instantiatedcount:5000count_0: 4998count_1: 2count_2: 2count_3: 1count_3_1: 1 我们发现count_0的结果依旧不等于count的值，也就是说还是线程不安全的。那么问题来了，在单例模式的双重检查中为啥还需要个volitle关键字呢？这里只给出它的作用：能保证可见性和一定的有序性（禁止指令重排序），但是不能保证原子性。根据这个结论，我们看看加了volitle关键字的单例双重检查 + synchronized关键字模式。1private static volatile Singleton singleton = null; //#0 volitle能保证可见性，也就是说只要一个线程对共享变量修改了，其他线程都能立即看到。有序性也是一定程度的，哪“不一定的程度”怎么保证呢？还有原子性怎么保证？这里别忘了，还有个synchronized关键字。synchronized是啥，是排他锁、同步锁，也就是说同一时刻只会有一个线程获得锁，其他的都在等待锁的释放。所以，synchronized就保证了有序性和原子性。 PS：count_0和singleton都是共享变量，从上面的运行结果看count_0出现不安全的概率有（5000-4998）/5000（很小），而5000个线程中只有几个进入了#1后，所以确实很不容易出现。 所以记得，在写单例模式时，用双重检查 + synchronized关键字 + voliltle关键字，这样才能保证绝对的安全。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>双重检查</tag>
        <tag>synchronized</tag>
        <tag>volitle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架的基本原理分析]]></title>
    <url>%2F2018%2F03%2F11%2Fthe-basic-principle-of-spring%2F</url>
    <content type="text"><![CDATA[引言工作有一段时间了，工作中基本每个项目都用到了Spring框架，说实话，很多人应该和我一样，只是“使用”了这个框架，对于框架的基本原理应该没怎么研究过。前段时间，和同事交流时，提到了Spring核心组件：IOC(控制反转)、AOP(面向切面编程)。交流的时候，只能大概说说，并不能完整讲出来。回来后，找相关文章和源码研究了下，特此记录。 Spring框架概念Spring是一个开源的容器框架，Spring可以接管Web层，业务层，Dao层，持久层组件。主要负责创建Bean以及维护Bean之间的关系。 Spring框架包括7大模块 ◆核心容器：核心容器提供 Spring框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 ◆Spring 上下文：Spring 上下文是一个配置文件，向 Spring框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 ◆Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 ◆Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 ◆Spring ORM：Spring框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 ◆Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 ◆Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring框架核心在项目中我们用到的Spring重要功能主要有两个：IOC和AOP，这里大致讲下这两个概念。 IOC 控制反转我们知道，一般来说要想实现一个功能，需要多个类协助才行。其中类A中，可能就需要类B、类C中的方法。为了能调用别的类的方法，首先得取得这个类的实例，即在类A中new一个类B、再new一个类C，也就是说调用者负责创建被调用者的实例。试想想下面这两种情形： 1. 若类A中还需要其他很多类协助；2. 类B、类C还需要协助很多其他类处理业务。 如此一来，会造成类A中越来越臃肿，越来越不好管理；类B、类C需要不断的创建。而采用Spring框架后，就不用这么麻烦了。创建类A、类B、类C的实例以及维护类A和类B、类C之间关系的责任就交给了Spring，它负责这些工作。也就是说本来是类A控制这些实例的创建，现在交由Spring框架了，所以控制反转(IOC)了。 还有一个相关概念 DI（Dependency Injection依赖注入），有说DI只是IOC的另一种说法，准确的说，DI是IOC的实现方式。类A依赖类B、类C，现在三个类都已经交给Spring管理了（控制反转），那类A怎么获得类B、类C的实例呢，这就是依赖注入。常见的依赖注入的方式有三种：setter方法，构造器方法，注解AutoWired方式。 AOP 面向切面编程程序在执行具体业务逻辑前、后，可能需要加入一些额外的东西，譬如：日志，事务等。在很多地方都需要加入这些额外的元素，但是这些方面和具体的业务逻辑并没有直接的关系。于是乎，就将这些额外的元素抽出来，加以封装，在特定的位置横切到方法的业务逻辑前后等位置。将业务和非业务的分开，极大程度解耦。 举个例子，当你的程序写好后，需要在所有的业务操作中添加一条日志，传统的做法是直接改造每个方法，但是这样势必让代码变糟糕，要是以后扩展起来那就更乱了。而AOP的思想就让你能从一个切面的角度来看待这些插入问题，AOP允许你以一种统一的方式在运行时期在想要的地方插入这些逻辑。专业一点的说法，什么是面向切面编程？ 这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 Spring框架原理示例讲原理前，先看个例子： 小汽车类Car1234567891011121314151617181920package com.example;public class Car &#123; private String name; private double price; // 省略getter，setter @Override public String toString() &#123; return "Car&#123;" + "name='" + name + '\'' + ", price=" + price + '&#125;'; &#125; public void carInfo() &#123; System.out.println("i have this car: " + name); &#125;&#125; 汽车拥有者类:Person123456789101112131415161718package com.example;public class Person &#123; private String name; private int age; private Car car; // 省略getter，setter @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + ", car=" + car + '&#125;'; &#125;&#125; Spring配置文件spring-config.xml12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="car" class="com.example.Car"&gt; &lt;property name="name" value="hongqi"/&gt; &lt;property name="price" value="1000000.0"/&gt; &lt;/bean&gt; &lt;bean id="person" class="com.example.Person"&gt; &lt;property name="name" value="zhaangsan"/&gt; &lt;property name="age" value="27"/&gt; &lt;property name="car" ref="car"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类SpringMain123456789101112131415161718package com.example;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain &#123; public static void main(String[] args) &#123; // 创建IOC容器 ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml"); // 通过getBean获取Car的实例，这里利用了反射 Car car = (Car) context.getBean("car"); car.carInfo(); System.out.println(car.toString()); Person person = (Person) context.getBean("person"); System.out.println(person.toString()); &#125;&#125; 执行结果：123i have this car: hongqiCar&#123;name=&apos;hongqi&apos;, price=1000000.0&#125;Person&#123;name=&apos;zhaangsan&apos;, age=27, car=Car&#123;name=&apos;hongqi&apos;, price=1000000.0&#125;&#125; 原理分析当执行new ClassPathXmlApplicationContext(“spring-config.xml”)这个动作时，Spring容器也即IOC容器随即创建。容器创建时，加载了保存所有bean信息的配置文件spring-config.xml，此时bean被创建，并保存到了内存中；随即通过context.getBean(“car”);获取相应的bean的实例，这里的car是配置文件中&lt; bean id=”car” …&gt;。 我们通过debug模式可以看到，在执行：1ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml"); 时，就已经将对应的属性值设置到对象中了，这里调用了setter方法或者构造器等。 这里我们来简单分析下，如何利用反射获取到了实例。 在Spring配置文件spring-config.xml中：1234&lt;bean id="car" class="com.example.Car"&gt; &lt;property name="name" value="hongqi"/&gt; &lt;property name="price" value="1000000.0"/&gt;&lt;/bean&gt; 首先容器读取到了&lt; bean … /&gt;节点，1. 读取id属性值，得到字符串“car”：1String idStr = "car"; 2. 读取class属性，得到全限定名字符串“com.example.Car”：1String classStr = "com.example.Car"; 3. 利用反射，通过全限定名获取Class对象：1Class&lt;?&gt; clz = Class.forName(classStr); 4. 接着实例化对象1Object obj = clz.newInstance(); 5. 加入到Spring容器中12// springContainer --&gt; MapspringContainer.put(idStr, obj); 而若一个类需要另一个类时，如下：1234&lt;bean id="person" class="com.example.Person"&gt; ... &lt;property name="car" ref="car"/&gt;&lt;/bean&gt; 解析&lt; property …/&gt;元素1. 获取name属性值car：1String nameStr = "car"; 2. 获取ref属性值car：1String refStr = "car"; 3. 生成将要调用setter方法名 ：1String setterName = "set" + nameStr.substring(0, 1).toUpperCase() + nameStr.substring(1); 4. 获取Spring容器中名为refStr的Bean1Object carBean = springContainer.get(refStr); 5. 获取setter方法的Method类，此处的clz是前面实例通过Class.forName()获得的类对象下面是Person类中的setCar(Car)方法123public void setCar(Car car) &#123; this.car = car;&#125; 通过反射，第一个参数是方法名，第二个参数是方法参数类型1Method setter = clz.getMethod(setterName, carBean.getClass()); 6. 调用invoke()方法，此处的obj是刚才反射代码得到的Object对象1public Object invoke(Object obj, Object... args)&#123;...&#125; 反射方法invoke中的参数，obj：从中调用底层方法的对象（简单的说就是调用谁的方法用谁的对象）；args：用于方法调用的参数，所以：1setter.invoke(obj, carBean); 到此，Spring框架原理基本介绍完毕。]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>Spring</tag>
        <tag>IOC</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传统的JDBC编程]]></title>
    <url>%2F2018%2F03%2F03%2Fjdbc-programming%2F</url>
    <content type="text"><![CDATA[ORM(Object Relational Mapping)，对象关系映射模型，我们常见的有两种：Hibernate，Mybatis，都是基于JDBC(Java Data Base Connectivity)进行封装的，只不过不同的ORM模型对JDBC封装的程度不一样。了解JDBC编程对理解ORM模型有益无害。Java程序都是通过JDBC连接数据库的，这样就可以通过SQL对数据库编程。JDBC是由原SUN公司提出的一系列规范，但也只定义了接口规范，具体的实现交由各个数据库厂商去实现的。所以JDBC是一种典型的桥接模式。 我们通过一个例子来了解下JDBC编程，以MySql数据库为例，查询用户信息。代码实例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.sql.*;import java.util.logging.Level;import java.util.logging.Logger;public class JDBCExample &#123; // 记录日志 Logger logger = Logger.getLogger(this.getClass().getName()); /** * 建立连接 * * @return 数据库连接 */ private Connection getConnection() &#123; Connection connection = null; try &#123; //加载MySql的驱动类 // Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver' Class.forName("com.mysql.cj.jdbc.Driver"); // useUnicode=true 表示使用Unicode字符集;characterEncoding=UTF-8解决中文乱码；serverTimezone=UTC是统一标准世界时间 String url = "jdbc:mysql://localhost:3306/jdbctest?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC"; String user = "root"; String password = "root"; // 建立数据库连接 connection = DriverManager.getConnection(url, user, password); &#125; catch (ClassNotFoundException | SQLException e) &#123; logger.log(Level.SEVERE, null, e); &#125; return connection; &#125; /** * 具体业务，根据用户id获取用户信息 * * @param id 用户id * @return 用户信息 */ public User getUser(long id) &#123; Connection connection = getConnection(); PreparedStatement ps = null; ResultSet rs = null; User user = null; try &#123; String sql = "select id, user_name, user_age from t_user where id = ?"; ps = connection.prepareStatement(sql); ps.setLong(1, id); rs = ps.executeQuery(); while (rs.next()) &#123; long userId = rs.getLong("id"); String userName = rs.getString("user_name"); int userAge = rs.getInt("user_age"); user = new User(); user.setId(userId); user.setUserName(userName); user.setUserAge(userAge); &#125; &#125; catch (SQLException e) &#123; logger.log(Level.SEVERE, null, e); &#125; finally &#123; this.close(rs, ps, connection); &#125; return user; &#125; /** * 释放数据库资源 * * @param rs * @param ps * @param conn */ private void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null &amp;&amp; !rs.isClosed()) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; logger.log(Level.SEVERE, null, e); &#125; try &#123; if (ps != null &amp;&amp; !ps.isClosed()) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; logger.log(Level.SEVERE, null, e); &#125; try &#123; if (conn != null &amp;&amp; !conn.isClosed()) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; logger.log(Level.SEVERE, null, e); &#125; &#125; public static void main(String[] args) &#123; JDBCExample jdbc = new JDBCExample(); User user = jdbc.getUser(2); System.err.println(user.toString()); &#125;&#125; 输出的结果：1User&#123;id=2, userName='zhangsan', userAge=27&#125; 总结下，使用JDBC编程整个过程大致分为以下几步： 1. 连接数据库（注册驱动，连接URL，数据库用户名密码，编码等），获取Connection； 2. 通过Connection，将预SQL传入以获取Statement对象； 3. 通过Statement处理占位并执行SQL，获取ResultSet对象； 4. 操作ResultSet对象读取数据，然后转换为具体的POJO对象； 5. 释放数据库等相关资源。 再看看，如果需要更新数据库表记录呢？123456789101112131415161718192021222324252627282930313233343536/** * 根据用户id更新用户姓名 * * @param id 用户id * @param name 用户姓名 */public void updateUser(long id, String name) &#123; // 获取连接 Connection conn = getConnection(); PreparedStatement ps = null; try &#123; // 设置事务手动提交 conn.setAutoCommit(false); String sql = "update t_user set user_name = ? where id = ?"; // 获取PreparedStatement对象 ps = conn.prepareStatement(sql); // 对占位符传值 ps.setString(1, name); ps.setLong(2, id); // 执行更新动作 ps.executeUpdate(); // 提交事务 conn.commit(); &#125; catch (Exception e) &#123; logger.log(Level.SEVERE, null, e); try &#123; // 异常时事务回滚 conn.rollback(); &#125; catch (SQLException e1) &#123; logger.log(Level.SEVERE, null, e); &#125; &#125; finally &#123; // 关闭数据库资源 this.close(null, ps, conn); &#125;&#125; 从整个代码示例也可以看出，使用传统的JDBC编程有以下几点弊端： 1. 我们需要先连接，然后处理事务，操作Connection对象、Statement对象、ResultSet对象获取数据，工作量有点大； 2. 我们需要对在JDBC编程期间产生的异常进行捕获并正确关闭资源； 3. 每次操作数据库，都需要重复很多动作。 由于直接JDBC编程带来的弊端，我们已经很少使用这种编程方式了，但是不管使用什么ORM模型，底层始终都是JDBC编程模式，所以了解原理还是很有必要的。]]></content>
      <categories>
        <category>java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之Executor框架篇]]></title>
    <url>%2F2018%2F02%2F10%2Fexecutor-of-concurrent%2F</url>
    <content type="text"><![CDATA[为了更好地控制多线程，JDK提供了一套线程框架Executor，帮助开发人员有效地进行线程控制。它们都在java.util.concurrent包中，是JDK并发包的核心。其中有一个比较重要的类：Executors，它扮演着这线程工厂的角色，我们通过Executors创建线程池方法： 常见的四种线程池newFixedThreadPoolnewFixedThreadPool()方法，该方法返回一个固定数量的线程池，该方法的线程数始终不变，当有一个任务提交时，若线程池中有空闲线程，则立即执行；若没有，则会被暂缓在一个任务队列中等待有空闲的线程去执行。1234567 ExecutorService pool = Executors.newFixedThreadPool(10); public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newSingleThreadExecutornewSingleThreadExecutor()方法，创建一个线程的线程池，若线程池中有空闲线程则执行，否则会被暂缓到任务队列中。12345678ExecutorService pool = Executors.newSingleThreadExecutor();public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; newCachedThreadPoolnewCachedThreadPool()方法，返回一个可根据实际情况调整线程个数的线程池，不限制最大线程数量。若有任务，则创建线程执行，若无任务则不创建线程。并且每一个空闲线程会在60s后自动回收。1234567ExecutorService pool = Executors.newCachedThreadPool(); public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; newScheduledThreadPoolnewScheduledThreadPool()方法，将返回一个ScheduledExecutorService对象，可以指定线程的数量。有点类似于newFixedThreadPool() 123456789101112131415ScheduledExecutorService pool = Executors.newScheduledThreadPool(10);public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS, new DelayedWorkQueue());&#125;public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123;...&#125; 通过观察者四种线程池的源码实现，我们可以看到，创建线程最终都是通过new ThreadPoolExecutor()，只不过不同的线程池创建的时候，传递的参数不同。下面的是ThreadPoolExecutor对象的构造器 核心ThreadPoolExecutor123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ...&#125; corePoolSize:核心线程数，也就是初始化时的线程数；maximumPoolSize：最大的线程数，也就是线程池线程的容量；keepAliveTime：空闲线程存活的时间，若是0，表示线程任务结束后，线程立即被回收；unit：空闲线程存活时间的单位，秒，分，时等；workQueue：线程池中的任务队列，多余的任务将被缓存在队列中，如队列，SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue，DelayedWorkQueue；threadFactory：线程工厂，提供创建新线程的功能；handler：当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution方法。； 简单newScheduledThreadPool实例1234567891011121314151617181920package executors;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;public class ScheduledThreadTest extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;ScheduledThreadTest run&quot;); &#125; public static void main(String[] args) &#123; ScheduledThreadTest command = new ScheduledThreadTest(); ScheduledExecutorService pool = Executors.newScheduledThreadPool(1); ScheduledFuture&lt;?&gt; scheduleTask = pool.scheduleWithFixedDelay(command, 2, 3, TimeUnit.SECONDS); &#125;&#125; 对于ThreadPoolExecutor中的缓存队列BlockingQueue有重要的两类：有界队列（ArrayBlockingQueue）和无界队列（LinkedBlockingQueue）。 有界队列（ArrayBlockingQueue）123456789101112131415161718192021public class ThreadPoolOfArrayBQ &#123; public static void main(String[] args) &#123; BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;Runnable&gt;(5); ThreadPoolExecutor pool = new ThreadPoolExecutor( 2, // coreSize 3, // MaxSize 60, TimeUnit.SECONDS, queue // 有界队列，容量为5 ); for (int i = 1; i &lt;= 10; i++) &#123; MyTask task = new MyTask(i, "task" + i); pool.execute(task); &#125; pool.shutdown(); &#125;&#125; 若现在有10个任务需要执行，这里采用了有界队列，容量为5；这里需要关注最大线程数MaxSize：3，也就是说来了10个任务，最大能一次创建3个线程执行任务，剩下的任务（7个）将暂缓加到队列中；而队列的容量是5，也就是说剩下的7个线程中，只有5个能加到有界队列中，还剩下2个任务，将会“拒绝执行”。执行结果：12345678910111213task1 runtask8 runtask2 runException in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task executors.MyTask@4f6b3939 rejected from java.util.concurrent.ThreadPoolExecutor@7f001ba5[Running, pool size = 3, active threads = 3, queued tasks = 5, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2048) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:821) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1372) at executors.ThreadPoolOfArrayBQ.main(ThreadPoolOfArrayBQ.java:21)task3 runtask5 runtask4 runtask6 runtask7 run 每次最多创建3个线程，执行3个任务；最多创建 maxThreadPoolSize + ArrayBlockingQueue.Size， 剩下的任务将会被拒绝执行。 无界队列（LinkedBlockingQueue）1234567891011121314151617181920212223242526272829303132333435363738public class ThreadPoolOfLinkedBQ implements Runnable &#123; private static AtomicInteger count = new AtomicInteger(0); @Override public void run() &#123; try &#123; int task = count.incrementAndGet(); System.out.println("Task " + task); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(); ThreadPoolExecutor pool = new ThreadPoolExecutor( 3, // coreSize 10, // MaxSize 120, TimeUnit.SECONDS, queue); // 无界队列，容量没有限制 for (int i = 0; i &lt; 10; i++) &#123; ThreadPoolOfLinkedBQ task = new ThreadPoolOfLinkedBQ(); pool.execute(task); &#125; Thread.sleep(1000); System.out.println("LinkedBlockingQueue`s size: " + queue.size()); pool.shutdown(); &#125;&#125; 若现在有10个任务需要执行，这里采用了无界队列，容量不限；这里需要关注核心线程数coreSize：3，核心线程数是瓶颈，也就是说来了10个任务，最大能一次创建3个线程执行任务，剩下的任务（7个）将暂缓加到队列中，也就是队列的大小现在为7。执行结果：1234567891011Task 3Task 1Task 2LinkedBlockingQueue`s size: 7Task 4Task 5Task 6Task 7Task 8Task 9Task 10 源码链接：https://pan.baidu.com/s/1vIjpbEWOyyXLW5GCQuXTJg 密码：5znj]]></content>
      <categories>
        <category>多线程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>有界队列</tag>
        <tag>无界队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之设计模式篇]]></title>
    <url>%2F2018%2F02%2F04%2Ffuture-Master-Worker%2F</url>
    <content type="text"><![CDATA[并行设计模式属于设计优化的一部分，它是对一些常用的多线程结构的总结和抽象。与串行程序相比，并行程序的结构通常更为复杂。因此合理地使用并行模式在多线程开发中更有意义。 Future模式该模式有点类似于商品订单。比如在网购时，当看中某商品时，就可以提交订单，当订单处理完成后，只需要在家等待商品送货上门即可。又如当我们发送Ajax请求时，页面时异步地进行后台处理，用户无需一直等待请求结果，可以继续浏览或操作其他内容。 示意图 示例代码链接：https://pan.baidu.com/s/1mhPW684 密码：kha7 Master-Worker模式是常用的并行计算模式。核心思想是系统由两类进行协作工作：Master进程和Worker进程。Master负责接收和分配任务，Worker负责处理子任务。当各个Worker子进程处理完成后，会将结果返回给Master，由Master做归纳和总结。其好处是能将一个大任务分解成若干个小任务，并行执行，从而提高系统的吞吐量。 示意图 示例代码链接：https://pan.baidu.com/s/1dFnlAtN 密码：vvx7 生产者-消费者模式生产者-消费者模式是非常典型的多线程模式，通常由两类线程：若干个生产者的线程和若干个消费者的线程。生产者线程负责提交用户请求，消费者线程负责具体处理生产者提交的任务，在生产者和消费者之间通过共享内存缓存区进行通信。 示意图 示例代码链接：https://pan.baidu.com/s/1eTurxrs 密码：ipyh]]></content>
      <categories>
        <category>多线程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Future</tag>
        <tag>Master-Worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之队列篇]]></title>
    <url>%2F2018%2F01%2F28%2Fqueue-of-concurrent%2F</url>
    <content type="text"><![CDATA[在并发队列上，JDK提供了继承于Queue的两套实现： 以ConcurrentLinkedQueue为代表的高性能队列； 以BlockingQueue接口为代表的阻塞队列。 其中BlockingQueue接口下的常用实现有： ArrayBlockingQueue LinkedBlockingQueue PriorityBlockingQueue DelayQueue SynchronousQueue ConcurrentLinkedQueue是一个适用于高并发场景下的队列，通过无锁的方式实现。实现了高并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueue。它是一个基于链节点的无界线程安全队列。该队列的元素遵循先进先出的原则。头部是最先加入的，尾部是最后加入的。不允许有null元素。 重要方法： add() 和 offer() 都是加入元素的方法，（在ConcurrentLinkedQueue中，这两个方法没有区别）； poll() 和 peek() 都是取头元素节点，区别在于前者会删除元素，后者不会。 BlockingQueue接口ArrayBlockingQueue基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，其内部没有实现读写分离，也就意味着生产和消费不能完全并行。长度是需要自定义的，可以指定先进先出或先进后出；也叫有界队列。 LinkedBlockingQueue基于链表的阻塞队列实现，其内部也维持着一个由链表构成的缓冲队列；该队列之所以能高效地处理并发数据，是因为其内部实现采用的是读写分离锁，从而实现生产和消费可以完全并行运行；是无界队列。 PriorityBlockingQueue基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入的队列对象必须实现Comparable接口），在实现该队列时，内部控制线程同步的锁采用的是公平锁；是一个无界队列； DelayQueue带有延迟时间的队列，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取该元素。该队列中的元素必须实现Delayed接口，该队列是一个没有大小限制的队列，应用场景多，譬如：对缓存超时的数据进行移除，任务超时处理，空闲连接的关闭等。现实中例子：如在网吧上网，交多少钱对应上网多少时间，时间到了自动下机。 SynchronousQueue是一种没有缓冲的队列，生产者产生的数据会直接被消费者获取并消费。其内部没有空间，若只是put()操作，会抛异常“queue full”；需要先take()阻塞，再put()可取，也就是没有经过队列内部。]]></content>
      <categories>
        <category>多线程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>阻塞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之容器篇]]></title>
    <url>%2F2018%2F01%2F20%2Fcontainer-of-concurrent%2F</url>
    <content type="text"><![CDATA[同步类容器概念同步类容器都是线程安全的，但是在某些场景下可能需要通过加锁来保护复合操作。那什么是复合类操作呢？诸如：迭代（反复访问元素，遍历完容器中所有的元素），跳转（根据指定的顺序找到当前元素的下一个元素），以及条件运算等。这些复合类操作在多线程并发修改容器时，可能会出现意想不到的情况，如经典的异常类ConcurrentModificationException，究其原因，当在容器迭代过程中，被并发地修改了内容，这是由于早期迭代器设计时并没有考虑到并发修改的问题。 种类诸如Vector，HashTable。这些容器的同步功能中有由JDK的Collections.synchronizedXX等工厂方法去创建实现的。其底层的实现机制无非就是利用传统的synchronized关键字对每个公用的方法都进行了同步操作，使得每次只能有一个线程访问容器的状态。对于当今互联网高并发的需求显然不能满足，在保证线程安全的同时，也必须要有足够好的性能。 示例Vector线程安全操作示例：12345678910111213141516171819202122232425262728package thread;import java.util.Vector;public class Tickets &#123; public static void main(String[] args) &#123; final Vector&lt;String&gt; tickets = new Vector&lt;&gt;(); for (int i = 1; i &lt;= 1000; i++) &#123; tickets.add("火车票" + i); &#125; for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while(true) &#123; if (tickets.isEmpty()) &#123; break; &#125; System.out.println(Thread.currentThread().getName() + "---" + tickets.remove(0)); &#125; &#125; &#125;, "线程" + i).start(); &#125; &#125;&#125; 为什么是线程安全的？我们看看Vector的remove操作具体实现。1234567891011121314public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue;&#125; 很显然，这里加了锁synchronized，所以是线程安全的。若是将Vector换成ArrayList，就有有重复数据出现，也说明ArrayList是线程不安全的。但是也正是这把锁，每次就1个线程能持有，另外的9个线程必须在外面排队等候，直到前面的线程释放锁。该容器并不能支持并发操作。 并发类容器概念JDK5.0以后提供了多种并发类容器来替代同步类容器，从而改善性能问题。对于同步类容器，虽然实现了线程安全，但是严重降低了并发性，在多线程环境下，严重降低了应用程序的吞吐量。而并发类容器，专门针对并发设计。 种类我们使用ConcurrentHashMap来代替基于散列实现的传统的HashTable，而且在ConcurrentHashMap中，添加了一些常见复合操作的支持；使用CopyOnWriteArrayList代替Vector，并发的CopyOnWriteArraySet，以及并发的Queue，如高性能的队列ConcurrentLinkedQueue和以阻塞形式的队列LinkedBlockingQueue，还有如ArrayBlockingQueue，PriorityBlockingQueue，SynchronousQueue等等。 ConcurrentMap容器ConcurrentMap接口下有两个重要的实现 ConcurrentHashMap—类似于 HashMap ConcurrentSkipListMap(支持并发排序功能，弥补ConcurrentHashMap)—类似于TreeMap ConcurrentHashMap内部使用段（Segment）来表示这些不同的部分，每个段其实就是一个小的HashTable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。把一个整体分为16个段，也就是最高支持16个线程的并发修改操作。这也是在多线程场景时，减小锁的粒度而降低锁竞争的一种方案。并且在代码中大多共享变量使用volatile关键字声明，目的是第一时间获取修改的内容，性能非常好。 Copy-On-Write容器简称COW，是一种用于程序设计中的优化策略。JDK中COW容器有2种，CopyOnWriteArrayList和CopyOnWriteArraySet。具体什么是COW容器呢？指写时复制的容器，也就是写（Write，添加、删除、修改）的时候进行复制（Copy）。通俗的讲，例如当我们往容器中添加元素的时候，不直接往当前容器中添加，而是将当前容器Copy一份，复制出一份新的容器，然后向新的容器中添加元素，添加完元素后，将原来容器的引用指向新的容器。这样做的好处是，我们可以向CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器中不会添加任何新的元素。所有CopyOnWrite容器是一种读写分离的思想，读和写的对象是不同的容器。这类容器适合于读多写少的场景，若写操作很多，还不如直接用普通容器加锁。对于该容器，当多个写发生时，为什么不会引起线程安全问题，直接看一个写操作：add方法。1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 可以看到，该操作中用到重入锁ReentrantLock，所以说也不会产生线程安全。]]></content>
      <categories>
        <category>多线程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>同步</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之通信篇]]></title>
    <url>%2F2018%2F01%2F13%2Fcommunication-of-concurrent%2F</url>
    <content type="text"><![CDATA[源码地址 链接：https://pan.baidu.com/s/1qXTRFre 密码：gky1 线程是操作系统中独立的个体，若不经过特殊的处理就能不能成为一个整体，而线程间的通信就是成为整体的必要方式之一。使用wait/notify方法来实现线程间的通信。需要重点关注2点： wait/notify必须配合synchronized关键字使用 wait方法释放锁，notify方法不释放锁 低阶方式实现：while(true)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package thread;import java.util.ArrayList;import java.util.List;public class AddListOne &#123; private static volatile List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public void addList() &#123; list.add(1); &#125; public int getSize() &#123; return list.size(); &#125; public static void main(String[] args) &#123; final AddListOne list = new AddListOne(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; list.addList(); System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, "t1").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while(true) &#123; if (list.getSize() == 5) &#123; System.out.println("当前线程：" + Thread.currentThread().getName() + "收到了通知，list.size = 5, 本线程终止"); throw new RuntimeException(); &#125; &#125; &#125; &#125;, "t2").start(); &#125;&#125; 两个线程共用一个变量list，用了volatile使得变量在线程间可见。一个现在循环10次，向list总增加值，另一个线程while(true)死循环，直到list中有5个值时，抛出异常，终止本线程。执行结果：1234567891011121314当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t2收到了通知，list.size = 5, 本线程终止Exception in thread "t2" java.lang.RuntimeException at thread.AddListOne$2.run(AddListOne.java:43) at java.lang.Thread.run(Thread.java:745)当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素 中阶方式实现：wait/notify由于一直在while(true)死循环，想换种线程间的通信方式，利用wait/notify重构代码。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package thread;import java.util.ArrayList;import java.util.List;public class AddListTwo &#123; private volatile List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public void addList() &#123; list.add(1); &#125; public int getSize() &#123; return list.size(); &#125; public static void main(String[] args) &#123; final AddListTwo list = new AddListTwo(); final Object lock = new Object(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 10; i++) &#123; list.addList(); System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (list.getSize() == 5) &#123; System.out.println("发出通知..."); lock.notify(); &#125; &#125; &#125; &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; if (list.getSize() != 5) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "线程在等待"); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("当前线程：" + Thread.currentThread().getName() + "收到了通知，list.size = 5, 本线程终止"); throw new RuntimeException(); &#125; &#125; &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125; 这里制造了一把锁lock，两线程共有这一把对象锁，每次只有一个线程占用。只有一方释放了锁，另一方才能拥有。这里两线程执行的顺序不确定，只有t2线程先执行时，才会有等待在先，通知在后；等待等着通知来唤醒。线程t2中执行wait方法时，阻塞了，并且释放锁，线程t1获得了锁lock， 虽然在list.getSize() = 5 时，发出了通知，但notify方法不释放锁。也就是说线程t1会一直执行下去，知道循环结束，这时候才会唤醒线程t2。执行结果：12345678910111213141516t2线程在等待当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素发出通知...当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t2收到了通知，list.size = 5, 本线程终止Exception in thread "t2" java.lang.RuntimeException at thread.AddListTwo$2.run(AddListTwo.java:57) at java.lang.Thread.run(Thread.java:745) 高阶方式实现：CountDownLatch可以看到这种情况下，虽然t1线程发出了通知，但是t2收到通知的时候，t1线程早就结束了。并不具备实时性。为了解决这个问题，在java并发包JUC下，提供了一个工具类CountDownLatch，不需要synchronized关键字，能实时实现通知。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package thread;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;public class AddListThree &#123; private volatile List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public void addList() &#123; list.add(1); &#125; public int getSize() &#123; return list.size(); &#125; public static void main(String[] args) &#123; final AddListThree list = new AddListThree(); final CountDownLatch countDownLatch = new CountDownLatch(1); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; list.addList(); System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (list.getSize() == 5) &#123; System.out.println("发出通知..."); countDownLatch.countDown(); &#125; &#125; &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; if (list.getSize() != 5) &#123; try &#123; countDownLatch.await(); System.out.println(Thread.currentThread().getName() + "线程在等待"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("当前线程：" + Thread.currentThread().getName() + "收到了通知，list.size = 5, 本线程终止"); throw new RuntimeException(); &#125; &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125; 执行结果：12345678910111213141516当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素发出通知...当前线程：t1添加了一个元素t2线程在等待当前线程：t2收到了通知，list.size = 5, 本线程终止Exception in thread "t2" java.lang.RuntimeException at thread.AddListThree$2.run(AddListThree.java:58) at java.lang.Thread.run(Thread.java:745)当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素当前线程：t1添加了一个元素 注意：这里new CountDownLatch(1)，这里的参数“1”表明发出几次通知，若这里传入2，需要调用countDownLatch.countDown()两次发通知才能收到唤醒通知。 使用wait/notify模拟队列QueueBlockintQueue：顾名思义，首先它就是一个队列，并且支持阻塞的机制，阻塞——放入和获取数据。我们将实现类似LinkedBlockingQueue中的take和put方法。 take：取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻断获取，直到BlockingQueue有新的数据被加入； put(anObject)：把anObeject加到BlockingQueue里，如果BlockingQueue没有空间，则调用此方法的线程被阻断，直到BlockingQueue里面有空间再继续。 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package thread;import java.util.LinkedList;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class MyQueue &#123; // 1. 需要一个承装元素的集合 private LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;(); // 2. 计数器 private AtomicInteger count = new AtomicInteger(0); // 3. 集合最小数 private final int minSize = 0; // 4. 集合最大数 private final int maxSize; // 5. 构造器，初始化集合最大数 public MyQueue(int size) &#123; this.maxSize = size; &#125; // 6. 同一把锁对象 private final Object lock = new Object(); // 7. 放入元素 public void put(Object obj) &#123; synchronized (lock) &#123; while (count.get() == this.maxSize) &#123; System.out.println("满了，放不下去了..."); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("加入新元素：" + obj); // 加入新元素 list.add(obj); // 计数++ count.incrementAndGet(); // put进入后，list空间变大了，若之前take没有元素，这时候take方法收到通知就可以take出元素了 lock.notify(); &#125; &#125; // 8. 取出元素 public Object take() &#123; Object obj = null; synchronized (lock) &#123; while (count.get() == this.minSize) &#123; System.out.println("空了，没有可取的..."); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 移除并获取首位第一个元素 obj = list.removeFirst(); System.out.println("获取新元素：" + obj); // 计数-- count.decrementAndGet(); // take完后，list空间变小了，若之前put不进去，阻塞，这时候put方法收到通知就可以put了 lock.notify(); &#125; return obj; &#125; // 9 获取容器的大小 public int getSize() &#123; return count.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; final MyQueue mq = new MyQueue(5); mq.put("a"); mq.put("b"); mq.put("c"); mq.put("d"); mq.put("e"); System.out.println("MyQueue容器中有元素:" + mq.getSize() + "个"); new Thread(new Runnable() &#123; @Override public void run() &#123; mq.put("f"); mq.put("g"); &#125; &#125;, "t1").start(); TimeUnit.SECONDS.sleep(2); new Thread(new Runnable() &#123; @Override public void run() &#123; mq.take(); mq.take(); &#125; &#125;, "t2").start(); &#125;&#125; main方法中模拟，先将容器中塞满元素；这时一个线程想加入2个元素但是被阻塞，于是wait()，并释放锁；这时候另一个线程获得锁从容器中取出元素，这时候容器有空余位置，并notify()，之前的put操作解除阻塞。执行结果：123456789101112加入新元素：a加入新元素：b加入新元素：c加入新元素：d加入新元素：eMyQueue容器中有元素:5个 满了，放不下去了...// 2s后获取新元素：a获取新元素：b加入新元素：f加入新元素：g ThreadLocal概念：线程局部变量，是一种多线程间并发访问变量的解决方案。与synchronized等加锁的方式不同，ThreadLocal完全不提供锁，而是使用以空间换时间的手段，为每个线程提供独立变量的独立副本，以保障线程安全。从性能上看，ThreadLocal不具有绝对的优势，在并发不是很高的时候，加锁的性能会更好；但作为一套与锁无关的解决方案，在高并发量或者竞争激烈的场景下，使用ThreadLocal可以在一定程度上减少锁竞争。代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package thread;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;public class MyThreadLocal &#123; public static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static List&lt;String&gt; list = new ArrayList&lt;&gt;(); public void getThreadLocal() &#123; System.out.println(Thread.currentThread().getName() + ": " + threadLocal.get()); &#125; public void setThreadLocal(String value) &#123; threadLocal.set(value); &#125; public static void main(String[] args) throws InterruptedException &#123; final MyThreadLocal myloLocal = new MyThreadLocal(); new Thread(new Runnable() &#123; @Override public void run() &#123; myloLocal.setThreadLocal("Hello"); myloLocal.getThreadLocal(); &#125; &#125;, "t1").start(); TimeUnit.SECONDS.sleep(2); System.out.println("休眠2s后..."); new Thread(new Runnable() &#123; @Override public void run() &#123; myloLocal.getThreadLocal(); &#125; &#125;, "t2").start(); &#125;&#125; 共用同一个对象ThreadLocal，一个线程t1，设置myloLocal.setThreadLocal(“Hello”) 并获取myloLocal.getThreadLocal()值；在休眠2s后（确保已经先设置值了），另一个线程也去获取值，结果如何？按照一般的思维，两个线程都应该获得值“Hello”。（若此处换成List，获取的值一样），执行结果：123t1: Hello休眠2s后...t2: null 线程t2并没有获取到线程t1中设置的值，也就是说ThreadLocal为每个线程提供独立变量的独立副本，这样一来就线程安全了。如：在Spring的事务管理中就是利用ThreadLocal来解决线程安全问题。 单例&amp;多线程单例模式最常见的就是懒汉模式（在调用方法时实例化对象）和饥汉模式（直接实例化对象）。在多线程模式下，考虑到性能和线程安全问题，我们一般选择下面两种比较经典的单例模式，在提高性能的同时，又保证了线程安全。 static inner class 静态内部类模式 dubble check instance 双检测模式 静态内部类模式123456789101112package thread;public class InnerSingleton &#123; private static class Singleton &#123; private static Singleton single = new Singleton(); &#125; public static Singleton getInstance() &#123; return Singleton.single; &#125;&#125; 这种方式实现起来很简单。 双检测模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package thread;import java.util.concurrent.TimeUnit;public class DubbleCheckSingleton &#123; private static DubbleCheckSingleton dcSingleton; public static DubbleCheckSingleton getInstance() &#123; if (dcSingleton == null) &#123; try &#123; TimeUnit.SECONDS.sleep(3); // 假设在做初始化准备工作 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (DubbleCheckSingleton.class) &#123; if (dcSingleton == null) &#123; dcSingleton = new DubbleCheckSingleton(); &#125; &#125; &#125; return dcSingleton; &#125; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(DubbleCheckSingleton.getInstance().hashCode()); &#125; &#125;, "t1").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(DubbleCheckSingleton.getInstance().hashCode()); &#125; &#125;, "t2").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(DubbleCheckSingleton.getInstance().hashCode()); &#125; &#125;, "t3").start(); &#125;&#125; 在第9，17行进行了两次 if (dcSingleton == null) 判断，也就是所谓的双重检查。在main方法中开启了3个子线程，并在run方法中，打印出实例对象的hashCode()调用结果。执行结果：123146067857114606785711460678571 3个线程的hashCode值是一样的，说明确实是单例。 为什么要用双重检查呢？若在第17行，去掉这层判断，结果会怎样？12345 synchronized (DubbleCheckSingleton.class) &#123;// if (dcSingleton == null) &#123; dcSingleton = new DubbleCheckSingleton();// &#125; &#125; 执行结果：1231739173940566582889896490263 3个线程的hashCode值是都不一样的，说明不是单例。为什么会这样呢？在第16行之前，有3s的初始化准备工作，3个线程都得到了dcSingleton == null，这时候其中一个线程A取得了锁，另外两个B，C因为锁同步别阻塞在外，假设就在第15行处等着线程A锁释放；另外两个线程中的一个B获得锁，另一个C依旧阻塞在外；这时候B因为前面已经获得的dcSingleton == null结论，获得锁进入同步块中又一次实例化了对象；同理后面的C获得锁后，也实例化了对象。所以这里三个线程实例化了三次，也就产生了3个不同的对象。而如果是双重检查，当B线程获得锁后，会再次检查dcSingleton引用是否为null，因为A线程已经实例化了一次，这里dcSingleton已经不为null了，所以不会再次实例化。3个线程，最后就产生了1个实例，即多线程下实现了单例模式。]]></content>
      <categories>
        <category>多线程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
        <tag>单例模式</tag>
        <tag>wait/notify</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程之基础篇]]></title>
    <url>%2F2018%2F01%2F07%2Fbasic-of-concurrent%2F</url>
    <content type="text"><![CDATA[源码地址：链接：https://pan.baidu.com/s/1c1MOlXY 密码：qfqi 线程安全概念线程安全：当多个线程访问同一个类（对象或方法）时，这个类始终表现着正确的行为，那么这个类就是线程安全的。synchronized ： 可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或者“临界区”。自定义线程类有两种方式：实现（implements）Runnable接口，继承（extends）Thread类，下面的代码采用第二种实现方式。 代码实例123456789101112131415161718192021222324public class MyThread extends Thread&#123; private int count = 5; @Override public void run() &#123; count --; System.out.println(Thread.currentThread().getName() + ", count = " + count); &#125; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread, "t1"); Thread t2 = new Thread(myThread, "t2"); Thread t3 = new Thread(myThread, "t3"); Thread t4 = new Thread(myThread, "t4"); Thread t5 = new Thread(myThread, "t5"); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125;&#125; 创建了5个线程（多线程），传入实例myThread（同一个），run方法中每次对成员变量count做减减操作，预期结果count值为：4,3,2,1,0.运行结果：12345t2, count = 2t5, count = 0t3, count = 2t4, count = 1t1, count = 2 很明显和预期结果不一致，也就是说当多个线程访问同一个方法时，这个方法没有表现着正确的行为，也就是说这是非线程安全的。为了在线程安全的情况下运行，我们给运行的run方法加一把同步锁synchronized，代码如下：12345@Overridepublic synchronized void run() &#123; count --; System.out.println(Thread.currentThread().getName() + ", count = " + count);&#125; 再次运行，结果如下：12345t1, count = 4t2, count = 3t5, count = 2t4, count = 1t3, count = 0 可看到count值确实和预期一致，也就是说当多个线程访问同一个方法时，这个方法表现出了正确的行为，即是线程安全的。 观察下发现打印的线程名称顺序和代码编写的顺序（t1 ~ t5）不一致，这是因为：当多线程访问myThread的run方法时，是以排队的方式进行处理（这里的排队指按照CPU分配的先后顺序而定）。 总结当一个线程想要执行synchronized修饰的方法代码时 首先会去尝试获得这把锁； 若获取了锁，则执行synchronized修饰的代码体中的内容；若没有获得，这个线程就会不断尝试去获取，直到拿到为止。此代码实例中，有多个线程同时去竞争这把锁。 这里又涉及到了另一个概念：锁竞争。例如有1000个线程同时尝试获取同一把锁时，CPU为了处理此次程序运行，一下子分配绝大部分内存资源出去，甚至导致死机，这是非常不好的事，所以尽量避免锁竞争问题。 多个线程多个锁概念多个线程，每个线程都可以拿到自己指定的锁，分别获得锁后，各自执行synchronized方法体中的内容。 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142package thread;public class MultiThread &#123; private int num = 0; public synchronized void printNum(String tag) &#123; if ("a".equals(tag)) &#123; num = 100; System.out.println("tag a, set num over!"); &#125; else &#123; num = 200; System.out.println("tag b, set num over!"); &#125; System.out.println("tag " + tag + ", num = " + num); &#125; public static void main(String[] args) &#123; final MultiThread m1 = new MultiThread(); final MultiThread m2 = new MultiThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1.printNum("a"); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; m2.printNum("b"); &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 我们在printNum方法上加了关键字synchronized，按照一贯思维，假设先执行t1线程时，拿到了锁，分别打印出：12tag a, set num over!tag a, num = 100 接着打印出：12tag b, set num over!tag b, num = 200 实际运行结果为：1234tag a, set num over!tag b, set num over!tag b, num = 200tag a, num = 100 显然实际结果和预期的不一致。虽然这里都用到了同一个类MultiThread，但是却是两个不同的对象（new）（引用），m1，m2。也就是不同的对象，锁肯定不一样，一个对象只能有一把锁。这里两个线程t1，t2，分别拿到了自己指定的锁，各自执行printNum方法中的代码逻辑，互不影响。 那么问题来了，这种情况下，要想只有一个线程执行printNum方法，另一个线程等前面的线程释放锁后再执行方法，那么该怎么做呢？其实很简单，只需要让printNum方法变成静态方法就行，即：123456// 这里也需要变成static变量，因为在静态方法printNum中只能访问静态成员变量private static int num = 0; public static synchronized void printNum(String tag) &#123; ...&#125; 静态方法上加锁就是类级别的锁了，类锁只有一把，所以是线程安全的。关于静态static相关的描述请参见：静态static与非静态non-static(变量、方法、内部类)解析执行结果：1234tag a, set num over!tag a, num = 100tag b, set num over!tag b, num = 200 可以看出，printNum方法确实被锁住了。 总结关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做是锁，在实例代码中哪个线程先执行synchronized关键字修饰的方法，那个线程就持有该方法所属对象的锁。两个对象，线程获得的就是两个不同的锁，他们互不影响。有一种情况，相同的锁，也就是上面所看到的，在静态方法上加关键字synchronized上锁，表示锁定的是类.class，即类级别的锁，独占锁。 对象锁的同步和异步概念同步：synchronized，同步的意思就是共享，如果不是共享的资源，也就是大家都需要的，就没有必要进行同步；异步：asynchronized，异步的意思就是独立，相互之间不受任何约束。同步的目的就是为了线程安全。 代码实例123456789101112131415161718192021222324252627282930313233343536373839package thread;public class MyObject &#123; public synchronized void method1() &#123; try &#123; System.out.println("method1 " + Thread.currentThread().getName()); Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void method2() &#123; System.out.println("method2 " + Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject mo = new MyObject(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method1(); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method2(); &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125; method1方法枷锁，且打印线程名称后，休眠5s。method2方法不加锁，不休眠。在主方法main中，实例化MyObject类，并起了两个线程，分别调用MyObject类中的method1，method2方法。执行结果，几乎同时打印：12method1 t1method2 t2 也就是说，方法method1，method2的执行事相互之间不受任何约束，是异步行为。 若修改下方法method2，也加上锁：123public synchronized void method2() &#123; System.out.println("method2 " + Thread.currentThread().getName());&#125; 关于执行结果，会有这样的情形： 先打印method1 t1，5s后，打印method2 t2; 或者先打印method1 t2，紧接着打印method1 t1，5s后程序终止; 方法method1，method2上面的锁是对象锁，对象锁只要一把，在上面执行情形1中，方法method1先取得了锁，方法method2就在排队等候，直到method1执行完毕。两个方法都需要共享这把锁，这就产生了同步行为。 总结A线程先持有object对象的锁，B线程如果这这个时候调用对象中的同步（synchronized）方法则需要等待，也就是同步；A线程先持有object对象的锁，B线程可以以异步（asynchronized）的方式调用对象中的非synchronized修饰的方法。 脏读概念对于对象的同步和异步方法，我们在设计程序时，一定要考虑问题的整体性，不然就会出现数据不一致的错误，脏读就是这种情况之一。 代码实例123456789101112131415161718192021222324252627282930313233343536package thread;public class DirtyRead &#123; private String name = "Hello"; private String password = "123"; public synchronized void setValue(String name, String password) &#123; this.name = name; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.password = password; System.out.println("the result of setValue [name:" + name + ", password:" + password + "]"); &#125; public void getValue() &#123; System.out.println("the result of getValue [name:" + name + ", password:" + password + "]"); &#125; public static void main(String[] args) throws InterruptedException &#123; final DirtyRead dr = new DirtyRead(); new Thread(new Runnable() &#123; @Override public void run() &#123; dr.setValue("World", "456"); &#125; &#125;).start(); Thread.sleep(1000); dr.getValue(); &#125;&#125; 这里实例了一次，设值和取值都用到了同一个引用dr，设值时在主线程main线程中开启了子线程。我们想要先处理下name，password的值，再获取处理后的值，也就是得到name:World, password:456，执行结果：12the result of getValue [name:World, password:123]the result of setValue [name:World, password:456] 程序获取值为：name:World, password:123，也就是没能保证name和password的一致性，这也就产生了脏读。我们应该使得设置值（setValue）和获取值（getValue）操作的整体性，这时候可以为两个方法都加上同步锁synchronized，由于公用同一把对象锁，也就抱着了原子性。 总结在我们对一个对象的方法加锁时，需要考虑业务的整体性，即为setValue/getValue方法同时加锁synchronized，保证业务的原子性，不然会出现业务错误。 锁重入关键字synchronized拥有锁重入的功能，也就是说使用synchronized时，当一个线程得到一个对象锁后，*再次请求此对象时是可以再次得到该对象的锁的。 代码实例1234567891011121314151617181920212223242526272829package thread;public class SyncAgain &#123; public synchronized void method1() &#123; System.out.println("method1 called..."); method2(); &#125; public synchronized void method2() &#123; System.out.println("method2 called..."); method3(); &#125; public synchronized void method3() &#123; System.out.println("method3 called..."); &#125; public static void main(String[] args) &#123; final SyncAgain sa = new SyncAgain(); new Thread(new Runnable() &#123; @Override public void run() &#123; sa.method1(); &#125; &#125;).start(); &#125;&#125; 方法method1，method2，metho13，均用关键字synchronized修饰，三个方法都拥有同一把对象锁； method1中调用method2，method2中调用method3。现在开启线程，调用method1。 我们按照正常逻辑思考：method1获得了对象锁，在方法体内调用method2，将要执行method2中的代码逻辑，此时由于method1并没有释放锁（method1方法还没有执行完），因此method2方法得不到锁。看似很矛盾，根本执行不下去。看看执行结果：123method1 called...method2 called...method3 called... 三个方法都执行了，并没有出现冲突。这就是前面说的锁重入问题，也就再次请求此对象时是可以再次得到该对象的锁的。 volatile关键字可见性作用：使变量在多个线程间可见 代码实例1234567891011121314151617181920212223242526public class VolatileVsibility extends Thread&#123; private volatile boolean isRunning = true; public void setRunning(boolean isRunning) &#123; this.isRunning = isRunning; &#125; @Override public void run() &#123; System.out.println("run called..."); while(isRunning) &#123; // ... &#125; System.out.println("线程结束"); &#125; public static void main(String[] args) throws InterruptedException &#123; VolatileVsibility vt = new VolatileVsibility(); vt.start(); Thread.sleep(2000); vt.setRunning(false); Thread.sleep(1000); System.out.println("now the value of isRunning is " + vt.isRunning); &#125;&#125; 在主线程main中起了子线程vt，子线程run方法中有个while循环，直到while(false)才会退出run方法，并打印“线程结束”字样。在主线程中，启动子线程后，2s后，修改了成员变量isRunning的值为false，正好符合子线程结束的条件。看看执行结果：12run called...now the value of isRunning is false 可以看到控制台只打印了一句日志，且控制台上的Terminate指示灯一直亮着，说明程序没结束，一致在while(true)，但是日志表明确实isRunning的值已经由true改变为false。也就是说变量isRunning主线程和子线程中并没有表现一致性，两个线程中不可见。这里有个示意图：为了让变量isRunning在两个线程中可见，保持一致性，只需要用volatile关键字修饰该变量即可，1private volatile boolean isRunning = true; 再次执行：123run called...线程结束now the value of isRunning is false 也就是说，变量被volatile关键字修饰时，当变量值改变时会强制线程执行引擎去主内存中重新去读取值，再次拷贝副本到子线程中的主内存区域。 不具备原子性volatile关键字具有一致性，但是不具备原子性。 代码实例11234567891011121314151617181920212223public class VolatileNoAtomic extends Thread&#123; private static volatile int count = 0; @Override public void run() &#123; for(int i=0; i&lt;1000;i++) &#123; count ++; &#125; System.out.println("count = " + count); &#125; public static void main(String[] args) &#123; VolatileNoAtomic[] vna = new VolatileNoAtomic[10]; for (int i = 0; i &lt; 10; i++) &#123; vna[i] = new VolatileNoAtomic(); &#125; for (int i = 0; i &lt; 10; i++) &#123; vna[i].start(); &#125; &#125;&#125; 成员变量count用了static也就是静态的，属于类，即不会因为每次new VolatileNoAtomic()而将变量值初始化为0，volatile使得多线程之间变量可见。执行结果：12345678910count = 3574count = 4000count = 5000count = 4000count = 3583count = 6753count = 6753count = 8499count = 9441count = 9441 因为在执行打印时，1System.out.println("count = " + count); 下一个线程会对count变量操作，所以过程中的值不会是整千，但是执行的最大的那个值应该是1000*10 = 10000。目前看来并不是，也就是说volatile关键字并不能保证原子性。此时可以用另一种方式来保证原子性。 代码实例212345678910111213141516171819202122232425262728import java.util.concurrent.atomic.AtomicInteger;public class VolatileNoAtomic extends Thread&#123; //private static volatile int count = 0; private static AtomicInteger count = new AtomicInteger(0); @Override public void run() &#123; for(int i=0; i&lt;1000;i++) &#123; // count ++; count.incrementAndGet(); &#125; System.out.println("count = " + count); &#125; public static void main(String[] args) &#123; VolatileNoAtomic[] vna = new VolatileNoAtomic[10]; for (int i = 0; i &lt; 10; i++) &#123; vna[i] = new VolatileNoAtomic(); &#125; for (int i = 0; i &lt; 10; i++) &#123; vna[i].start(); &#125; &#125;&#125; 执行结果：12345678910count = 7861count = 8146count = 8461count = 8853count = 8568count = 9344count = 9819count = 9910count = 9888count = 10000 不管执行多少次，最大的数确实是10000，也就证明了AtomicInteger类在多线程下能保证原子性。原子性操作：多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。该类来自1import java.util.concurrent.atomic.AtomicInteger; JUC包，包括并发应用程序的锁、互斥、队列、线程池、轻量级任务、有效的并发集合、原子的算术操作和其它基本构件。很重要的。]]></content>
      <categories>
        <category>多线程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
        <tag>锁</tag>
        <tag>锁重入</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析以及常见问题]]></title>
    <url>%2F2017%2F12%2F31%2Fsource-code-of-hashmap%2F</url>
    <content type="text"><![CDATA[2017年最后一篇博客，加油！ HashMap基本用法通过HashMap与Hashtable比较： HashMap能接受为null的键和值，Hashtable键和值都不能为null（通过put方法跟踪源码就一目了然）； HashMap是非synchronized的，所以快，Hashtable是synchronized，相对慢（源码）； HashMap 数组+链表 的存储结构，存储键值对；而一般的集合List、Set则是存储单个对象。 HashMap的工作原理HashMap是基于hashing的原理，我们在使用put(key,value)存储对象到HashMap中，使用get(key)从HashMap中获取对象；当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket的位置来存储Entry对象。我们来看看这句话涉及的源码，首先从put(key, value)方法开始。 put()方法源码实现HashMap存储结构在外层是数组，在源码中有：123static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; 在下面的put方法中，第2~4行，若是第一次操作HashMap，这里table必然是空的，需要去初始化。12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 在第5行，key为null时，并没有抛出异常，说明HashMap中允许键为null值的。在第7行，调用了hash方法，键作为参数传入。 这里看看hash()方法具体实现：1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 对于hashCode()，它是一个本地方法，实质就是地址取样运算1public native int hashCode(); 该方法第7行，调用了key的hashCode()方法，并通过一系列位运算，获取最后的hash值。反观HashTable中put()方法中调用的hash()方法实现：1234private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode();&#125; HashMap在HashTable的基础上做了优化，我们继续HashMap的put()方法的源码研究。在第8行：1int i = indexFor(hash, table.length); 通过返回的hash值找到（table中）bucket的位置来存储Entry对象。12345678/** * Returns index for hash code h. * 返回hashCode在table中的下标，以便存储Entry对象 */static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1);&#125; 在第9~17行，在判断value值是不是在HashMap中已经存在，存在的话就返回旧值。在第20行，1addEntry(hash, key, value, i); 看方法名就知道，这里就是真正将键值对添加到HashMap中的方法。传入四个参数：hash值，key-value，以及该Entry对象存储的位置。看看具体实现：123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; 如果HashMap的大小（size）超过了阀值（threshold）并且该Entry对象存储的位置被占用了，这时候就需要“扩容”了。也就是所谓的rehash。1resize(2 * table.length) 将HashMap的大小扩充为原来大小的两倍，并且重新计算该Entry对象存储的位置。12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; 通过resize()方法，我们可以看到在第9，10行，重新创建了容量是原来两倍大小的新Entry数组，并且在方法transfer()中会把原来Entry对象中的数据迁移到新的Entry中。12345678910111213141516171819/** * Transfers all entries from current table to newTable. * 把所有的Entry对象从当前table（旧）转义到刚创建的table（新）中 */void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 这一过程还是相当耗时的。在addEntry方法中的第8行：1createEntry(hash, key, value, bucketIndex); 创建具体的Entry对象：123456789101112131415void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125;/** * Creates new entry. */Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h;&#125; 这里很清晰了，根据之前计算的Entry对象的位置和键值对，创建了Entry对象。这里需要注意这行代码：1Entry&lt;K,V&gt; e = table[bucketIndex]; 计算出来的该key在bucket中的下标bucketIndex，返回该下标在数组中存储的对象，然后通过Entry构造器，在新Entry对象中，最为next存储。这里就利用到了链表结构。后面会详细讲到，这就是整个put()方法的调用过程。 get()方法源码实现关于通过键获取值的get(key)方法，我们需要了解其中的碰撞探测以及碰撞的解决办法。首先看看get()方法的实现：1234567public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125; key为null值这里就不看了，逻辑很简单。在第4行，这里通过key获取到了Entry对象。我们看看getEntry()的具体实现：12345678910111213final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; 在第6行，这里调用的key的hash方法，计算key的hashCode值。在第7行，通过返回的hashCode值获取该key在bucket中的index（下标，索引），并返回该key对应的Entry对象在数组中的存在。在9行if语句中，首先判断计算的hash值和该Entry对象创建时存储的key的hash值是否相等，一般人会认为两个key比较时，只要hash值相等，这个key就相等，其实这是不对的，这里就涉及到了碰撞探测。换句话说，这里用到了HashMap的存储结构–数组+链表。首先是数组，我们上面的代码中计算hashCode值在bucket中的位置，这个bucket就是数组（table）；1transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; 若有两个key对象的hash值相同的话，也就是说两个值对象存储在同一个bucket中，这时候怎么获取值对象（value）？继续看第9行后面的部分：1&amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)) 首先用的运算符&amp;&amp;，也就是说光传入key的hash和存储在Entry中的hash值相等还不行，后面部分运算结果也得是true。后面“||”左面部分为true的条件是，该传入的key和获取的Entry对象中的key是同一个，这样肯定能精确获得想要的值对象（hash值相同，key也相同）；“||”右面部分调用的key的equals()方法，返回结果为true，当然是同一个key，也就是说左右部分的运算都是为了找到同一个key。那么具体在同一个bucket中怎么同时存两个或多个hash值相同的不同key对象的呢？明白了怎么存的也就清楚了怎么取了。我们先回到：123456// put() ==&gt; addEntry() ==&gt; createEntry()void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 若前面已经通过put(key, value)形式存储的一个Entry对象，这里又来了一个key1，通过计算key和key1拥有相同的hashCode值，也即在bucket中的位置是一致的，即bucketIndex相同。在第3行中，首先就是通过下标取出数组中的Entry对象；在第4行中，新建了一个Entry对象，将新的key，value，计算的hash值以及上一个相同hash值的Entry对象一起保存在该新Entry对象中，然后在相同的bucket位置返回新的Entry对象，旧的Entry对象被挂起了；后来再来一个不同的key2，若计算得出的hash值也相同，刚新建的Entry对象也将变成后来这个新Entry对象的next被挂起。这样就是链表的形式存储了具有相同hash值的不同的key对象。所以说，HashMap就是通过数组+链表的形式实现的。这里说到了怎么存具有相同hash值的不同key对象，取呢？1234// get() ==&gt; getEntry()for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; .... &#125; 首先这里用到了for循环遍历，其实也说明了“数不止一个” 。在循环时用到了 e = e.next ，这里正是遍历挂起的Entry对象。1234567891011121314151617static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; ....&#125; 以上就是HashMap中最重要的存取方法：put(key,value)，get(key)源码解析过程。了解了这些，下面常见的问题也很容易回答。 常见问题 当两个不同的键对象的hashCode相同时会发生什么？它们会存储在同一个bucket位置的HashMap.Entry组成的链表中。 若两个键的hashCode值相同，你如何正确取出值对象的？当我们调用get(key)方法时，会先计算key的hashCode值，通过该值找到key在bucket（数组）中的位置，找到bucket位置后，循环遍历（next），并调用keys.equals()方法找到链表中正确的节点。 什么是hash，什么是碰撞？hash：是一种信息摘要算法，它还叫做哈希，或者散列。我们平时使用的MD5就属于Hash算法，通过输入key进行Hash计算，就可以获取key的HashCode()，比如我们通过校验MD5来验证文件的完整性。碰撞：好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞;就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。 如何减少碰撞？使用不可变的，声明做final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生（若has不同对象的hashCode值都不相同，自然就不需要链表来存储了），提高效率。不可变性使得能够缓存不同键的hashCode，这将提高整个获取对象的速度（不需要遍历，速度当然就快了），使用String，Integer这样的wrapper类作为键是非常好的选择。 为什么String, Interger这样的wrapper类适合作为键？因为String是不可变的，是final的，已经重写了hashCode()和equals()方法，其他的Wrapper类也有类似的特点。不可变性是必要的，因为为了要计算hashCode值，就要防止键值改变，如果键值在put和get时，返回了不同的hash值，也就不能正确的从HashMap中获取想要的对象了；如果可以仅仅通过将某个对象声明成final就能保证hashCode是不变的，就可以这么处理。因为获取对象时，需要调用hashCode()和equals()方法，对键值对象正确重写这两个方法时非常重要的。如果两个不相等的键值对象返回不同的hash值，那么碰撞的几率会小很多，这样较少了不必要的对链表的操作，就能提高HashMap的性能。 可以使用自定义的对象作为键吗？当然可以，只要其遵守equals()方法和hashCode()方法规则，当键值对象插入HashMap中不会再改变就可以。 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子是0.75，也就是说，当一个HashMap中填满了75%的bucket时，将会创建原来两倍大小的新bucket数组，并将原来的对象迁移到新创建的bucket中。 1static final float DEFAULT_LOAD_FACTOR = 0.75f; 重新调整HashMap大小存在什么问题吗？由于HashMap是非线程安全的，在多线程环境下，会产生条件竞争。因为若两个线程都发现需要调整HashMap时，都会尝试去调整。我们看下扩容的源码： 12345678910111213141516// put() ==&gt; addEntry() ==&gt; resize(2 * table.length) ==&gt; transfervoid transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 假设有两个不同的key：A，B对应了同一个hash值，假设当前bucket中存储最上面的是A，A.next = B。那么从上面的源码可以看到，当前是 A = e，e.next就是B， 第11行，先将e.next（B）处“清空”，因为newTable[i]目前只是空位置； 第12行，将A放入新bucket位置； 第13行，将当前对象e对象设置成B，继续while循环。 在B的循环中，B.next 为null， 第11行，此处newTable[i]是前面的A，这里赋值给了当前对象e(B)的next对象； 第12行，将B对象存储在该bucket位置； 第13行，next为null赋值给当前e，while循环为false，结束循环。 也就是说新的bucket中存储的最上面的是B，B.next = A，整个链表反过来了。这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。所以在多线程环境下，不能使用HashMap。 能否让HashMap同步？HashMap可以通过下面的手段实现同步： 1Collections.synchronizedMap(hashMap); 如何提升HashMap的性能？解决扩容损失：如果知道大致需要的容量，把初始容量设置好以解决扩容损失；比如我现在有1000个数据，需要 1000/0.75 = 1333，又 1024 &lt; 1333 &lt; 2048，所以最好使用2048作为初始容量。2048 = roundUpToPowerOf2(1333) 12345678910111213141516171819public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; ...&#125;private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); ...&#125;private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : "number must be non-negative"; return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;&#125;]]></content>
      <categories>
        <category>源码</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Maven搭建SpringMVC项目]]></title>
    <url>%2F2017%2F12%2F23%2Fmaven-and-springmvc%2F</url>
    <content type="text"><![CDATA[创建一个Maven Project右键 -&gt; New -&gt; Other... -&gt; 搜索‘maven’ -&gt; 选择‘Maven Project’ -&gt; Next 创建一个简单项目勾选：Create a simple project（自动创建约定的项目目录结构，即不使用骨架）-&gt; Next 确定唯一标示填写如截图中的内容 -&gt; Nex -&gt; Finish Group id: 组织id，域名倒写； Artifact id：项目、模块id； Version： 版本； Packaging: 该元素决定了项目的打包方式，有3种，jar，war，pom（比如是一个父模块）；Maven为jar项目调用了maven-jar-plugin，为war项目调用了maven-war-plugin，换言之，packaging直接影响Maven的构建生命周期 由于packing是war包，那么下面也就多出了webapp的目录 转换为dynamic web project由于我们的项目要使用eclipse发布到tomcat下面，这里我们需要先把项目转成 dynamic web project。在我们的项目上点击 右键，选择 Properties 并找到 Project Facets ，并点击Convert to faceted form... 将maven项目转换为Dynamic Web项目，勾选 Dynamic Web Module， 并点击 Further configuration available... 勾选生成web项目需要的部署描述符文件 web.xml， 然后点击 OK -&gt; OK 接下来观察我们的项目结构，多了一个WebContent目录 META-INF相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。MANIFEST.MF文件，在用jar打包时自动生成。 转为标准的Maven项目结构虽然此时我们可以发布到tomcat中，但这不符合maven的结构，“约定优于配置”，转为标准的maven项目结构。我们还要做如下修改：把上图 WebContent 下面两个目录 META-INF，WEB-INF 直接剪切到 src/main/webapp 目录下，并删掉 WebContent 目录，那么现在的项目结构如下图： 修改发布规则需要修改发布规则，右键点击项目，选择 Properties ， 选择 Deployment Assembly 选择 WebContent，把它 Remove 测试类我们也不需要发布， test 的两个目录页可以 Remove 因为是基于Maven项目，需要把Maven依赖库也添加到发布路径，点击 Add ， 选择 Java Build Path Entries, Next，选择 Maven Dependencies， Finish， OK 此处列表是，部署项目时，文件发布的路径 至此一个基于maven的webapp就建立好了，并可以直接从eclipse中发布到tomcat中。 导入我们的Spring MVC依赖jar包在 pom.xml 文件中写入下面的依赖，maven会自动为我们下载需要依赖的jar包，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;artifactId&gt;springmvc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 集中定义依赖版本号 --&gt; &lt;properties&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-net.version&gt;3.3&lt;/commons-net.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jsp-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Apache工具组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-net.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 此时工程目录下多了 Maven Dependencies 库 在上面的步骤中，我们在 pom.xml 文件中加入了好多东西，简单说说。12345678910&lt;!-- 集中定义依赖版本号 --&gt;&lt;properties&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-net.version&gt;3.3&lt;/commons-net.version&gt;&lt;/properties&gt; 在大型项目或者比较复杂的项目，例如聚合项目中，为了统一规定版本号，可以在父类工程中集中定义依赖版本号，这样在子类工程中就不许要考虑版本号问题了。从这里也可以看出该文件中有3大类依赖，spring，jsp以及工具类。 123456&lt;!-- Spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 在 &lt;properties&gt; 节点中集中定义了依赖版本号后，具体的依赖中就可以如上面直接用花括号的形式引用版本号了，当然要是再父类工程定义了版本号，子类想要用父类定义好的版本号，需要引入父类工程，如12345&lt;parent&gt; &lt;artifactId&gt;springmvc-parent&lt;/artifactId&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; 后面的 build 节点中集成了Tomcat7 插件，这样在运行项目时，只需要 项目右键 -&gt; Run as -&gt; Run Configurations...， 在 Goals 中填入 tomcat7:run 就可以自动部署项目到tomcat下运行了。123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 根据部署描述符(web.xml)中的默认欢迎页面，我们在webapp下新建一个 index.jsp 页面123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 项目右键 -&gt; Run as -&gt; Run Configurations...， 在 Goals 中填入 tomcat7:run，单击 Run，项目运行。控制台中会输出下面的信息123[INFO] Running war on http://localhost:8081/[INFO] Creating Tomcat server configuration at D:\workspace_springmvc\springmvc\target\tomcat[INFO] create webapp with contextPath: 在浏览器中输入 http://localhost:8081，回车 自此，基于maven搭建的web项目能正常访问了。我们再看下项目结构，多了个 target 文件夹，这个是哪来的？ 如图可知，java编译后的字节码文件就存在 target/classes 下 下一步，就是集成SpringMVC。 集成SpringMVC我们在 在src/main/java 下新建包：控制层（mvc.controller），业务逻辑层（mvc.service），数据访问层（mvc.dao），还有实体层（mvc.entity）； 在src/main/resources下新建spingmvc所需要的配置文件/mvc/config/springmvc.xml； 在WEB-INF下新建文件夹: css，js，jsp，用于存放资源文件和页面等 在部署描述符（web.xml）中，我们加入如下内容 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc/config/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 拦截所有的请求，包括WEB-INF下资源文件请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 在新建的 springmvc.xml 文件中，我们需要加入下面的内容： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- spring基于扫描机制找到应用程序中所有基于注解的控制器类和业务逻辑层 --&gt; &lt;context:component-scan base-package="mvc.controller" /&gt; &lt;context:component-scan base-package="mvc.service" /&gt; &lt;!-- 由于在`web.xml`中，会拦截所有的请求'/'，包括 `WEB-INF`下的资源文件：css，js等，而在`WEB-INF` 下的文件又不能直接访问，这里需要特殊处理下--&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:resources location="/WEB-INF/css/" mapping="/css/**"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources location="/WEB-INF/js/" mapping="/js/**"&gt;&lt;/mvc:resources&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 下面是一系列源码，很简单，就不解说了，文章最后附有完整的项目工程。实体类 Book.java1234567891011121314151617181920212223public class Book implements Serializable &#123; private static final long serialVersionUID = 1520961851058396786L; private long id; private String isbn; private String title; private Category category; private String author; public Book() &#123; &#125; public Book(long id, String isbn, String title, Category category, String author) &#123; this.id = id; this.isbn = isbn; this.title = title; this.category = category; this.author = author; &#125; // getter and setter&#125; 实体类 Category.java123456789101112131415public class Category implements Serializable &#123; private static final long serialVersionUID = 5658716793957904104L; private int id; private String name; public Category() &#123; &#125; public Category(int id, String name) &#123; this.id = id; this.name = name; &#125; // getter and setter&#125; 这里忽略数据访问层DAO业务逻辑层接口类 BookService.java12345678910public interface BookService &#123; List&lt;Category&gt; getAllCategories(); Category getCategory(int id); List&lt;Book&gt; getAllBooks(); Book save(Book book); Book update(Book book); Book get(long id); long getNextId();&#125; 业务逻辑层接口实现类 BookServiceImpl.java1234567891011121314151617181920212223242526272829303132333435@Servicepublic class BookServiceImpl implements BookService &#123; /* * this implementation is not thread-safe */ private List&lt;Category&gt; categories; private List&lt;Book&gt; books; public BookServiceImpl() &#123; categories = new ArrayList&lt;Category&gt;(); Category category1 = new Category(1, "Computing"); Category category2 = new Category(2, "Travel"); Category category3 = new Category(3, "Health"); categories.add(category1); categories.add(category2); categories.add(category3); books = new ArrayList&lt;Book&gt;(); books.add(new Book(1L, "9780980839623", "Servlet &amp; JSP: A Tutorial", category1, "Budi Kurniawan")); books.add(new Book(2L, "9780980839630", "C#: A Beginner's Tutorial", category1, "Jayden Ky")); &#125; @Override public List&lt;Book&gt; getAllBooks() &#123; return books; &#125; ...&#125; 最后控制层类 BookController.java1234567891011121314151617@Controllerpublic class BookController &#123; @Autowired private BookService bookService; private static final Log logger = LogFactory.getLog(BookController.class); @RequestMapping(value = "/book_list") public String listBooks(Model model) &#123; logger.info("book_list"); List&lt;Book&gt; books = bookService.getAllBooks(); model.addAttribute("books", books); return "BookList"; &#125; ...&#125; 页面 BookList.jsp12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Book List&lt;/title&gt;&lt;style type="text/css"&gt;@IMPORT url("./css/main.css");&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="global"&gt; &lt;h1&gt;Book List&lt;/h1&gt; &lt;a href="&lt;c:url value='/book_input'/&gt;"&gt;Add Book&lt;/a&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Category&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;ISBN&lt;/th&gt; &lt;th&gt;Author&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;books&#125;" var="book"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.category.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.title &#125;&lt;/td&gt; &lt;td&gt;$&#123;book.isbn &#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="book_edit/$&#123;book.id &#125;"&gt;Edit&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由于我在pom.xml 文件中配置的 项目访问路径是 “/”，所以直接在浏览器中输入：1http://localhost:8081/book_list 自此，用Maven搭建SpringMVC项目就讲完了，还有很多细节需要处理，需要不断学习。 完整工程下载链接：https://pan.baidu.com/s/1hrQdCwc 密码：kifh]]></content>
      <categories>
        <category>spring</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven入门介绍]]></title>
    <url>%2F2017%2F12%2F16%2FIntroduction-to-Maven%2F</url>
    <content type="text"><![CDATA[项目依赖管理在项目合作开的时，我们是如何进行项目依赖管理的呢？我们通常会在新建项目的时候，同时建立一个lib目录，在其中放着项目所依赖的各方类库，这样提交到SVN之后， 每个开发人员检出项目到本地，得到项目的工作副本，这样所有开发人员就会持有统一的项目依赖了。这样有2个比较明显的问题。 管理中的问题依赖冗余随着项目的增多，模块的增多，这种方式就会有问题。很多模块都会引用相同的依赖，当每个模块都把自己的依赖提交到SVN，那么相同的依赖就会占用服务器SVN的Repository很大的空间，造成空间浪费。 版本问题同时，如果一个项目中依赖的版本和另一个项目依赖的版本不一致。比如这个项目依赖hibernate2.x，而另一个可能依赖hibernate3.x， 当合并两个项目发布的时候， 可能因为这种依赖类库详细版本信息的缺失，造成问题。 解决办法为了解决以上依赖管理过程中出现的问题以及我们项目中遇到的其他类似问题， 我们寻求出一途径：各个项目只要通过统一的依赖描述文件（pom.xml）来指定自己需要的依赖就可以， 而不用自己来管理真正的依赖库，因为所有的项目都使用同一个中央依赖库(中央仓库)， 所以即使各个项目中有相同的依赖， 也不会出现依赖冗余的问题。Maven正是我们寻求的，能解决此问题的工具。 Maven是什么基本概念Maven是基于POM(project object model，即项目对象模型)的跨平台的项目管理工具，主要服务于基于JAVA平台的项目构建，依赖管理和项目信息管理。 项目构建清理、编译、测试、报告、打包、部署； 依赖管理自动下载，统一依赖管理； 信息管理项目名称描述，开发人员信息，开发者信息。 PS: 测试报告存放在target文件夹下。 优势如果没有Maven，你可能不得不经历下面的过程： 使用jar包时，需要去官网下载，譬如：如果使用了spring，去spring的官网下载jar包； 当某些jar包有依赖的时候，还要去下载对应的依赖jar包； 当jar包依赖有冲突时，不得不一个一个的排查； 执行构建时，需要使用ant写出很多重复的任务代码； 当新人加入开发时，需要拷贝大量的jar包，然后重复进行构建。 而maven的优势就是： 项目jar包的依赖管理：仅仅通过jar包的几个属性，就能确定唯一的jar包，在指定的文件pom.xml中，只要写入这些依赖属性，就会自动下载并管理jar包； 项目自动化编译部署：清理—&gt;编译—&gt;测试—&gt;打包—&gt;部署； 项目的插件管理。 Maven的配置文件如果使用过Ant都知道Ant是通过build.xml执行构建任务的，Maven中是通过pom.xml来执行任务.POM，project object model，即项目对象模型，它通过这个pom.xml 描述一个项目的构建以及信息。1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.h3c&lt;/groupId&gt; &lt;artifactId&gt;mavenLearning&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;xxxx&lt;/name&gt; &lt;packaging&gt;war&lt;/packaging&gt;&lt;/project&gt; 第一行指定了文档的XML版本和编码;第二行即每个pom.xml的核心元素——project;project下面有几个子元素，这几个子元素一般是每个项目都会使用到的： modelVersion这个元素指定了POM的版本（Maven2或者Maven3 都只能是4.0.0）； groupId 是项目组的ID，一般是com.公司组织名.项目名； artifactId 是该项目在项目组中ID，比如当前的项目是项目组的一个服务链项目，就可以叫做serviceChain； version 是项目的版本号，用于维护项目的升级和发布； name 一般没有实际的用处，只是用于标识该项目； packaging项目打包方式，常有jar，war，pom等，缺省下为jar比较重要的参数是 groupId、artifactId、version，这三个属性确定唯一的一个项目。 Maven如何管理jar包Jar包坐标关于jar包的坐标，maven是通过groupId，artifactId，以及version确定一个唯一的jar包。例如，最常使用的Junit的声明就是如下：123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;scope&gt;这是声明的范围，不同的生命周期所要求的范围是不一样的。 Maven仓库在Maven中会涉及到几种仓库： 工作空间，即我们的项目工程，这里面放着pom.xml文件，这个pom.xml就是maven的配置文件； 本地仓库，本地仓库用于存放jar包，其实Jar包并不是直接放入工作空间的，它是存放在本地仓库，然后在执行发布打包的时候，添加依赖路径； 私库：私库是使用者自己搭建的maven仓库，用于缓解频繁从外网下载jar包资源的压力。而且使用私库作为缓存层，也相对安全一些； 共享仓库：一般所说的中央仓库或者一些常用的镜像网站都属于这种，国内比较著名的oschina以及163都是不错的maven仓库。 Maven下载jar包的过程当我们在pom中声明了依赖关系后，参考上面的图： Maven在执行相关的任务时，会先去本地仓库查看是否有该资源，如果有的话，判断版本是否正确，如果一切都没问题则直接使用；否则，执行下一步； Maven会去配置的共享仓库中查找，如果找到就拷贝到本地仓库中；找不到则会给出相关的提示； Maven在本地如果搭建了私库，则会去私库中查找，找到就拷贝到本地仓库；找不到就会去共享仓库中查找，然后放入私库和本地库。有了私库，局域网内的开发者可以共享依赖，就不用每个人都去外网下载jar包，浪费带宽了。 Maven的目录结构介绍 bin：该目录下同JDK一样，主要是Maven的运行脚本，这些脚本用来配置Java命令，准备好classpath和相关Java系统属性，然后执行Java命令。mvn.bat是基于Windows的脚本。在CMD中每次输入一条MVN的命令都是在调用并执行这些脚本。该目录还有一个文件名为m2.conf，它是classworlds的配置文件。boot：该目录只有一个文件plexus-classworlds-2.5.1.jar。他是一个类加载器的框架，相对于JDK中的类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架架在自己的类库。conf：该目录包含了一个非常重要的文件setting.xml。配置该文件就能在Project中定制Maven的行为。lib：包含了所有Maven运行时需要的Java类库以及用到的第三方以来。LICENSE：记录了Maven的软件许可证。NOTICE.txt：记录了Maven所包含的第三方软件。README.txt：包含了Maven的简介以及简要指令等. 代理配置我们没有搭建私服（私库），Maven工程需要的jar包需要联网下载，在setting.xml配置文件中配置代理，即可下载需要的jar包。123456789101112&lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;xxxx&lt;/username&gt; &lt;password&gt;xxxx&lt;/password&gt; &lt;host&gt;xxx&lt;/host&gt; &lt;port&gt;xxx&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt;&lt;/proxies&gt; 在&lt;settings&gt;标签中添加如上代码，说明如下： proxies中可以配置多个proxy，但是默认第一个proxy生效。 active中的TRUE表示该代理目前生效状态。 http协议、主机地址、端口不在赘述。 用户名密码按需配置即可。 nonProxyHost表示不需要代理访问的地址。中间的竖线分隔多个地址，此处可以使用星号作为通配符号。 本地仓库配置本地仓库，顾名思义，就是Maven在本地存储构件的地方。注：maven的本地仓库，在安装maven后并不会创建，它是在第一次执行maven命令的时候才被创建maven本地仓库的默认位置：无论是Windows还是Linux，在用户的目录下都有一个.m2/repository/的仓库目录，这就是Maven仓库的默认位置如何更改maven默认的本地仓库的位置：这里要引入一个新的元素：localRepository。1&lt;localRepository&gt;E:\MAVEN&lt;/localRepository&gt; 远程仓库配置远程仓库中最核心的中央仓库（还有私服和其它公共库），中央仓库是默认的远程仓库，maven在安装的时候，自带的就是中央仓库的配置。所有的maven项目都会继承超级pom，具体的说，包含了下面配置的pom我们就称之为超级pom。中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; Maven的生命周期及阶段生命周期Maven中有三大生命周期，他们相互独立，分别是： clean 清理； default 构建； site 建站； 一般来说，clean和default比较常用。 阶段每个生命周期又有不同的阶段，阶段按顺序执行，并且可以指定执行结束的阶段。构建的时候，会依次从最上面的阶段执行到指定的那个阶段。比如，clean有3个阶段： pre-clean 执行清理前要完成的工作 clean 清理上一次构建生成的文件 post-clean 执行清理后需要完成的工作 当我们输入mvn clean的时候，执行的是pre-clean和clean两个阶段。 default的阶段比较多： validate initialize generate-sources process-sources generate-resources process-resources compile process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile process-test-classes tet prepare-package package pre-integration-test integration-test post-integration-test verify install deploy 看名字大概就能理解，当执行mvn install的时候，实际会执行validate -&gt; initialize -&gt;… -&gt; verify-&gt; install等二十几个阶段。为了操作方便，不同的生命周期可以在一起执行，比如mvn clean install，会先执行clean的阶段，再执行install的阶段。在IDE开发环境中，当我们Run as的时候，就可以执行maven clean进行清理，或者执行maven install进行构建，也可以执行maven build同时执行clean和install两个任务. Maven工程结构介绍一般的Maven项目会包含这样一个目录树： project|-src–main–java–你的源代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–main–resource：资源文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–test–java–单元测试代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–test– resource–单元测试代码相关资源文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–target–编译出的文件和jar包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–pom.xml–项目信息以及任务定义 “约定优于配置（Convention over Configuration）”，maven提供了约定的项目的目录结构，自动创建项目目录，提高开发效率。 Maven 集成Tomcat7插件Maven Tomcat插件现在主要有两个版本，tomcat-maven-plugin和tomcat7-maven-plugin，使用方式基本相同。在pom.xml中加入节点：123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;9090&lt;/port&gt; &lt;path&gt;/mavenLearningTest&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; path 是访问应用的路径。 port 是tomcat的端口号（一般在tomcat—conf-- server.xml中修改）。 uriEncoding URL按UTF-8进行编码，这样就解决了中文参数乱码。 Server 指定tomcat名称。 选择pom.xml文件，击右键——&gt;选择 Run As——&gt; Maven build，在Goals中填写：tomcat7:run（若填的是tomcat:run,默认调用的是tomcat-maven-plugin，此时pom配置文件中也得修改） 几个常用的Goal 命令 描述 tomcat7:deploy 部署一个web war包 tomcat7:reload 重新加载web war包 tomcat7:start 启动tomcat tomcat7:stop 停止tomcat tomcat7:undeploy 停止一个war包 tomcat7:run 启动嵌入式tomcat ，并运行当前项目 下一篇中将介绍下如何使用Maven搭建SpringMVC项目]]></content>
      <categories>
        <category>项目构建</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC基本介绍]]></title>
    <url>%2F2017%2F12%2F12%2Fintroduction-to-springmvc%2F</url>
    <content type="text"><![CDATA[对SpringMVC的了解来自实际项目以及在项目过程遇到问题是，查找相关资料，并没有系统地学习这些。很多会用，但是不太清楚具体原理，最新重新学习SpringMVC，开头一章系统的介绍，让我有所顿悟。对于这些知识的学习，让我对SpringMVC基本配置认识更加深刻，特此将重要的知识点摘录下来。 依赖注入 有两个组件A和B，A依赖于B。现在假定A是一个类，且A有方法methodA()，该方法中获取B，代码如下：12345678public class A &#123; public void methodA() &#123; B b = ...// get an instance of B b.methodB(); ... &#125; ...&#125; 要使用B，类A必须先获取组件B的实例引用。若B是一个具体的类，则可以通过new关键字直接创建B的实例。但是，如果B是接口，且有多个实现，则问题就复杂了。我们固然可以任意选择接口B的一个实现类，但这也意味着A的可重用性大大降低，因为无法采用B的其他实现。依赖注入是这样处理此类情景：接管对象的创建工作，并将该对象的引用注入需要该对象的组件。对于上面的例子，依赖注入框架会分别创建对象A和对象B，并将对象B注入到对象A中。为了能让框架进行依赖注入，我们需要编写特定的setter方法或构造方法。setter方法依赖注入实例：12345678910public class A &#123; private B b; public void methodA() &#123; b.methodB(); ... &#125; public void setB(B b) &#123; this.b = b; &#125;&#125; 修改后的类A新增了一个set方法，Spring会先创建B的实例，框架会调用该方法，并注入创建好的B的实例，因此在methodA()中调用B的methodB()方法前，不需要获取B的实例，构造器方法依赖注入实例：1234567891011public class A &#123; private B b; public A(B b) &#123; this.b = b; &#125; public void methodA() &#123; b.methodB(); ... &#125;&#125; Sping会先创建B的实例，再创建A的实例，然后把B注入到实例A中。 注：Spring管理的对象称为beans。 从1.0版本开始，Spring同时支持上述两种方式依赖注入：setter方式和构造器方式；从2.5版本开始，可以通过AutoWired注解，Spring支持基于field方式依赖注入。缺点是会引入org.springframework.beans.factory.annotation.Autowired，这对Spring产生了依赖，这样程序无法直接迁移到另一个依赖注入容器间。以上是依赖注入的最后实现的两种方式。往前一点，Spring支持两种方式来支持这种依赖注入：XML配置方式和注解配置方式。此外，需要创建一个ApplicationContext对象，代表一个Spring控制反转容器，org.springframework.context.ApplicationContext接口有多个实现，包括ClassPathXmlApplicationContext和FileSystemXmlApplicationContext。这两个实现都需要至少包含一个beans信息的XML文件。ClassPathXmlApplicationContext尝试在类加载路径中加载配置文件，而FileSystemXmlApplicationContext从文件系统中加载。下面为从类路径中加载config1.xml和config2.xml的ApplicationContext创建的一个代码示例。1ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"config1.xml", "config2.xml"&#125;); 然后通过调用ApplicationContext的getBean方法获得对象。1Product product = context.getBean("product", Product.class); getBean方法会查询id为product且类型为Product的bean对象。 注：理想情况下，我们仅需要在测试代码中创建一个ApplicationContext，应用程序本身无需处理。对于Spring MVC应用，可以通过一个Spring Servlet来处理ApplicationContext，而无需直接处理。 XML配置文件介绍配置文件的根元素通常为：123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; ...&lt;/beans&gt; 若需要更强的Spring配置能力，可以在schemaLocation属性中添加相应的schema。如：123456789101112131415xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd" 配置文件可以是一份也可以是多份，支持模块化配置。ApplicationContext的实现类支持读取多份配置文件，如上面例子中的：1ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"config1.xml", "config2.xml"&#125;); 另一种选择是，通过一个主配置文件，将其他配置文件导入在主配置文件中，直接读取主配置文件，如：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;import resource="config1.xml/&gt; &lt;import resource="module/config2.xml/&gt; &lt;import resource="resource/config2.xml/&gt; ...&lt;/beans&gt; Spring控制反转容器的使用通过构造器创建一个bean实例前面通过调用ApplicationContext的getBean方法来获取到一个bean的实例。下面的配置文件中定义了一个名为product的bean。123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean name="product" class="myspring.bean.Product"/&gt;&lt;/beans&gt; 该bean的定义告诉Spring通过默认无参构造器来初始化Product类。如果不存在该构造器（若类作者重载了构造器，但是没有显示声明默认构造器），Spring将抛出异常。 注意：应采用id或者name属性标示一个bean。 为了让Spring创建一个Product实例，应将bean定义的name值“product”（具体实践中也可以是id值）和Product类型作为参数传递给ApplicationContext的getBean方法。12ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"spring-contig.xml"&#125;);Product product = context.getBean("product", Product.class); 通过工厂方法创建一个bean实例Spring还支持通过调用一个工厂的方法来初始化类。下面的bean定义展示了通过工厂方法来实例化java.util.Calendar。1&lt;bean id="calendar" class="java.util.Calendar" factory-method="getInstance"/&gt; 该类中有方法：12345public static Calendar getInstance() &#123; Calendar localCalendar = createCalendar(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT)); localCalendar.sharedZone = true; return localCalendar;&#125; 本例子采用了id属性，而非name属性来表示bean，采用getBean方法来获取Calendar实例。12ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"spring-contig.xml"&#125;);Calendar calendar = context.getBean("calendar", Calendar.class); Destory Method 的使用有时候我们希望在类被销毁前还做点什么，这次我们可以在bean定义中配置 destroy-method 属性，来指定在销毁前要被执行的方法。下面的例子中，我们配置Spring通过 java.util.concurrent.Executors 的静态方法newCachedThreadPool 来创建一个 java.util.concurrent.ExecutorService 实例，并指定了 destroy-method 属性值为 shutdown 方法。这样，Spring会在销毁 ExecutorService 实例前，调用其 shutdown 方法。12&lt;bean id="executorService" class=".util.concurrent.ExecutorService" factory-method="newCachedThreadPool" destroy-method="shutdown"/&gt;]]></content>
      <categories>
        <category>spring</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try catch finally return 的执行顺序]]></title>
    <url>%2F2017%2F12%2F03%2Fthe%20order%20of%20the%20try-catch-finally-return%2F</url>
    <content type="text"><![CDATA[结论： 不管有没有异常，finally中的代码一定会执行； try 和 catch 中有 return 时，finally也会执行； finally是在return后面的表达式运算后执行的，因此函数返回值是在finally执行前确定； finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值，是finally中return返回的值。 说明：对于第3点，return后面的表达式运算后先把要返回的值保存起来，然后执行finally中的代码（这里不包含return，否则就是第4点了），再将之前保存的值取出，并返回。 下面会列出几种情况并通过具体代码验证上面的结论。 情况1：1try&#123;&#125; catch()&#123;&#125;finally&#123;&#125; return; 举例代码如下，这里不会发生异常：123456789101112131415public static void main(String[] args) &#123; System.out.println("main:" + test1());&#125;public static int test1() &#123; try &#123; System.out.println("try..."); &#125; catch (Exception e) &#123; System.out.println("catch..."); &#125; finally &#123; System.out.println("finally..."); &#125; System.out.println("return..."); return 0;&#125; 执行结果：1234try...finally...return...main:0 显然按顺序执行。 情况2:1try&#123; return; &#125;catch()&#123;&#125; finally&#123;&#125; return; try中有return，举例代码如下：12345678910111213141516public static void main(String[] args) &#123; System.out.println("main:" + test2());&#125;public static int test2() &#123; try &#123; System.out.println("try...return1+1"); return 1 + 1; &#125; catch (Exception e) &#123; System.out.println("catch..."); &#125; finally &#123; System.out.println("finally..."); &#125; System.out.println("return0..."); return 0;&#125; 执行结果：123try...return1+1finally...main:2 这里程序先执行try块中return之前已经return语句中表达式运算代码，再执行finally块，最后执行try中的return；而finally块后的return语句，因为在try块中已经return了，所以后面的就不执行了。 情况3：1try&#123; &#125; catch()&#123;return;&#125; finally&#123;&#125; return; catch中有return，在try中造一个异常，举例代码如下：1234567891011121314151617public static void main(String[] args) &#123; System.out.println("main:" + test3());&#125;public static int test3() &#123; try &#123; System.out.println("try..."); int i = 1 / 0; &#125; catch (Exception e) &#123; System.out.println("catch...return2"); return 2; &#125; finally &#123; System.out.println("finally..."); &#125; System.out.println("return0..."); return 0;&#125; 执行结果：1234try...catch...return2finally...main:2 程序先执行try块中的代码，因为try块中有异常，然后执行catch中return之前及return语句中表达式运算代码，最后执行finally块中的代码。 情况4：1try&#123; return; &#125;catch()&#123;&#125; finally&#123;return;&#125; try块和finally块中均有return，举例如下：123456789101112131415public static void main(String[] args) &#123; System.out.println("main:" + test3());&#125;public static int test3() &#123; try &#123; System.out.println("try...return1"); return 1; &#125; catch (Exception e) &#123; System.out.println("catch..."); &#125; finally &#123; System.out.println("finally...return3"); return 3; &#125;&#125; 执行结果：123try...return1finally...return3main:3 程序还是先执行try块中包括return之前已经return本身表达式运算代码，此时会将返回值存起来；这里没有异常，再接着执行finally块中的语句，由于finally块中有return，所以提前结果程序。finally中有return时，此时编译器也会给出警告：1finally block does not complete normally 情况5：1try&#123;&#125; catch()&#123;return;&#125;finally&#123;return;&#125; catch块和finally块中有return，举例如下：12345678910111213141516public static void main(String[] args) &#123; System.out.println("main:" + test5());&#125;public static int test5() &#123; try &#123; System.out.println("try..."); int i = 1 / 0; &#125; catch (Exception e) &#123; System.out.println("catch...return2"); return 2; &#125; finally &#123; System.out.println("finally...return3"); return 3; &#125;&#125; 执行结果：1234try...catch...return2finally...return3main:3 程序首先执行try块，遇到了异常执行catch块，此时执行catch中return之前以及return中包含的表达式运算代码，将结果作为返回值保存起来；接着执行finally中的代码，由于finally块中有return，前面保存的返回值将丢弃，返回finally中的return值，程序退出。 情况6：1try&#123; return;&#125;catch()&#123;return;&#125; finally&#123;return;&#125; try、catch、finally块中均有return，并且try中会发生异常，举例如下：1234567891011121314151617public static void main(String[] args) &#123; System.out.println("main:" + test6());&#125;public static int test6() &#123; try &#123; System.out.println("try...return1"); int i = 1 / 0; return 1; &#125; catch (Exception e) &#123; System.out.println("catch...return2"); return 2; &#125; finally &#123; System.out.println("finally...return3"); return 3; &#125;&#125; 执行结果：1234try...return1catch...return2finally...return3main:3 程序先执行try中代码，若没有异常将执行return之前以及return中表达式运算并将结果存起，执行finally中的代码；这里try块中有异常，接着执行catch中的代码，并执行return之前以及return中表达式运算并将结果存起，然后执行finally中的代码，由于finally中有return，将丢弃前面保存的，程序提前结束。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>try-catch-finally-return</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现字符串反转的三种方法]]></title>
    <url>%2F2017%2F11%2F24%2Freverse-string%2F</url>
    <content type="text"><![CDATA[递归反转123456public static String reverse1(String str) &#123; if (str == null || str.length() &lt;= 1) &#123; return str; &#125; return reverse1(str.substring(1)) + str.charAt(0);&#125; 字符串的substring(1)方法返回下标为1及后面所有的字符，如1System.out.println("abcdef".substring(1)); 执行结果为：1bcdef 字符串的charAt(0)方法返回下标为0的字符，如1System.out.println("abcdef".charAt(0)); 执行结果为：1a 注意：在用递归编写程序是，需要明确两点： 递归公式 收敛条件（即：何时结束递归） 否则会出现异常，甚至栈溢出，如下面的递归。12345public class StackOverflowErrorTest &#123; public static void main(String[] args) &#123; main(null); &#125;&#125; 运行结果：1234Exception in thread "main" java.lang.StackOverflowError at com.h3c.imc.campus.commgroup.StackOverflowErrorTest.main(StackOverflowErrorTest.java:5) at com.h3c.imc.campus.commgroup.StackOverflowErrorTest.main(StackOverflowErrorTest.java:5) ... reverse方法反转StringBuffer/StringBuilder中自带方法reverse()能实现字符串反转。1234567public static String reverse2(String str) &#123; if (str == null || str.length() &lt;= 1) &#123; return str; &#125; StringBuilder sb = new StringBuilder(str); return sb.reverse().toString();&#125; 循环反转第一种思路：循环递减遍历该字符串，从最后一位开始取，每次取一个字符，最后拼接在一起。1234567891011public static String reverse3(String str) &#123; int length = str.length(); if (str == null || length &lt;= 1) &#123; return str; &#125; StringBuilder sb = new StringBuilder(); for (int i = length - 1; i &gt;= 0; i--) &#123; sb.append(str.charAt(i)); &#125; return sb.toString();&#125; 第二种思路：循环递增遍历该字符串，从首位开始取，字符拼接时，已经取出的拼接在后面，新的在前面。1234567891011public static String reverse3(String str) &#123; int length = str.length(); if (str == null || length &lt;= 1) &#123; return str; &#125; String reverse = ""; for (int i = 0; i &lt; length; i++) &#123; reverse = str.charAt(i) + reverse; &#125; return reverse;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm加载class文件的原理机制分析]]></title>
    <url>%2F2017%2F11%2F21%2Fjvm-classloader%2F</url>
    <content type="text"><![CDATA[案例分析A、B类中均包含静态代码块，非静态代码块以及构造器，A类是B类的父类。1234567891011121314public class A &#123; static &#123; System.out.print("A中静态代码块&gt;&gt;&gt;"); &#125; &#123; System.out.print("A中非静态代码块&gt;&gt;&gt;"); &#125; public A() &#123; System.out.print("A中构造器&gt;&gt;&gt;"); &#125;&#125; 12345678910111213public class B extends A&#123; static &#123; System.out.print("B中静态代码块&gt;&gt;&gt;"); &#125; &#123; System.out.print("B中非静态代码块&gt;&gt;&gt;"); &#125; public B() &#123; System.out.print("B中构造器&gt;&gt;&gt;"); &#125;&#125; 那么看看下面代码的运行结果。1234567public class ABTest &#123; public static void main(String[] args) &#123; A ab = new B(); System.out.println("\n==========================\n"); ab = new B(); &#125;&#125; 执行结果：1234A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt;A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt;==========================A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt; 总结： 同一类中：静态代码块 =&gt; 非静态代码块 =&gt; 构造器 父子类中：父类 =&gt; 子类； 静态代码块只在第一次实例化（new）执行了，非静态代码块在每次实例化都执行。 看执行结果，上面的3条总结都没问题，对于第3点，需要注意下：静态代码块其实不是跟着实例走的，而是跟着类走。看如下测试，通过Class.forName()动态加载类：123public static void main(String[] args) throws ClassNotFoundException &#123; Class.forName("B");&#125; 执行结果：1A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt; 这里并没有执行实例化过程，但是静态代码块却执行了，这也证明了静态static代码块并不是跟着实例走。下面将简单介绍下类加载相关概念及过程，介绍完后再看看上面的例子，印象会更深刻。首先得了解下几个比较重要的JVM的内存概念。 jvm的几个重要内存概念方法区 专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域。 常量池 是方法区的一部分，主要用来存放常量和类中的符号引用等信息。 堆区 用于存放类的对象实例，如new、数组对象。 栈区 由一个个栈帧组成的后进先出的结构，主要存放方法运行时产生的局部变量、方法出口等信息。 java类的生命周期我们编写完一个.java结尾的源文件后，经过编译后生成对应的一个或多个.class后缀结尾的文件。该文件也称为字节码文件，能在java虚拟机中运行。而类的生命周期正是：从类（.class文件）被加载到虚拟机内存，到从内存中卸载为止。整个周期一共分为7个阶段： 加载，验证，准备，解析，初始化，使用，卸载 其中 验证，准备，解析统称为连接； 加载，验证，准备，初始化，卸载，这5个的顺序是确定的。 值得注意的是，通常我们所说的类加载指的是：加载，验证，准备，解析，初始化，这5个阶段。 加载该阶段虚拟机的任务主要是找到需要加载的类，并把类的信息加载到jvm的方法区中，然后堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。 连接连接阶段有三个阶段：验证，准备，解析。主要任务是加载后的验证工作以及一些初始化前的准备工作。 验证当一个类被加载后，需要验证下该类是否合法，以保证加载的类能在虚拟机中正常运行。 准备该阶段主要是为类的静态变量分配内存并设置为jvm默认的初始值；对于非静态变量，则不会为它们分配内存。这里静态变量的初始值，不是由我们指定的，是jvm默认的。 基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0； 引用类型默认值是null； 常量的默认值为我们设定的值。比如我们定义final static int a = 1000，则在准备阶段中a的初始值就是1000。 解析这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，jvm会将所有的类、接口名、字段名、方法名等转换为具体的内存地址。譬如：我们要在内存中找到一个类里面的一个叫call的方法，显然做不到，但是该阶段，由于jvm已经将call这个名字转换为指向方法区中的一块内存地址了，也就是说我们通过call这个方法名会得到具体的内存地址，也就找到了call在内存中的位置了。 初始化有且仅有 5种情况必须立即对类进行“初始化”： 使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已经在编译器把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候； 使用java.lang.reflect包的方法进行反射调用时，若类没有进行初始化，需要先触发其初始化； 当初始化一个类时，若其父类还没有进行初始化，则需要先触发其父类的初始化； 执行main方法，虚拟机会先初始化其包含的那个主类； 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化（这一点不是很懂）。 在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。（这正好解释了案例中第3点结论） 使用初始化阶段的5种情况用了很强烈的限定词：有且仅有，这5种行为称为对一个类进行“主动引用”。其他所有引用类的方法（行为）都不会对类进行初始化，称之为“被动引用”。 《学习深入Java虚拟机》一书中列举了3个被动引用例子，我验证了下，确实如此，不过还得到了新的启发。这里列出其中的2个例子，如下： 例子1：通过子类引用父类的静态字段，不会导致子类初始化123456789package classloading;public class SuperClass &#123; static &#123; System.out.println("SuperClass init!"); &#125; public static int value = 123;&#125; 12345678package classloading;public class SubClass extends SuperClass&#123; static &#123; System.out.println("SubClass init!"); &#125;&#125; 1234567package classloading;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 执行结果：12SuperClass init!123 结论：通过子类SubClass来引用父类SuperClass的静态字段value，初始化的只是父类，并不会触发子类的初始化。 例子2：常量在编译阶段会存入调用类的常量池中，不会触发定义常量的类的初始化123456789package classloading;public class ConstClass &#123; static &#123; System.out.println("ConstClass init!"); &#125; public static final String HELLO_WORLD = "hello world";&#125; 1234567package classloading;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLO_WORLD); &#125;&#125; 执行结果：1hello world 结论：从打印的结果可以看到，并没有初始化ConstClass类；但是从源码上看是引用了ConstClass类的常量。因为在NotInitialization类的编译期中，通过常量优化，已经将常量 &quot;hello world&quot;存储到了NotInitialization类的常量池中了。也就是说，NotInitialization中引用ConstClass.HELLO_WORLD其实是对自身常量池中常量引用。 卸载在使用完类后，需满足下面，类将被卸载： 该类所有的实例都已经被回收，也就是java队中不存在该类的任何实例； 加载该类的ClassLoader已经被回收了； 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 当上面三个条件都满足后，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程本质上就是在方法区中清空类信息，结束整个类的生命周期。 jvm加载class文件的原理机制面试题中经常会问到JVM加载Class文件的原理机制，结合上面的分析，引用下面网上的分析，更加容易理解。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：&nbsp;&nbsp;1)&nbsp;&nbsp;如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；&nbsp;&nbsp;2)&nbsp;&nbsp;如果类中存在初始化语句，就依次执行这些初始化语句。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。 下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈java对象浅度克隆和深度克隆]]></title>
    <url>%2F2017%2F11%2F12%2Fshallow-and-deep-clone%2F</url>
    <content type="text"><![CDATA[需要克隆的原因在工作中我们有时会遇到这样的需求： A对象包含一些有用信息，这时候需要一个和A完全相同的B对象。拿到B对象后，只需要稍微调整下就ok。A和B是两个独立的对象，只是B的初始值来自于A。而A/B对象中包含了比较复杂的数据结构。此时通过简单的赋值，并不能满足这种需求。 我之前做过一个需求： 定时任务——自动新建XX产品：XX产品包含了很多信息，有基本类型数据也有复杂结构对象。已经上线的产品通过修改某些属性值就可以初始化形成新的XX产品，然后等待上线。这里就用到了克隆。 克隆的实现方式浅度克隆首先，定义一个Student类，包含两成员变量：name，age，并且实现Cloneable接口，代码如下：12345678910111213141516171819202122232425262728public class Student implements Cloneable&#123; private String name; private int age; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 再，定义一个Teacher类，也是两字段：一个name，一个聚合对象student，并且实现Cloneable接口，代码如下：12345678910111213141516171819202122232425262728public class Teacher implements Cloneable &#123; private String name; private Student student; public Teacher(String name, Student student) &#123; super(); this.name = name; this.student = student; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125;&#125; 需要clone的类为什么要实现Cloneable接口？我们先看看该接口的源码： 1234567891011121314151617181920212223242526272829package java.lang;/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object's clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; * By convention, classes that implement this interface should override * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method. * See &#123;@link java.lang.Object#clone()&#125; for details on overriding this * method. * &lt;p&gt; * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method. * Therefore, it is not possible to clone an object merely by virtue of the * fact that it implements this interface. Even if the clone method is invoked * reflectively, there is no guarantee that it will succeed. * * @author unascribed * @see java.lang.CloneNotSupportedException * @see java.lang.Object#clone() * @since JDK1.0 */public interface Cloneable &#123;&#125; 这是一个“标示接口”，即：没有任何方法和属性的接口。这个标示仅针对java.lang.Object#clone()方法。注释中：第一段可以看到：我们调用的clone()方法是Obejct类的方法；第二段中：若调用这个Object.clone()方法，但是不实现Cloneable接口(not implement Cloneable)的话，会抛CloneNotSupportedException异常。 我们来测试下，修改Student方法，去掉实现。代码修改如下：123456789public class Student &#123; ... public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student("jack", 27); Student cloneStudent = (Student) student.clone(); &#125;&#125; 执行结果如下：123Exception in thread "main" java.lang.CloneNotSupportedException: clone.Student at java.lang.Object.clone(Native Method) at clone.Student.main(Student.java:38) 第三段中说：按照惯例，对于Object.clone()方法，我们需要是重写。我们看下该方法源码：1protected native Object clone() throws CloneNotSupportedException; 是个native方法，一般来说native方法的效率要高于非native方法，因此比那种new出新对象再把旧对象的信息赋值到新对象的效率要高。该方法还是个protected方法，也就是说外部程序想调用有局限性，因此需要重写修饰符设置为public。 下面再看一个Teacher相关的例子，这里先重写下equals()方法：123456789101112131415161718@Overridepublic boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (this == obj) &#123; return true; &#125; if (obj instanceof Teacher) &#123; Teacher teacher = (Teacher) obj; if (teacher.name == this.name &amp;&amp; teacher.student.equals(this.student)) &#123; return true; &#125; return false; &#125; return false;&#125; 作如下测试：12345678910111213141516public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student("jack", 27); Teacher teacher = new Teacher("Ali", student); System.out.println("Teacher的内存地址：" + teacher); Teacher cloneTeacher = (Teacher) teacher.clone(); System.out.println("克隆Teacher的内存地址：" + cloneTeacher); System.out.println("克隆前后，Teacher对象是否相等：" + teacher.equals(cloneTeacher) + "\n"); System.out.println("++++++我只想修改克隆对象中的Student姓名为‘rose’++++++\n"); cloneTeacher.getStudent().setName("rose"); System.out.println("修改Student姓名后，Teacher的内存地址：" + teacher); System.out.println("修改Student姓名后，克隆Teacher的内存地址：" + cloneTeacher); System.out.println("修改Student姓名后，克隆前后，Teacher对象是否相等：" + teacher.equals(cloneTeacher)); &#125; 执行结果如下：123456789Teacher的内存地址：clone.Teacher@6c89db9a克隆Teacher的内存地址：clone.Teacher@4eb09321克隆前后，Teacher对象是否相等：true++++++我只想修改克隆对象中的Student姓名为‘rose’++++++修改Student姓名后，Teacher的内存地址：clone.Teacher@6c89db9a修改Student姓名后，克隆Teacher的内存地址：clone.Teacher@4eb09321修改Student姓名后，克隆前后，Teacher对象是否相等：true 我们可以看到： 克隆前后，内存地址发生了变化@6c89db9a=&gt;@4eb09321； 克隆前后以及修改了Student对象name属性值，对象没有变化，equals结果为true。 也就是说，不同的引用指向了同一个对象。因此，若我只想修改克隆对象的信息，这种情况下是做不到的。 但是若只是修改基本类型或者String字符串，却能满足需求，只会影响克隆后的对象。譬如：去掉：1cloneTeacher.getStudent().setName("rose"); 并增加：1cloneTeacher.setName("Alice"); equals结果：1修改Student姓名后，克隆前后，Teacher对象是否相等：false 最后别忘了重写下clone方法，修改修饰符为public:1234@Overridepublic Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 深度克隆深度克隆之所以有深度，是弥补了浅度克隆对于对象类型的属性克隆的不足。这里通过对象序列化和反序列化来实现深度克隆。 对象的序列化 把对象转换为字节序列的过程 对象的反序列化： 把字节序列恢复为对象的过程 如何实现：首先新建一个工具类，封装clone方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class CloneUtil &#123; private CloneUtil() &#123;&#125; @SuppressWarnings("unchecked") public static &lt;T extends Serializable&gt; T clone(T obj) &#123; ByteArrayOutputStream baos = null; ObjectOutputStream oos = null; ByteArrayInputStream bais = null; ObjectInputStream ois = null; try &#123; baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(obj); bais = new ByteArrayInputStream(baos.toByteArray()); ois = new ObjectInputStream(bais); return (T) ois.readObject(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException("Class not found.", e); &#125; catch (IOException e) &#123; throw new RuntimeException("Clone Object failed in IO.", e); &#125; finally &#123; try &#123; if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 说明： 调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义。这两个基于内存的流就能够释只要垃圾回收器清理对象放资源，这一点不同于对外部资源（如文件流）的释放。 修改Student代码如下：123456789101112public class Student implements Serializable&#123; private static final long serialVersionUID = 1L; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125; ... &#125; 修改Teacher代码如下：123456789101112public class Teacher implements Serializable &#123; private static final long serialVersionUID = 1L; @Override public String toString() &#123; return "Teacher [name=" + name + ", student=" + student + "]"; &#125; ... &#125; 替换main方法中测试代码：1Teacher cloneTeacher = (Teacher) teacher.clone(); 为序列化-反序列化克隆方法：1Teacher cloneTeacher = CloneUtil.clone(teacher); 执行结果：123456789Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]克隆Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]克隆前后，Teacher对象是否相等：false++++++我只想修改克隆对象中的Student姓名为‘rose’++++++修改Student姓名后，Teacher的的toString：Teacher [name=Ali, student=Student [name=jack, age=27]]修改Student姓名后，克隆Teacher的的toString：Teacher [name=Ali, student=Student [name=rose, age=27]]修改Student姓名后，克隆前后，Teacher对象是否相等：false 明显可以看到，修改Student属性后，对克隆前的对象没有影响。 需要注意：CloneUtil类中的clone()长这样：123public static &lt;T extends Serializable&gt; T clone(T obj) &#123; ...&#125; 基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型&lt;T extends Serializable&gt;限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 当然，若是聚合对象如Teacher中的Student没有实现Serializable接口，还是会在运行时抛异常的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>浅度克隆</tag>
        <tag>深度克隆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射机制基础解析]]></title>
    <url>%2F2017%2F11%2F07%2Freflect-base%2F</url>
    <content type="text"><![CDATA[概念 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. 通俗来讲：反射就是把Class对象的各种成分映射成对应的Java类。 作用java反射机制其实就是将.class转化为.java，也即反编译。具体主要提供了以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法。 后面会围绕这几点具体展开。 重要API在java.lang.reflect包下提供类和接口，以获得关于类和对象的反射信息。这里简单罗列了与反射相关的几个重要的API，真正想学习反射机制，除了在项目中历练，API也是非常重要的手段。英语不好理解的话，就搜搜汉化后的API文档。 变量相关 含义 getField(String name) 返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 方法相关 含义 getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 构造方法相关 含义 getConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法 getConstructors() 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法 getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。 getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法 父类、父接口相关 含义 getInterfaces() 确定此对象所表示的类或接口实现的接口。 getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。 其他重要相关 含义 getModifiers() 以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符。 getName() 以 String 形式返回此 Method 对象表示的方法名称。 getReturnType() 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。 newInstance() 创建此 Class 对象所表示的类的一个新实例。 isInstance(Object obj) 判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。 具体功能实现下面通过例子分别讲述获取Class对象的3种方式，如何创建实例，如何获取构造器，如何获取方法，如何获取属性以及通过反射调用方法。 获取Class对象的3种方式例如新建一个类MyReflectTest，代码如下：123public class MyReflectTest &#123; &#125; 方式1：使用Class类的中静态forName()方法获得与字符串对应的Class对象12345678public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; clz = Class.forName("test.MyReflectTest"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 在数据库有关开发中，我们经常会用到这个方法，例如：1Class.forName("com.mysql.jdbc.Driver") 方式2： 利用对象的class属性123public static void main(String[] args) &#123; Class clz = MyReflectTest.class;&#125; 注意，在基本类型和包装类型中有，例如：1Integer.TYPE 等价于1int.class 是int的Class对象，不等价于1Integer.class 这是Integer的Class对象表示，看看源码就知道了。 方式3：调用对象的getClass()方法1234public static void main(String[] args) &#123; MyReflectTest myReflectTest = new MyReflectTest(); Class clz = myReflectTest.getClass();&#125; 创建实例获取到class对象后，调用newInstance()方法来创建Class对象对应的类实例，测试代码：1234public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Class clz = MyReflectTest.class; MyReflectTest newInstance = (MyReflectTest) clz.newInstance();&#125; 获取构造器获取类的所有构造器，测试代码：1234567891011public static void main(String[] args) &#123; // 获取类对象 Class clz = MyReflectTest.class; // 获取public构造器数组 Constructor[] cons = clz.getConstructors(); // 获取public，默认，protected，private构造器数组 Constructor[] declaredCons = clz.getDeclaredConstructors();&#125; 获取类中指定的某个构造器，测试代码：12345678910111213141516171819202122public MyReflectTest(String name) &#123; super(); this.name = name;&#125;MyReflectTest(String name, int age) &#123; super(); this.name = name; this.age = age;&#125;public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; // 获取public构造器，构造器参数类型为String Constructor con = clz.getConstructor(String.class); // 获取public，默认，protected，private构造器，构造器参数类型为String，int Constructor declaredCon = clz.getDeclaredConstructor(String.class, int.class);&#125; 获取方法新增两个方法:add()和get()。 12345678private void add(String name) &#123; System.out.println(name);&#125;public int get() &#123; System.out.println(age); return age;&#125; getDeclaredMethods()方法相关测试代码：1234567891011121314151617181920public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Method[] declaredMethods = clz.getDeclaredMethods(); for (Method method : declaredMethods) &#123; System.out.println("==============================="); // 访问修饰符 System.out.println(Modifier.toString(method.getModifiers())); // 返回类型 System.out.println(method.getReturnType()); // 方法名称 System.out.println(method.getName()); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (Class&lt;?&gt; param : parameterTypes) &#123; // 方法参数类型 System.out.println(param.getName()); &#125; &#125;&#125; 执行结果：1234567891011121314===============================public staticvoidmain[Ljava.lang.String; //"["表示数组对象===============================privatevoidaddjava.lang.String===============================publicintget 能获取私有的方法add()。看看另一个反射方法：getMethods()，代码和上面一个，基本没变化。测试代码：1234567891011121314151617public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Method[] methods = clz.getMethods(); for (Method method : methods) &#123; System.out.println("+++++++++++++++++++++++++++++++++"); System.out.println(Modifier.toString(method.getModifiers())); System.out.println(method.getReturnType()); System.out.println(method.getName()); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (Class&lt;?&gt; param : parameterTypes) &#123; System.out.println(param.getName()); &#125; &#125;&#125; 执行结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+++++++++++++++++++++++++++++++++public staticvoidmain[Ljava.lang.String;+++++++++++++++++++++++++++++++++publicintget+++++++++++++++++++++++++++++++++public finalvoidwaitlongint+++++++++++++++++++++++++++++++++public final nativevoidwaitlong+++++++++++++++++++++++++++++++++public finalvoidwait+++++++++++++++++++++++++++++++++publicbooleanequalsjava.lang.Object+++++++++++++++++++++++++++++++++publicclass java.lang.StringtoString+++++++++++++++++++++++++++++++++public nativeinthashCode+++++++++++++++++++++++++++++++++public final nativeclass java.lang.ClassgetClass+++++++++++++++++++++++++++++++++public final nativevoidnotify+++++++++++++++++++++++++++++++++public final nativevoidnotifyAll 对比上面的getDeclaredMethods()，少了一个私有的方法add()，但是多了好多不在本类的方法。由于每个类的超类都是Object类，很明显，这些方法都是来自超类，看看源码也能发现这个。也就是说： getDeclaredMethods()获取的是本类的方法，public、默认、protected、private； getMethods()获取的是本类和父类的所有的public的方法。 另外有获取指定某一个方法的反射方法。测试代码：123456789101112public String save(String name, int age) &#123; return "name: " + name + ", age: " + age;&#125;public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; // 第一个参数是“方法名”，后面的是方法的可变参数列表 Method method = clz.getMethod("save", String.class, int.class); System.out.println(Modifier.toString(method.getModifiers()));&#125; 执行结果：1public 其他的类似。 获取属性创建两个成员变量name，age，如下：123public String name;private int age; 测试代码：1234567891011121314151617181920public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; // 获取类对象 Class clz = MyReflectTest.class; Field[] fields = clz.getFields(); for (Field field : fields) &#123; System.out.println("+++++++++++++++++++++++++"); System.out.println(Modifier.toString(field.getModifiers())); System.out.println(field.getType()); System.out.println(field.getName()); &#125; Field[] declaredFields = clz.getDeclaredFields(); for (Field field : declaredFields) &#123; System.out.println("========================="); System.out.println(Modifier.toString(field.getModifiers())); System.out.println(field.getType()); System.out.println(field.getName()); &#125;&#125; 执行结果：123456789101112+++++++++++++++++++++++++publicclass java.lang.Stringname=========================publicclass java.lang.Stringname=========================privateintage 另外getField(String)，getDeclaredField(String)参数为方法名，和Method类似。 调用方法通过上面的一系列操作获取到某一方法后，我们可以利用invoke()方法来调用这个方法。测试代码：12345678910111213141516171819public String save(String name, int age) &#123; return "name: " + name + ", age: " + age;&#125;public static void main(String[] args) throws Exception &#123; // 获取类对象 Class&lt;MyReflectTest&gt; clz = MyReflectTest.class; // 获取对象实例 MyReflectTest reflect = (MyReflectTest) clz.newInstance(); // 获取save方法 Method method = clz.getMethod("save", String.class, int.class); // 第一个参数为对象实例，后面的为方法的参数 Object result = method.invoke(reflect, "jack", 27); System.out.println(result);&#125; 执行结果：1name: jack, age: 27 最后：反射在工作中其实用到的时候并不多，主要用来构建框架。譬如Spring中的IOC也即控制反转，其底层就是利用了反射。以后有时间再整理下这块。反射机制基础到这结束。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态static与非静态non-static(变量、方法、内部类)解析]]></title>
    <url>%2F2017%2F11%2F06%2Fstatic-and-non-static%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。 —— Java编程思想 &nbsp;&nbsp;&nbsp;&nbsp;一句话描述下：方便在对象没有创建的时候调用方法或变量。很显然，static依赖于类，只要类加载了，就可以使用，而不需要等对象实例化后再调用。 下面具体分析下。 变量静态变量 static修饰的变量，也叫类变量； 可以直接用类名.变量调用，也可以用对象名.变量调用； 所有对象的同一个类变量共享同一块内存空间。 实例变量 没有static修饰，也就对象变量； 只能通过对象调用； 所有对象的同一个类变量共享不同内存空间。 总结 静态变量是所有对象共有的，当某一个对象将它的值改变，此时其他对象去获取时，将得到改变后的值，因为它依赖于类； 实例变量是每一个对象私有的，当某一个对象将它的值改变，此时其他对象去获取时，得到的还是改变前的值，因为它依赖具体的实例； 举例静态变量和非静态变量举例代码如下：123456789101112131415161718192021222324252627282930public class StaticTest &#123; static int age = 1; int level = 1; public static void main(String[] args) &#123; System.out.println("静态变量：直接用‘类名.’调用: age = " + StaticTest.age); // 修改静态变量值 StaticTest.age = 2; // 实例化StaticTest对象 StaticTest staticTest = new StaticTest(); System.out.println("静态变量：通过‘实例化后的对象’调用：age = " + staticTest.age); System.out.println("实例变量：只能通过‘实例化后的对象’调用：level = " + staticTest.level); // 修改静态变量值 staticTest.age = 3; // 修改实例变量值 staticTest.level = 2; // 再实例化一个StaticTest对象 StaticTest staticTest1 = new StaticTest(); System.out.println("静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = " + staticTest1.age); System.out.println("实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = " + staticTest1.level); &#125;&#125; 执行结果：12345静态变量：直接用‘类名.’调用: age = 1静态变量：通过‘实例化后的对象’调用：age = 2实例变量：只能通过‘实例化后的对象’调用：level = 1静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = 3实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = 1 结果和前面分析的一致。 方法静态方法 static修饰的方法，属于类； 可以直接用类名.方法名调用，也可以用对象名.方法名调用； 在访问本类成员时，只允许访问静态变量和静态方法，不允许访问实例变量和实例方法； static块也即静态代码块，只能调用静态方法。 实例方法 没有static修饰，属于对象； 只能通过对象调用； 实例方法可以访问实例成员，也可访问静态成员； static块中不能调用实例方法。 举例123456789101112131415161718192021222324252627282930313233343536public class StaticTest &#123; static int age = 1; int level = 1; /** * 非静态方法 */ public void nonStaticMethod() &#123; System.out.println(this.level); System.out.println(age); staticMethod(); &#125; /** * 静态方法 */ public static void staticMethod() &#123; System.out.println(age); // 编译不通过 //System.out.println(level); System.out.println(new StaticTest().level); // 编译不通过 //nonStaticMethod(); new StaticTest().nonStaticMethod(); &#125;&#125; 总结&nbsp;&nbsp;&nbsp;&nbsp;静态方法在类加载时就创建了，但是非静态方法需要实例化后才能创建，因为先类加载，再实例化，所以静态方法中不能直接访问类的成员，只有类实例化后才能访问。 内部类 &nbsp;&nbsp;&nbsp;&nbsp;将一个类的定义放在另一个类的定义内部，就是内部类。 &nbsp;&nbsp;&nbsp;&nbsp;这里只分析普通内部类和静态内部类的区别，具体关于内部类知识暂时请参见详解内部类 普通内部类 不能有静态成员（静态方法，静态变量），否则编译不通过； 可以访问外部类的所有成员（方法，属性）； 实例化内部类方法： &nbsp;&nbsp;&nbsp;&nbsp;1). 先生成一个外部类的对象实例，如：1OutClass o = new OutClass(); &nbsp;&nbsp;&nbsp;&nbsp;2). 通过外部类的对象实例生成内部类对象，如：1OutClass.InnerClass no_static_i = o.new InnerClass(); 静态内部类 可以有静态和非静态成员； 只能访问外部类的静态成员； 实例化一个静态内部类方法： &nbsp;&nbsp;&nbsp;&nbsp;1). 不依赖外部类的实例，直接实例化内部类对象，如：1OutClass.InnerStaticClass static_i = new OutClass.InnerStaticClass(); &nbsp;&nbsp;&nbsp;&nbsp;2). 调用静态内部类的方法或变量，通过类名直接调用，如：12OutClass.InnerStaticClass.static_name;OutClass.InnerStaticClass.getName(); 举例及总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class OutClass &#123; private String outName = "OutClass.outName"; static String staticOutName = "OutClass.staticOutName"; public void getOutName() &#123; System.out.println(outName); System.out.println(staticOutName); &#125; public static void getOutStaticName() &#123; // 编译不通过，静态方法不能访问非静态成员 //System.out.println(outName); System.out.println(staticOutName); &#125; public static void main(String[] args) &#123; // 依赖外部类实例，创建非静态内部类 OutClass o = new OutClass(); OutClass.InnerClass no_static_i = o.new InnerClass(); no_static_i.getInnerName(); // 不依赖外部类实例，直接实例化静态内部类 OutClass.InnerStaticClass static_i = new OutClass.InnerStaticClass(); static_i.getInnerName(); // 通过静态内部类类名直接调用成员变量或方法 System.out.println(OutClass.InnerStaticClass.staticInnerName); OutClass.InnerStaticClass.getStaticInnerName(); &#125; /** * 非静态内部类 */ public class InnerClass &#123; // 编译不通过，普通静态内部类中不能有static变量 //static String staticInnerName = "InnerClass.staticInnerName"; // 编译不通过，普通静态内部类中不能有static方法 //public static void getStaticInnerName() &#123; // System.out.println(staticInnerName); //&#125; String innerName = "InnerClass.innerName"; public void getInnerName() &#123; System.out.println(innerName); // 直接访问外部类成员变量 System.out.println(outName); // 直接访问外部类静态成员变量 System.out.println(staticOutName); &#125; &#125; /** * 静态内部类 */ public static class InnerStaticClass &#123; static String staticInnerName = "InnerStaticClass.staticInnerName"; String innerName = "InnerStaticClass.innerName"; public static void getStaticInnerName() &#123; System.out.println(staticInnerName); &#125; public void getInnerName() &#123; System.out.println(innerName); // 编译不通过，不能直接反问外部类成员变量 //System.out.println(outName); // 只能访问外部类静态成员 System.out.println(staticOutName); &#125; &#125;&#125;]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>静态</tag>
        <tag>非静态</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译小工具：jad常用命令介绍]]></title>
    <url>%2F2017%2F11%2F06%2Fjad-cmd-introduce%2F</url>
    <content type="text"><![CDATA[jad是最简单的字节码.class反编译出源码.java的小工具。是jdk自带的，我的在‪D:\Java\jdk1.7.0_80\bin\jad.exe。 jad常用命令 -o 不提示，覆盖源文件，例如：1jad -o example.class 若当前目录下有example.jad文件（默认扩展名jad），执行该命令后会覆盖原example.jad文件 -s 指定输出文件的类型，例如：1jad -s java example.class 反编译结果以.java为扩展名。 -p 将反编译结果输出到cmd窗口，例如：1jad -p example.class 反编译结果直接在cmd界面显示。 &gt; 将反编译结果重定向到文件，例如：1jad -p example.class &gt; example1.java 在当前目录下，将example.class反编译后输出到example1.java文件中。 -d 指定反编译的输出文件目录，例如：1jad -d test example.class 在当前目录下会产生目录test，里面有example.jad文件 常用命令组合1jad -a -o -s java example.class 用JVM字节码格式来注解输出(-a)； 覆盖原文件（-o）； 以java扩展名输出example文件（-s java） jad帮助信息jad的帮助信息如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Options: //用JVM字节格式来注解输出 -a - generate JVM instructions as comments (annotate) //同 -a,但是注解的时候用全名称 -af - output fully qualified names when annotating //输出多于的括号 (e.g., if(a) &#123; b(); &#125;, default: no) -b - generate redundant braces (braces) //清除所有的前缀 -clear - clear all prefixes, including the default ones //指定输出文件的文件目录 -d &lt;dir&gt; - directory for output files //试图反编译代码的dead 部分(default: no) -dead - try to decompile dead parts of code (if there are any) //不用用字节码的方式反编译 (no JAVA source generated) -dis - disassembler only (disassembler) //输出整个的名字,无论是类还是方法 -f - generate fully qualified names (fullnames) //输出类的成员在方法之前 (default: after methods) -ff - output fields before methods (fieldsfirst) //输出所有的变量的缺省的最初值 -i - print default initializers for fields (definits) //将strings分割成指定数目的块的字符 (default: no) -l&lt;num&gt; - split strings into pieces of max &lt;num&gt; chars (splitstr) //将输出文件用行号来注解 (default: no) -lnc - output original line numbers as comments (lnc) //分割strings用新行字符 newline character (default: no) -nl - split strings on newline characters (splitstr) //不要转换java的定义符 (default: do) -noconv - don&apos;t convert Java identifiers into valid ones (noconv) //不要生成辅助文件 -nocast - don&apos;t generate auxiliary casts //不要生成方法的源代码 -nocode - don&apos;t generate the source code for methods //不允许空的构造器存在 -noctor - suppress the empty constructors //不要去检查class文件是否以dos方式写 (CR before NL, default: check) -nodos - turn off check for class files written in DOS mode //关掉对内部类的支持 (default: turn on) -noinner - turn off the support of inner classes //忽略局部变量的表信息 -nolvt - ignore Local Variable Table entries (nolvt) //不要输出一个新行在打开一个括号之前 (default: do) -nonlb - don&apos;t insert a newline before opening brace (nonlb) //无需确认直接覆盖输出 (default: no) -o - overwrite output files without confirmation //发送反编译代码到标准输出 STDOUT (e.g., for piping) -p - send all output to STDOUT (for piping) //在生成源代码时将所有的包加前缀 -pa &lt;pfx&gt;- prefix for all packages in generated source files //用数字名字给所有的类加前缀 (default: _cls) -pc &lt;pfx&gt;- prefix for classes with numerical names (default: _cls) //给没有用到的异常的名字加前缀 -pe &lt;pfx&gt;- prefix for unused exception names (default: _ex) //用数字名字给所有的成员变量加前缀 (default: _fld) -pf &lt;pfx&gt;- prefix for fields with numerical names (default: _fld) //在&lt;num&gt; 的导入之后将其他引用包裹成一行导入 (default: 3) -pi&lt;num&gt; - pack imports into one line using .* (packimports) //给局部变量用数字名字加前缀 (default: _lcl) -pl &lt;pfx&gt;- prefix for locals with numerical names (default: _lcl) //给方法用数字名字加前缀 (default: _mth) -pm &lt;pfx&gt;- prefix for methods with numerical names (default: _mth) //给方法的参数用数字名字加前缀 (default: _prm) -pp &lt;pfx&gt;- prefix for method parms with numerical names (default:_prm) //将同类型的成员包裹成一行 (default: no) -pv&lt;num&gt; - pack fields with the same types into one line (packfields) //恢复包的目录结构 -r - restore package directory structure //指定输出文件的类型 (by default &apos;.jad&apos;) -s &lt;ext&gt; - output file extension (default: .jad) //遇到关键字(if/for/while/etc)输出空格和表达式 (default: off) -space - output space between keyword (if, while, etc) and expression //显示所有的类，方法，成员变量的总数 -stat - show the total number of processed classes/methods/fields //用 &lt;num&gt;个的空格 (default: 4) -t&lt;num&gt; - use &lt;num&gt; spaces for indentation (default: 4) //用tabs代替空格对于边缘 -t - use tabs instead of spaces for indentation //正在反编译的时候 显示方法的名字 -v - show method names while decompiling //将 UNICODE strings 转换成 8-bit strings，用当前的 ANSI 码页 (Win32 only) -8 - convert Unicode strings into ANSI strings (ansi) //重新定向 STDERR to STDOUT (Win32 only) -&amp; - redirect STDERR to STDOUT]]></content>
      <categories>
        <category>小工具</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>jad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类（abstract class）和接口（interface）解析]]></title>
    <url>%2F2017%2F11%2F05%2Fabstract-and-interface%2F</url>
    <content type="text"><![CDATA[概念抽象类：包含抽象方法的类就称为 抽象类；接口： 抽象方法的集合，方法没有具体实现即不包含方法体。 两者异同相同点 都不能被实例化； 接口的实现类或抽象类的子类都必须实现接口或抽象类中的方法后才能被实例化 不同点 接口中的方法是高度抽象的，只有定义，没有具体的实现；抽象类中可以有定义也可以有实现； 接口中的方法默认为public abstract， 可以直接写public， 可以都省略不写；接口中方法修饰符不能是private， 接口需要实现，所以私有的方法没有意义；抽象类中的具体实现的方法和普通的类一样，而只有定义的方法必须用abstract修饰，不然编译不通过；而且抽象方法的修饰符不能是private，static，synchronized，native，能用默认的，public和protected。 接口中定义变量默认为public static final， 并且要赋予初始值，不然编译不通过；抽象类和普通的类一样，可以有自己的成员变量，可以重新赋值； 接口需要实现（implements）， 抽象类需要继承（extends），一个类可以实现多个接口，但是只能继承一个抽象类（单继承多实现）。 接口三问接口方法能否用private修饰 不能。因为接口是对外开放的，需要具体的类来实现其中的方法，私有的方法作用范围为本类，在接口中定义私有方法没有任何意义，编译不会通过。 接口方法能否用synchronized修饰 不能。synchronized是一种同步锁，在修饰方法时，需要具体逻辑，而接口只是定义，因为直接修饰接口中的方法没意义，可以用来修饰接口方法的具体实现。 接口方法能否用static修饰 这和jdk版本有关。jdk8之前：不能；jdk8新特性： 能。——参见JDK8新特性之接口的静态方法和默认方法 举例这里提供两种方式：jad反编译和反射来获取成员变量和方法的相关内容。 jad反编译下面先给出对应源码，再用jad反编译.class文件。反编译执行命令如下：1jad -a -o -s java 类名.class jad详细命令参见反编译小工具：jad常用命令介绍 接口.java源码MyInterface.java接口源码如下：123456public interface MyInterface &#123; String name = "MyInterface"; void add();&#125; 接口.class反编译MyInterface.class反编译结果如下：123456public interface MyInterface &#123; public abstract void add(); public static final String name = "MyInterface";&#125; 可以看到， 1.在成员变量（常量）中默认的修饰符是public static final;2.在方法中，默认的修饰符是public abstract 抽象类.java源码MyAbstract抽象类源码如下：1234567891011public abstract class MyAbstract &#123; public String name; void get() &#123; System.out.println("MyAbstract get() "); &#125; // 抽象类中的没有实现的方法必须是“abstract” abstract void delete();&#125; 抽象类.class反编译1234567891011121314public abstract class MyAbstract &#123; public MyAbstract() &#123; &#125; void get() &#123; System.out.println("MyAbstract get() "); &#125; abstract void delete(); public String name;&#125; 可以看到，成员方法和成员变量和普通类一样，是什么修饰就是什么。 反射获取这里新建一个MyTest类，继承抽象类MyAbstract，并且实现接口MyInterface 反射代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class MyTest extends MyAbstract implements MyInterface &#123; public static void main(String[] args) &#123; Field[] abstractFields = MyAbstract.class.getDeclaredFields(); Method[] abstractMethods = MyAbstract.class.getDeclaredMethods(); System.out.println("抽象类MyAbstract成员变量反射信息："); for (Field f : abstractFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("抽象类MyAbstract成员方法反射信息："); for (Method m : abstractMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType() + "\n"); &#125; Field[] interfaceFields = MyInterface.class.getDeclaredFields(); Method[] interfaceMethods = MyInterface.class.getDeclaredMethods(); System.out.println(); System.out.println("接口MyInterface成员变量反射信息："); for (Field f : interfaceFields) &#123; System.out.println("变量名：" + f.getName()); System.out.println("修饰符：" + Modifier.toString(f.getModifiers())); System.out.println("变量类型：" + f.getType()); &#125; System.out.println(); System.out.println("接口MyInterface成员方法反射信息："); for (Method m : interfaceMethods) &#123; System.out.println("方法名：" + m.getName()); System.out.println("修饰符：" + Modifier.toString(m.getModifiers())); System.out.println("返回类型：" + m.getReturnType()); &#125; &#125; @Override public void add() &#123; &#125; @Override void delete() &#123; &#125;&#125; 运行结果1234567891011121314151617181920212223抽象类MyAbstract成员变量反射信息：变量名：name修饰符：public变量类型：class java.lang.String抽象类MyAbstract成员方法反射信息：方法名：get修饰符：返回类型：void方法名：delete修饰符：abstract返回类型：void接口MyInterface成员变量反射信息：变量名：name修饰符：public static final变量类型：class java.lang.String接口MyInterface成员方法反射信息：方法名：add修饰符：public abstract返回类型：void 可以看到，和jad反编译的结果是一样的。 具体的反射机制请参见另一篇博文反射机制基础解析]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>反射</tag>
        <tag>jdk8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8新特性之接口的静态方法和默认方法]]></title>
    <url>%2F2017%2F11%2F05%2FJDK8-static-and-default%2F</url>
    <content type="text"><![CDATA[JDK8之前我们在接口中定义成员变量只能是public static final的，定义的成员方法只能是public abstract的，默认省略。JDK8前后这一概念等价。定义接口BeforeJDK8Interface如下：name和name1表述等价，getName()和getName1()表述等价。12345678910111213public interface BeforeJDK8Interface &#123; String name = "BeforeJDK8Interface"; //public、 static、 final 可以单独使用，也可以组合使用 public static final String name1 = "BeforeJDK8Interface"; void getName(); //public、 abstract 可以单独使用，也可以组合使用 public abstract void getName1();&#125; JDK8新增特性，允许我们在接口中定义default默认方法和static静态方法。定义接口JDK8Interface如下：1234567891011public interface JDK8Interface &#123; default void myDefaultMethod() &#123; System.out.println("JDK8新特性:接口中的默认方法"); &#125; static void myStaticMethod() &#123; System.out.println("JDK8新特性：接口中的静态方法"); &#125;&#125; 实现接口时，这里static方法由于static的原因，属于接口类，只能通过 接口类名直接调用；而default方法，需要 接口实现类实例化后调用。定义接口实现类JDK8InterfaceImpl如下：12345678public class JDK8InterfaceImpl implements JDK8Interface &#123; public static void main(String[] args) &#123; JDK8Interface.myStaticMethod(); JDK8InterfaceImpl jdk8Interface = new JDK8InterfaceImpl(); jdk8Interface.myDefaultMethod(); &#125;&#125; 由于static的原因，静态方法不能重写；但是default方法却可以，重写myDefaultMethod代码如下：123456789public class JDK8InterfaceImpl implements JDK8Interface &#123; ... @Override public void myDefaultMethod() &#123; System.out.println("接口中的default方法不满足需求，需要重写"); &#125;&#125; 这里稍注意下，JDK8Interface接口中default方法用了修饰符&quot;default&quot;，这里重写后修饰符是&quot;public&quot; 由于java实行的是单继承extends多实现implements，那JDK8新增特性中的两个方法有啥要求不？ 首先看看static方法，由于调用static方法时，用的是接口类名，不能的接口类名肯定不同，所以没影响； 对于default方法， 有于是实现类实例化后调用，若该类有多个接口且接口中有相同名称的default方法，这时候编译器就没办法区分了，会报错，必须重写default方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk8新特性</tag>
        <tag>静态方法</tag>
        <tag>默认方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载（Overload）和重写（Override）解析]]></title>
    <url>%2F2017%2F11%2F02%2Foverload-and-override%2F</url>
    <content type="text"><![CDATA[方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 概念重载Overload 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。 访问修饰符：重载与访问修饰符无关 返回类型： 重载与返回值无关 方法名： 重载方法名需完全一致 参数列表： 重载参数列表需完全不同 重写Override 发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。 访问修饰符：子类的访问修饰符权限 &gt;= 父类的访问修饰符权限 返回类型： 子类的返回类型 &lt;= 父类的返回类型 方法名： 方法名应完全一致 参数列表： 参数列表应完全一致 举例String类重载例子String类的构造器重载：1234567public String() &#123; this.value = new char[0];&#125;public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; String类的valueOf()方法的重载：1234567public static String valueOf(char data[]) &#123; return new String(data); &#125; public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; 重写例子ArrayList继承了AbstractList类1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; AbstractList类中有方法add()：1234public boolean add(E e) &#123; add(size(), e); return true;&#125; ArrayList类中有重写了add()方法：12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 多态面向对象编程有三大特性：封装、继承、多态。 概念 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding）多态存在的三个必要条件 1. 要有继承； 2. 要有重写； 3. 父类引用指向子类对象。 根据何时确定执行多态方法中的哪一个，多态分为两种情况：编译时多态和运行时多态。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。 编译时多态重载都是编译时多态，从上面的分析可以看到，只要确定了方法参数的数据类型,个数,次序就能确定调用哪一个方法。 运行时多态重写有两种多态性，当对象引用本类实例，此时为编译时多态，能在编译期确定调用哪个方法；否则为运行时多态。 举例分析123456789101112131415package test;public class Test &#123; &#125;class Animal&#123; public String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String getName() &#123; return "Dog"; &#125;&#125; 1.执行下面的main方法123456public static void main(String[] args) &#123; Animal animal = new Animal(); Dog dog = new Dog(); System.out.println(animal.getName()); System.out.println(dog.getName());&#125; 输出结果：12AnimalDog Animal和Dog引用的都是本类的实例12Animal animal = new Animal();Dog dog = new Dog(); 2.若是这样呢？输入结果是多少1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName());&#125; 此时输出：1Dog 程序在运行时，会从实例所属的类开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照继承关系逐层向上查找，直到超级父类Object类。该例子animal.getName()执行过程是： 3.修改Animal类, 空类12class Animal&#123;&#125; 此时执行方法：1234public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(((Dog) animal).getName());&#125; 需要显示地转换下((Dog) animal).getName(),因为Animal类中没有定义getName()方法。 4.修改Animal,Dog类的getName()方法为静态方法,并增加一成员变量name1234567891011121314class Animal &#123; public String name = "a"; public static String getName() &#123; return "Animal"; &#125;&#125;class Dog extends Animal &#123; public String name = "d"; public static String getName() &#123; return "Dog"; &#125; 执行main方法：12345public static void main(String[] args) &#123; Animal animal = new Dog(); System.out.println(animal.getName()); System.out.println(animal.name);&#125; 输出结果为：12Animala 结果解释：1.重写只使用于实例方法，不能用于静态方法，对于static方法，只能隐藏,重载,继承；2.在利用引用animal访问对象的属性name或静态方法getName()时，是引用类型决定了实际上访问的是哪个对象（Animal）的成员，而不是当前引用代表的那个类（new Dog()）;由此可知，子类静态方法并不能重写（覆盖）父类的静态方法;故而输出的结果都是父类的成员结果。 为什么不能根据返回类型来区分重载假设下面的重载方法update能编译通过123456789public class Test &#123; public void update() &#123; &#125; public int update() &#123; return 0; &#125;&#125; 当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。方法的返回值,只能作为方法运行之后得一个状态，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的标示。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
        <tag>多态</tag>
        <tag>编译时多态</tag>
        <tag>运行时多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和Integer解析]]></title>
    <url>%2F2017%2F11%2F02%2Fint-and-Integer%2F</url>
    <content type="text"><![CDATA[Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 两个常见的面试例子先看两个常见的例子，后面会针对例子加以分析。例11234567public static void main(String[] args) &#123; Integer a = new Integer(8); Integer b = 8; int c = 8; System.out.println(a == b); System.out.println(a == c); &#125; 1执行结果： false, true 例2 12345public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 250, f4 = 250; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125; 1执行结果： true, false 知识点一：自动拆箱与自动包装概念1.自动拆箱： 自动将包装器类型转换为基本数据类型； 2.自动包装： 自动将基本数据类型转换为包装器类型。 具体分析例1中1234Integer b = 8; //自动装箱//Integer a = new Integer(8);//int c = 8;System.out.println(a == c) // 自动拆箱 注意：Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是intValue()方法。 对例1反编译看看(这里用jad来反编译), Test是例子中的类名。下面命令将输出带字节码注释和源码 -a表示用JVM字节格式来注解输出; -o表示无需确认直接覆盖输出; -s表示定义输出文件的扩展名,默认的扩展名是jad; java表示我们想要的反编译后输出java格式文件 jad详细命令参见反编译小工具：jad常用命令介绍1jad -a -o -s java Test.class 反编译结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package test;import java.io.PrintStream;public class Test &#123; public Test() &#123; // 0 0:aload_0 // 1 1:invokespecial #8 &lt;Method void Object()&gt; // 2 4:return &#125; public static void main(String args[]) &#123; Integer a = new Integer(8); // 0 0:new #16 &lt;Class Integer&gt; // 1 3:dup // 2 4:bipush 8 // 3 6:invokespecial #18 &lt;Method void Integer(int)&gt; // 4 9:astore_1 Integer b = Integer.valueOf(8); // 5 10:bipush 8 // 6 12:invokestatic #21 &lt;Method Integer Integer.valueOf(int)&gt; // 7 15:astore_2 int c = 8; // 8 16:bipush 8 // 9 18:istore_3 System.out.println(a == b); // 10 19:getstatic #25 &lt;Field PrintStream System.out&gt; // 11 22:aload_1 // 12 23:aload_2 // 13 24:if_acmpne 31 // 14 27:iconst_1 // 15 28:goto 32 // 16 31:iconst_0 // 17 32:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; System.out.println(a.intValue() == c); // 18 35:getstatic #25 &lt;Field PrintStream System.out&gt; // 19 38:aload_1 // 20 39:invokevirtual #37 &lt;Method int Integer.intValue()&gt; // 21 42:iload_3 // 22 43:icmpne 50 // 23 46:iconst_1 // 24 47:goto 51 // 25 50:iconst_0 // 26 51:invokevirtual #31 &lt;Method void PrintStream.println(boolean)&gt; // 27 54:return &#125;&#125; 可以看到第20, 22行，调用了Integer方法.valueOf(int)自动装箱：1Integer b = 8; 1Integer b = Integer.valueOf(8); 第36行,调用了Integer方法.intValue()自动拆箱：1System.out.println(a == c); 1System.out.println(a.intValue() == c); 所以：a == c的结果为true 例1中123Integer a = new Integer(8);Integer b = 8;System.out.println(a == b); 结果为何为false？ 刚讲到了1Integer b = 8; 调用了Integer方法.valueOf(int)自动装箱，我们来看下.valueOf(int)源码实现：123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 也就是说最后会new出来一个Integer对象或者返回缓存中的数据。注意： ==符号在比较对象时，比较的是内存地址; 对于原始数据类型(如上面a == c)直接比对的是数据值。 这里又涉及到了堆栈内存了，需要清楚2点： new出来的对象或创建的数组会在堆中开辟内存空间； 对象的引用（即对象在堆内存中的地址，如a）和基本数据类型存储在栈中； 由此可知a,b引用指向的对象不是同一个，所以结果是false 知识点二：Integer缓存在上面的.valueOf(int)源码中我们能看到IntegerCache类，看名称就知道是和缓存有关。我们来看下Integer类的静态内部类IntegerCache源码实现：1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125; 该类中有一个静态数组：1static final Integer cache[]; 还有一个静态代码块:1static &#123;...&#125; 既然是在static静态类的静态代码快中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到静态代码快主要是向静态数组中添加了[-128,127],也就要是说，调用方法.valueOf(int)传入的int值在[-128,127]这个范围内时，直接从IntegerCache的缓存数组中获取， 不会去在堆内存中new。 [-128,127]期间的数字比较常用，这一行为有助于节省内存、提高性能。 12if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; 所以在例2中：1.自动装箱调用方法Integer.valueOf(int)12345678910111213141516171819public static void main(String args[]) &#123; Integer f1 = Integer.valueOf(100); // 0 0:bipush 100 // 1 2:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 2 5:astore_1 Integer f2 = Integer.valueOf(100); // 3 6:bipush 100 // 4 8:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 5 11:astore_2 Integer f3 = Integer.valueOf(250); // 6 12:sipush 250 // 7 15:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 8 18:astore_3 Integer f4 = Integer.valueOf(250); // 9 19:sipush 250 // 10 22:invokestatic #16 &lt;Method Integer Integer.valueOf(int)&gt; // 11 25:astore 4 &#125; 2.通过Integer.valueOf(int)内部调用IntegerCache类实现。由于f1,f2对应的基本值在[-128,127]之间，结果返回true;而f3,f4对应的基本值不在范围内，结果返回false 其他的包装类型也可以类似分析，回头再总结。]]></content>
      <categories>
        <category>面试题分析</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
        <tag>包装类型</tag>
        <tag>自动包装</tag>
        <tag>自动拆箱</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
