<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农的春天还没来</title>
  
  <subtitle>等待 突破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-12T05:22:54.648Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>殷学飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈java对象浅度克隆和深度克隆</title>
    <link href="http://yoursite.com/2017/11/12/shallow-and-deep-clone/"/>
    <id>http://yoursite.com/2017/11/12/shallow-and-deep-clone/</id>
    <published>2017-11-12T05:20:16.000Z</published>
    <updated>2017-11-12T05:22:54.648Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="需要克隆的原因"><a href="#需要克隆的原因" class="headerlink" title="需要克隆的原因"></a>需要克隆的原因</h2><p>在工作中我们有时会遇到这样的需求：</p><blockquote><p>A对象包含一些有用信息，这时候需要一个和A完全相同的B对象。拿到B对象后，只需要稍微调整下就ok。A和B是两个独立的对象，只是B的初始值来自于A。而A/B对象中包含了比较复杂的数据结构。此时通过简单的赋值，并不能满足这种需求。</p></blockquote><p>我之前做过一个需求：</p><blockquote><p>定时任务——自动新建XX产品：XX产品包含了很多信息，有<code>基本类型数据</code>也有<code>复杂结构对象</code>。已经上线的产品通过修改某些属性值就可以初始化形成新的XX产品，然后等待上线。这里就用到了克隆。</p></blockquote><hr><h2 id="克隆的实现方式"><a href="#克隆的实现方式" class="headerlink" title="克隆的实现方式"></a>克隆的实现方式</h2><h3 id="浅度克隆"><a href="#浅度克隆" class="headerlink" title="浅度克隆"></a>浅度克隆</h3><p>首先，定义一个<code>Student</code>类，包含两成员变量：<code>name</code>，<code>age</code>，并且实现<code>Cloneable</code>接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再，定义一个<code>Teacher</code>类，也是两字段：一个<code>name</code>，一个聚合对象<code>student</code>，并且实现<code>Cloneable</code>接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Student student;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, Student student)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.student = student;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> student;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudent</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.student = student;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ol><li>实现<code>Cloneable</code>接口<br>需要<code>clone</code>的类为什么要实现该接口？我们先看看该接口的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.lang;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></div><div class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></div><div class="line"><span class="comment"> * is legal for that method to make a</span></div><div class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></div><div class="line"><span class="comment"> * &lt;p&gt;</span></div><div class="line"><span class="comment"> * Invoking Object's clone method on an instance that does not implement the</span></div><div class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></div><div class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></div><div class="line"><span class="comment"> * &lt;p&gt;</span></div><div class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></div><div class="line"><span class="comment"> * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method.</span></div><div class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></div><div class="line"><span class="comment"> * method.</span></div><div class="line"><span class="comment"> * &lt;p&gt;</span></div><div class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method.</span></div><div class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></div><div class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></div><div class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></div><div class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></div><div class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>这是一个<code>“标示接口”</code>，即：没有任何方法和属性的接口。这个标示仅针对<code>java.lang.Object#clone()</code>方法。注释中：<br>第一段可以看到：我们调用的<code>clone()</code>方法是<code>Obejct</code>类的方法；<br>第二段中：若调用这个<code>Object.clone()</code>方法，但是不实现<code>Cloneable</code>接口(not implement Cloneable)的话，会抛<code>CloneNotSupportedException</code>异常。</p><p>我们来测试下，修改<code>Student</code>方法，去掉实现。代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">"jack"</span>, <span class="number">27</span>);</div><div class="line">    Student cloneStudent = (Student) student.clone();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"main"</span> java.lang.CloneNotSupportedException: clone.Student</div><div class="line">at java.lang.Object.clone(Native Method)</div><div class="line">at clone.Student.main(Student.java:<span class="number">38</span>)</div></pre></td></tr></table></figure></p><p>第三段中说：按照惯例，对于<code>Object.clone()</code>方法，我们需要是重写。我们看下该方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</div></pre></td></tr></table></figure></p><p>是个<code>native</code>方法，一般来说native方法的效率要高于非native方法，因此比那种new出新对象再把旧对象的信息赋值到新对象的效率要高。该方法还是个<code>protected</code>方法，也就是说外部程序想调用有局限性，因此需要重写修饰符设置为<code>public</code>。</p><p>下面再看一个<code>Teacher</code>相关的例子，这里先重写下<code>equals()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Teacher) &#123;</div><div class="line">    Teacher teacher = (Teacher) obj;</div><div class="line">    <span class="keyword">if</span> (teacher.name == <span class="keyword">this</span>.name &amp;&amp; teacher.student.equals(<span class="keyword">this</span>.student)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>作如下测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">"jack"</span>, <span class="number">27</span>);</div><div class="line">    Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"Ali"</span>, student);</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"Teacher的内存地址："</span> + teacher);</div><div class="line">    Teacher cloneTeacher = (Teacher) teacher.clone();</div><div class="line">    System.out.println(<span class="string">"克隆Teacher的内存地址："</span> + cloneTeacher);</div><div class="line">    System.out.println(<span class="string">"克隆前后，Teacher对象是否相等："</span> + teacher.equals(cloneTeacher) + <span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"++++++我只想修改克隆对象中的Student姓名为‘rose’++++++\n"</span>);</div><div class="line">    cloneTeacher.getStudent().setName(<span class="string">"rose"</span>);</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"修改Student姓名后，Teacher的内存地址："</span> + teacher);</div><div class="line">    System.out.println(<span class="string">"修改Student姓名后，克隆Teacher的内存地址："</span> + cloneTeacher);</div><div class="line">    System.out.println(<span class="string">"修改Student姓名后，克隆前后，Teacher对象是否相等："</span> + teacher.equals(cloneTeacher));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Teacher的内存地址：clone.Teacher@<span class="number">6</span>c89db9a</div><div class="line">克隆Teacher的内存地址：clone.Teacher@<span class="number">4</span>eb09321</div><div class="line">克隆前后，Teacher对象是否相等：<span class="keyword">true</span></div><div class="line"></div><div class="line">++++++我只想修改克隆对象中的Student姓名为‘rose’++++++</div><div class="line"></div><div class="line">修改Student姓名后，Teacher的内存地址：clone.Teacher@<span class="number">6</span>c89db9a</div><div class="line">修改Student姓名后，克隆Teacher的内存地址：clone.Teacher@<span class="number">4</span>eb09321</div><div class="line">修改Student姓名后，克隆前后，Teacher对象是否相等：<span class="keyword">true</span></div></pre></td></tr></table></figure></p><p>我们可以看到：</p><ul><li>克隆前后，内存地址发生了变化<code>@6c89db9a</code>=&gt;<code>@4eb09321</code>；</li><li>克隆前后以及修改了<code>Student</code>对象<code>name</code>属性值，对象没有变化，<code>equals</code>结果为<code>true</code>。</li></ul><p>也就是说，<strong>不同的引用指向了同一个对象</strong>。因此，若我只想修改克隆对象的信息，这种情况下是做不到的。</p><p>但是若只是修改<code>基本类型</code>或者<code>String字符串</code>，却能满足需求，只会影响克隆后的对象。譬如：<br>去掉：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cloneTeacher.getStudent().setName(<span class="string">"rose"</span>);</div></pre></td></tr></table></figure></p><p>并增加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cloneTeacher.setName(<span class="string">"Alice"</span>);</div></pre></td></tr></table></figure></p><p><code>equals</code>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">修改Student姓名后，克隆前后，Teacher对象是否相等：<span class="keyword">false</span></div></pre></td></tr></table></figure></p><p>最后别忘了重写下<code>clone</code>方法，修改修饰符为<code>public</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.clone();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h3><p><em>深度克隆</em>之所以有<code>深度</code>，是弥补了<em>浅度克隆</em>对于<strong>对象类型的属性</strong>克隆的不足。这里通过<strong>对象序列化和反序列化</strong>来实现深度克隆。</p><p>对象的序列化</p><blockquote><p>把对象转换为字节序列的过程</p></blockquote><p>对象的反序列化：</p><blockquote><p>把字节序列恢复为对象的过程</p></blockquote><p>如何实现：<br>首先新建一个工具类，封装<code>clone</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtil</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">CloneUtil</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">    ByteArrayOutputStream baos = <span class="keyword">null</span>;</div><div class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</div><div class="line">    ByteArrayInputStream bais = <span class="keyword">null</span>;</div><div class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">      oos = <span class="keyword">new</span> ObjectOutputStream(baos);</div><div class="line">      oos.writeObject(obj);</div><div class="line"></div><div class="line">      bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</div><div class="line">      ois = <span class="keyword">new</span> ObjectInputStream(bais);</div><div class="line">      <span class="keyword">return</span> (T) ois.readObject();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Class not found."</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Clone Object failed in IO."</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</div><div class="line">          ois.close();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</div><div class="line">          oos.close();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>说明：</p><blockquote><p>调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义。这两个基于内存的流就能够释只要垃圾回收器清理对象放资源，这一点不同于对外部资源（如文件流）的释放。</p></blockquote><p>修改<code>Student</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>修改<code>Teacher</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Teacher [name="</span> + name + <span class="string">", student="</span> + student + <span class="string">"]"</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>替换<code>main</code>方法中测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Teacher cloneTeacher = (Teacher) teacher.clone();</div></pre></td></tr></table></figure></p><p>为<code>序列化-反序列化</code>克隆方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Teacher cloneTeacher = CloneUtil.clone(teacher);</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=<span class="number">27</span>]]</div><div class="line">克隆Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=<span class="number">27</span>]]</div><div class="line">克隆前后，Teacher对象是否相等：<span class="keyword">false</span></div><div class="line"></div><div class="line">++++++我只想修改克隆对象中的Student姓名为‘rose’++++++</div><div class="line"></div><div class="line">修改Student姓名后，Teacher的的toString：Teacher [name=Ali, student=Student [name=jack, age=<span class="number">27</span>]]</div><div class="line">修改Student姓名后，克隆Teacher的的toString：Teacher [name=Ali, student=Student [name=rose, age=<span class="number">27</span>]]</div><div class="line">修改Student姓名后，克隆前后，Teacher对象是否相等：<span class="keyword">false</span></div></pre></td></tr></table></figure></p><p>明显可以看到，修改<code>Student</code>属性后，对克隆前的对象没有影响。</p><p>需要注意：<code>CloneUtil</code>类中的<code>clone()</code>长这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型<strong><code>&lt;T extends Serializable&gt;</code></strong>限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用<code>Object</code>类的<code>clone</code>方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p><p>当然，若是聚合对象如<code>Teacher</code>中的<code>Student</code>没有实现<code>Serializable</code>接口，还是会在运行时抛异常的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;需要克隆的原因&quot;&gt;&lt;a href=&quot;#需要克隆的原因&quot; class=&quot;headerlink&quot; title=&quot;需要克隆的原因&quot;&gt;&lt;/a&gt;需要克隆的原因&lt;/h2&gt;&lt;p&gt;在工作中我们有时会遇到这样的需求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A对象包含一些
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="浅度克隆" scheme="http://yoursite.com/tags/%E6%B5%85%E5%BA%A6%E5%85%8B%E9%9A%86/"/>
    
      <category term="深度克隆" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/"/>
    
  </entry>
  
  <entry>
    <title>反射机制基础解析</title>
    <link href="http://yoursite.com/2017/11/07/reflect-base/"/>
    <id>http://yoursite.com/2017/11/07/reflect-base/</id>
    <published>2017-11-07T15:02:25.000Z</published>
    <updated>2017-11-07T15:08:30.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p></blockquote><p>通俗来讲：<strong>反射就是把Class对象的各种成分映射成对应的Java类</strong>。</p><hr><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>java反射机制其实就是将<code>.class</code>转化为<code>.java</code>，也即<strong>反编译</strong>。具体主要提供了以下功能：</p><ul><li>在运行时判断任意一个对象所属的<code>类</code>；</li><li>在运行时<code>构造</code>任意一个类的对象；</li><li>在运行时判断任意一个类所具有的<code>成员变量</code>和<code>方法</code>；</li><li>在运行时<code>调用</code>任意一个对象的方法。</li></ul><p>后面会围绕这几点具体展开。</p><hr><h2 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h2><p>在<code>java.lang.reflect</code>包下<strong>提供类和接口，以获得关于类和对象的反射信息</strong>。这里简单罗列了与反射相关的几个重要的API，真正想学习反射机制，除了在项目中历练，API也是非常重要的手段。英语不好理解的话，就搜搜汉化后的API文档。</p><table><thead><tr><th>变量相关</th><th>含义</th></tr></thead><tbody><tr><td>getField(String name)</td><td>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定<strong>公共成员字段</strong>。</td></tr><tr><td>getFields()</td><td>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问<strong>公共字段</strong>。</td></tr><tr><td>getDeclaredField(String name)</td><td>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。</td></tr><tr><td>getDeclaredFields()</td><td>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的<strong>所有字段</strong>。</td></tr><tr><td></td><td></td></tr><tr><td><strong>方法相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr><tr><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td></td><td></td></tr><tr><td><strong>构造方法相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法</td></tr><tr><td>getConstructors()</td><td>返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法</td></tr><tr><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。</td></tr><tr><td>getDeclaredConstructors()</td><td>返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法</td></tr><tr><td></td><td></td></tr><tr><td><strong>父类、父接口相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getInterfaces()</td><td>确定此对象所表示的类或接口实现的接口。</td></tr><tr><td>getSuperclass()</td><td>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。</td></tr><tr><td></td><td></td></tr><tr><td><strong>其他重要相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getModifiers()</td><td>以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符。</td></tr><tr><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称。</td></tr><tr><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。</td></tr><tr><td>newInstance()</td><td>创建此 Class 对象所表示的类的一个新实例。</td></tr><tr><td>isInstance(Object obj)</td><td>判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。</td></tr></tbody></table><hr><h2 id="具体功能实现"><a href="#具体功能实现" class="headerlink" title="具体功能实现"></a>具体功能实现</h2><p>下面通过例子分别讲述<code>获取Class对象的3种方式</code>，<code>如何创建实例</code>，<code>如何获取构造器</code>，<code>如何获取方法</code>，<code>如何获取属性</code>以及通过反射<code>调用方法</code>。</p><h3 id="获取Class对象的3种方式"><a href="#获取Class对象的3种方式" class="headerlink" title="获取Class对象的3种方式"></a>获取Class对象的3种方式</h3><p>例如新建一个类<code>MyReflectTest</code>，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflectTest</span> </span>&#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方式1：使用<code>Class</code>类的中静态<code>forName()</code>方法获得与字符串对应的Class对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class&lt;?&gt; clz = Class.forName(<span class="string">"test.MyReflectTest"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在数据库有关开发中，我们经常会用到这个方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>)</div></pre></td></tr></table></figure></p><p>方式2： 利用对象的<code>class</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意</strong>，在基本类型和包装类型中有，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer.TYPE</div></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>.class</div></pre></td></tr></table></figure></p><p>是<code>int</code>的<code>Class</code>对象，不等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer.class</div></pre></td></tr></table></figure></p><p>这是<code>Integer</code>的<code>Class</code>对象表示，看看源码就知道了。</p><p>方式3：调用对象的<code>getClass()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  MyReflectTest myReflectTest = <span class="keyword">new</span> MyReflectTest();</div><div class="line">  Class clz = myReflectTest.getClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>获取到class对象后，调用<code>newInstance()</code>方法来创建Class对象对应的类实例，<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line">  MyReflectTest newInstance = (MyReflectTest) clz.newInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>获取类的所有构造器，测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line">  </div><div class="line">  <span class="comment">// 获取public构造器数组</span></div><div class="line">  Constructor[] cons = clz.getConstructors();</div><div class="line">  </div><div class="line">  <span class="comment">// 获取public，默认，protected，private构造器数组</span></div><div class="line">  Constructor[] declaredCons = clz.getDeclaredConstructors();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取类中指定的某个构造器，测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyReflectTest</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>();</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyReflectTest(String name, <span class="keyword">int</span> age) &#123;</div><div class="line">  <span class="keyword">super</span>();</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  <span class="comment">// 获取public构造器，构造器参数类型为String</span></div><div class="line">  Constructor con = clz.getConstructor(String.class);</div><div class="line"></div><div class="line">  <span class="comment">// 获取public，默认，protected，private构造器，构造器参数类型为String，int</span></div><div class="line">  Constructor declaredCon = clz.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>新增两个方法:<code>add()</code>和<code>get()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">  System.out.println(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  System.out.println(age);</div><div class="line">  <span class="keyword">return</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>getDeclaredMethods()</code>方法相关测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  Method[] declaredMethods = clz.getDeclaredMethods();</div><div class="line">  <span class="keyword">for</span> (Method method : declaredMethods) &#123;</div><div class="line">    System.out.println(<span class="string">"==============================="</span>);</div><div class="line">    <span class="comment">// 访问修饰符</span></div><div class="line">    System.out.println(Modifier.toString(method.getModifiers()));</div><div class="line">    <span class="comment">// 返回类型</span></div><div class="line">    System.out.println(method.getReturnType());</div><div class="line">    <span class="comment">// 方法名称</span></div><div class="line">    System.out.println(method.getName());</div><div class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; param : parameterTypes) &#123;</div><div class="line">      <span class="comment">// 方法参数类型</span></div><div class="line">      System.out.println(param.getName());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">===============================</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span></div><div class="line"><span class="keyword">void</span></div><div class="line">main</div><div class="line">[Ljava.lang.String; <span class="comment">//"["表示数组对象</span></div><div class="line">===============================</div><div class="line"><span class="keyword">private</span></div><div class="line"><span class="keyword">void</span></div><div class="line">add</div><div class="line">java.lang.String</div><div class="line">===============================</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="keyword">int</span></div><div class="line">get</div></pre></td></tr></table></figure></p><p>能获取私有的方法<code>add()</code>。<br>看看另一个反射方法：<code>getMethods()</code>，代码和上面一个，基本没变化。<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  Method[] methods = clz.getMethods();</div><div class="line">  <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">    System.out.println(<span class="string">"+++++++++++++++++++++++++++++++++"</span>);</div><div class="line">    System.out.println(Modifier.toString(method.getModifiers()));</div><div class="line">    System.out.println(method.getReturnType());</div><div class="line">    System.out.println(method.getName());</div><div class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; param : parameterTypes) &#123;</div><div class="line">      System.out.println(param.getName());</div><div class="line">      </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span></div><div class="line"><span class="keyword">void</span></div><div class="line">main</div><div class="line">[Ljava.lang.String;</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="keyword">int</span></div><div class="line">get</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span></div><div class="line"><span class="keyword">void</span></div><div class="line">wait</div><div class="line"><span class="keyword">long</span></div><div class="line"><span class="keyword">int</span></div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span></div><div class="line"><span class="keyword">void</span></div><div class="line">wait</div><div class="line"><span class="keyword">long</span></div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span></div><div class="line"><span class="keyword">void</span></div><div class="line">wait</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="keyword">boolean</span></div><div class="line">equals</div><div class="line">java.lang.Object</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></div><div class="line"><span class="class"><span class="title">toString</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">int</span></span></div><div class="line"><span class="class"><span class="title">hashCode</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span></span></div><div class="line"><span class="class"><span class="title">getClass</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">void</span></span></div><div class="line"><span class="class"><span class="title">notify</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">void</span></span></div><div class="line"><span class="class"><span class="title">notifyAll</span></span></div></pre></td></tr></table></figure></p><p>对比上面的<code>getDeclaredMethods()</code>，少了一个私有的方法<code>add()</code>，但是多了好多不在本类的方法。由于每个类的超类都是<code>Object</code>类，很明显，这些方法都是来自超类，看看源码也能发现这个。也就是说：</p><ul><li><code>getDeclaredMethods()</code>获取的是本类的方法，public、默认、protected、private；</li><li><code>getMethods()</code>获取的是本类和父类的所有的public的方法。</li></ul><p>另外有获取指定某一个方法的反射方法。<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">", age: "</span> + age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  <span class="comment">// 第一个参数是“方法名”，后面的是方法的可变参数列表</span></div><div class="line">  Method method = clz.getMethod(<span class="string">"save"</span>, String.class, <span class="keyword">int</span>.class);</div><div class="line">  System.out.println(Modifier.toString(method.getModifiers()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span></div></pre></td></tr></table></figure></p><p>其他的类似。</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>创建两个成员变量<code>name</code>，<code>age</code>，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String name;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  Field[] fields = clz.getFields();</div><div class="line">  <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">    System.out.println(<span class="string">"+++++++++++++++++++++++++"</span>);</div><div class="line">    System.out.println(Modifier.toString(field.getModifiers()));</div><div class="line">    System.out.println(field.getType());</div><div class="line">    System.out.println(field.getName());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Field[] declaredFields = clz.getDeclaredFields();</div><div class="line">  <span class="keyword">for</span> (Field field : declaredFields) &#123;</div><div class="line">    System.out.println(<span class="string">"========================="</span>);</div><div class="line">    System.out.println(Modifier.toString(field.getModifiers()));</div><div class="line">    System.out.println(field.getType());</div><div class="line">    System.out.println(field.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></div><div class="line"><span class="class"><span class="title">name</span></span></div><div class="line"><span class="class"></span>=========================</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></div><div class="line"><span class="class"><span class="title">name</span></span></div><div class="line"><span class="class"></span>=========================</div><div class="line"><span class="keyword">private</span></div><div class="line"><span class="keyword">int</span></div><div class="line">age</div></pre></td></tr></table></figure></p><p>另外<code>getField(String)</code>，<code>getDeclaredField(String)</code>参数为方法名，和<code>Method</code>类似。</p><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>通过上面的一系列操作获取到某一方法后，我们可以利用<code>invoke()</code>方法来调用这个方法。<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">", age: "</span> + age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class&lt;MyReflectTest&gt; clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  <span class="comment">// 获取对象实例</span></div><div class="line">  MyReflectTest reflect = (MyReflectTest) clz.newInstance();</div><div class="line">  </div><div class="line">  <span class="comment">// 获取save方法</span></div><div class="line">  Method method = clz.getMethod(<span class="string">"save"</span>, String.class, <span class="keyword">int</span>.class);</div><div class="line">  </div><div class="line">  <span class="comment">// 第一个参数为对象实例，后面的为方法的参数</span></div><div class="line">  Object result = method.invoke(reflect, <span class="string">"jack"</span>, <span class="number">27</span>);</div><div class="line">  </div><div class="line">  System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name: jack, age: <span class="number">27</span></div></pre></td></tr></table></figure></p><p>最后：反射在工作中其实用到的时候并不多，主要用来构建框架。譬如Spring中的<code>IOC</code>也即<code>控制反转</code>，其底层就是利用了反射。以后有时间再整理下这块。反射机制基础到这结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Reflection enables Java code to discover information abou
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>静态static与非静态non-static(变量、方法、内部类)解析</title>
    <link href="http://yoursite.com/2017/11/06/static-and-non-static/"/>
    <id>http://yoursite.com/2017/11/06/static-and-non-static/</id>
    <published>2017-11-06T14:54:16.000Z</published>
    <updated>2017-11-06T15:04:50.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。<br> </p><p align="right">—— <a href="https://baike.baidu.com/item/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/10078563?fr=aladdin" target="_blank" rel="external">Java编程思想</a></p><p></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;一句话描述下：<strong>方便在对象没有创建的时候调用方法或变量</strong>。<em>很显然，<code>static</code>依赖于<code>类</code>，只要类加载了，就可以使用，而不需要等对象实例化后再调用。</em></p><p>下面具体分析下。</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul><li><code>static</code>修饰的变量，也叫<code>类变量</code>；</li><li>可以直接用<code>类名.变量</code>调用，也可以用<code>对象名.变量</code>调用；</li><li>所有对象的同一个类变量共享同一块内存空间。</li></ul><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul><li>没有<code>static</code>修饰，也就<code>对象变量</code>；</li><li>只能通过<code>对象</code>调用；</li><li>所有对象的同一个类变量共享不同内存空间。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>静态变量是所有对象<strong>共有的</strong>，当某一个对象将它的值改变，此时其他对象去获取时，将得到改变后的值，因为它依赖于<code>类</code>；</li><li>实例变量是每一个对象<strong>私有的</strong>，当某一个对象将它的值改变，此时其他对象去获取时，得到的还是改变前的值，因为它依赖具体的<code>实例</code>；</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>静态变量和非静态变量举例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"静态变量：直接用‘类名.’调用: age = "</span> + StaticTest.age);</div><div class="line"></div><div class="line">    <span class="comment">// 修改静态变量值</span></div><div class="line">    StaticTest.age = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 实例化StaticTest对象</span></div><div class="line">    StaticTest staticTest = <span class="keyword">new</span> StaticTest();</div><div class="line">    System.out.println(<span class="string">"静态变量：通过‘实例化后的对象’调用：age = "</span> + staticTest.age);</div><div class="line">    System.out.println(<span class="string">"实例变量：只能通过‘实例化后的对象’调用：level = "</span> + staticTest.level);</div><div class="line"></div><div class="line">    <span class="comment">// 修改静态变量值</span></div><div class="line">    staticTest.age = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 修改实例变量值</span></div><div class="line">    staticTest.level = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 再实例化一个StaticTest对象</span></div><div class="line">    StaticTest staticTest1 = <span class="keyword">new</span> StaticTest();</div><div class="line">    System.out.println(<span class="string">"静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = "</span> + staticTest1.age);</div><div class="line">    System.out.println(<span class="string">"实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = "</span> + staticTest1.level);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">静态变量：直接用‘类名.’调用: age = 1</div><div class="line">静态变量：通过‘实例化后的对象’调用：age = 2</div><div class="line">实例变量：只能通过‘实例化后的对象’调用：level = 1</div><div class="line">静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = 3</div><div class="line">实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = 1</div></pre></td></tr></table></figure></p><p>结果和前面分析的一致。</p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><code>static</code>修饰的方法，属于<code>类</code>；</li><li>可以直接用<code>类名.方法名</code>调用，也可以用<code>对象名.方法名</code>调用；</li><li>在访问本类成员时，只允许访问<code>静态变量</code>和<code>静态方法</code>，不允许访问<code>实例变量</code>和<code>实例方法</code>；</li><li><code>static</code>块也即静态代码块，只能调用静态方法。</li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li>没有<code>static</code>修饰，属于<code>对象</code>；</li><li>只能通过<code>对象</code>调用；</li><li>实例方法可以访问<code>实例成员</code>，也可访问<code>静态成员</code>；</li><li><code>static</code>块中不能调用实例方法。</li></ul><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 非静态方法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="keyword">this</span>.level);</div><div class="line">    </div><div class="line">    System.out.println(age);</div><div class="line">    </div><div class="line">    staticMethod();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 静态方法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(age);</div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过</span></div><div class="line">    <span class="comment">//System.out.println(level);</span></div><div class="line"></div><div class="line">    System.out.println(<span class="keyword">new</span> StaticTest().level);</div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过</span></div><div class="line">    <span class="comment">//nonStaticMethod();</span></div><div class="line"></div><div class="line">    <span class="keyword">new</span> StaticTest().nonStaticMethod();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;静态方法在类加载时就创建了，但是非静态方法需要实例化后才能创建，因为<strong>先类加载，再实例化</strong>，所以静态方法中不能直接访问类的成员，只有类实例化后才能访问。</p><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;将一个类的定义放在另一个类的定义内部，就是内部类。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;这里只分析普通内部类和静态内部类的区别，具体关于内部类知识暂时请参见<a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="external">详解内部类</a></p><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><ul><li>不能有静态成员（静态方法，静态变量），否则编译不通过；</li><li>可以访问外部类的所有成员（方法，属性）；</li><li>实例化内部类方法：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1). 先生成一个外部类的对象实例，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass o = <span class="keyword">new</span> OutClass();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2). 通过外部类的对象实例生成内部类对象，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerClass no_static_i = o.new InnerClass();</div></pre></td></tr></table></figure></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ul><li>可以有静态和非静态成员；</li><li>只能访问外部类的静态成员；</li><li>实例化一个静态内部类方法：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1). 不依赖外部类的实例，直接实例化内部类对象，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerStaticClass static_i  = <span class="keyword">new</span> OutClass.InnerStaticClass();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2). 调用静态内部类的方法或变量，通过类名直接调用，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerStaticClass.static_name;</div><div class="line">OutClass.InnerStaticClass.getName();</div></pre></td></tr></table></figure></p><h3 id="举例及总结"><a href="#举例及总结" class="headerlink" title="举例及总结"></a>举例及总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String outName = <span class="string">"OutClass.outName"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> String staticOutName = <span class="string">"OutClass.staticOutName"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOutName</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(outName);</div><div class="line">    System.out.println(staticOutName);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getOutStaticName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 编译不通过，静态方法不能访问非静态成员</span></div><div class="line">    <span class="comment">//System.out.println(outName);</span></div><div class="line"></div><div class="line">    System.out.println(staticOutName);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 依赖外部类实例，创建非静态内部类</span></div><div class="line">    OutClass o = <span class="keyword">new</span> OutClass();</div><div class="line">    OutClass.InnerClass no_static_i = o.new InnerClass();</div><div class="line">    no_static_i.getInnerName();</div><div class="line"></div><div class="line">    <span class="comment">// 不依赖外部类实例，直接实例化静态内部类</span></div><div class="line">    OutClass.InnerStaticClass static_i = <span class="keyword">new</span> OutClass.InnerStaticClass();</div><div class="line">    static_i.getInnerName();</div><div class="line"></div><div class="line">    <span class="comment">// 通过静态内部类类名直接调用成员变量或方法</span></div><div class="line">    System.out.println(OutClass.InnerStaticClass.staticInnerName);</div><div class="line">    OutClass.InnerStaticClass.getStaticInnerName();</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 非静态内部类</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 编译不通过，普通静态内部类中不能有static变量</span></div><div class="line">    <span class="comment">//static String staticInnerName = "InnerClass.staticInnerName";</span></div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过，普通静态内部类中不能有static方法</span></div><div class="line">    <span class="comment">//public static void getStaticInnerName() &#123;</span></div><div class="line">    <span class="comment">//  System.out.println(staticInnerName);</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line"></div><div class="line">    String innerName = <span class="string">"InnerClass.innerName"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(innerName);</div><div class="line"></div><div class="line">      <span class="comment">// 直接访问外部类成员变量</span></div><div class="line">      System.out.println(outName);</div><div class="line"></div><div class="line">      <span class="comment">// 直接访问外部类静态成员变量</span></div><div class="line">      System.out.println(staticOutName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 静态内部类</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerStaticClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> String staticInnerName = <span class="string">"InnerStaticClass.staticInnerName"</span>;</div><div class="line"></div><div class="line">    String innerName = <span class="string">"InnerStaticClass.innerName"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getStaticInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(staticInnerName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(innerName);</div><div class="line"></div><div class="line">      <span class="comment">// 编译不通过，不能直接反问外部类成员变量</span></div><div class="line">      <span class="comment">//System.out.println(outName);</span></div><div class="line"></div><div class="line">      <span class="comment">// 只能访问外部类静态成员</span></div><div class="line">      System.out.println(staticOutName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="静态" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81/"/>
    
      <category term="非静态" scheme="http://yoursite.com/tags/%E9%9D%9E%E9%9D%99%E6%80%81/"/>
    
      <category term="内部类" scheme="http://yoursite.com/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>反编译小工具：jad常用命令介绍</title>
    <link href="http://yoursite.com/2017/11/06/jad-cmd-introduce/"/>
    <id>http://yoursite.com/2017/11/06/jad-cmd-introduce/</id>
    <published>2017-11-05T16:56:14.000Z</published>
    <updated>2017-11-05T17:13:50.446Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>jad</code>是最简单的字节码<code>.class</code>反编译出源码<code>.java</code>的小工具。<br>是<code>jdk</code>自带的，我的在<code>‪D:\Java\jdk1.7.0_80\bin\jad.exe</code>。</p><hr><h2 id="jad常用命令"><a href="#jad常用命令" class="headerlink" title="jad常用命令"></a>jad常用命令</h2><ul><li><code>-o</code> 不提示，覆盖源文件，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -o example.class</div></pre></td></tr></table></figure></li></ul><p>　若当前目录下有<code>example.jad</code>文件（默认扩展名<code>jad</code>），执行该命令后会覆盖原<code>example.jad</code>文件</p><ul><li><code>-s</code> 指定输出文件的类型，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -s java example.class</div></pre></td></tr></table></figure></li></ul><p>反编译结果以<code>.java</code>为扩展名。</p><ul><li><code>-p</code> 将反编译结果输出到<code>cmd</code>窗口，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -p example.class</div></pre></td></tr></table></figure></li></ul><p>反编译结果直接在<code>cmd</code>界面显示。</p><ul><li><code>&gt;</code> 将反编译结果重定向到文件，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -p example.class &gt; example1.java</div></pre></td></tr></table></figure></li></ul><p>在当前目录下，将<code>example.class</code>反编译后输出到<code>example1.java</code>文件中。</p><ul><li><code>-d</code> 指定反编译的输出文件目录，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -d test example.class</div></pre></td></tr></table></figure></li></ul><p>在当前目录下会产生目录<code>test</code>，里面有<code>example.jad</code>文件</p><p><strong>常用命令组合</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java example.class</div></pre></td></tr></table></figure></p><ul><li>用<code>JVM字节码格式</code>来注解输出(<code>-a</code>)；</li><li>覆盖原文件（<code>-o</code>）；</li><li>以<code>java</code>扩展名输出<code>example</code>文件（<code>-s java</code>）</li></ul><h2 id="jad帮助信息"><a href="#jad帮助信息" class="headerlink" title="jad帮助信息"></a>jad帮助信息</h2><p><code>jad</code>的帮助信息如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">Options: </div><div class="line">                   //用JVM字节格式来注解输出   </div><div class="line">         -a       - generate JVM instructions as comments (annotate) </div><div class="line">                  //同 -a,但是注解的时候用全名称</div><div class="line">         -af      - output fully qualified names when annotating</div><div class="line">                  //输出多于的括号 (e.g., if(a) &#123; b(); &#125;, default: no)</div><div class="line">         -b       - generate redundant braces (braces)</div><div class="line">                  //清除所有的前缀 </div><div class="line">         -clear   - clear all prefixes, including the default ones</div><div class="line">                  //指定输出文件的文件目录</div><div class="line">         -d &lt;dir&gt; - directory for output files</div><div class="line">                  //试图反编译代码的dead 部分(default: no)</div><div class="line">         -dead    - try to decompile dead parts of code (if there are any)</div><div class="line">                  //不用用字节码的方式反编译 (no JAVA source generated)</div><div class="line">         -dis     - disassembler only (disassembler)</div><div class="line">                  //输出整个的名字,无论是类还是方法</div><div class="line">         -f       - generate fully qualified names (fullnames)</div><div class="line">                  //输出类的成员在方法之前 (default: after methods)</div><div class="line">         -ff      - output fields before methods (fieldsfirst)</div><div class="line">                  //输出所有的变量的缺省的最初值</div><div class="line">         -i       - print default initializers for fields (definits)</div><div class="line">                  //将strings分割成指定数目的块的字符 (default: no)</div><div class="line">         -l&lt;num&gt;  - split strings into pieces of max &lt;num&gt; chars (splitstr)</div><div class="line">                  //将输出文件用行号来注解 (default: no)</div><div class="line">         -lnc     - output original line numbers as comments (lnc)</div><div class="line">                  //分割strings用新行字符 newline character (default: no)</div><div class="line">         -nl      - split strings on newline characters (splitstr)</div><div class="line">                  //不要转换java的定义符 (default: do)</div><div class="line">         -noconv  - don&apos;t convert Java identifiers into valid ones (noconv)</div><div class="line">                  //不要生成辅助文件</div><div class="line">         -nocast  - don&apos;t generate auxiliary casts</div><div class="line">                  //不要生成方法的源代码 </div><div class="line">         -nocode  - don&apos;t generate the source code for methods</div><div class="line">                  //不允许空的构造器存在</div><div class="line">         -noctor  - suppress the empty constructors</div><div class="line">                  //不要去检查class文件是否以dos方式写 (CR before NL, default: check)</div><div class="line">         -nodos   - turn off check for class files written in DOS mode</div><div class="line">                  //关掉对内部类的支持 (default: turn on)</div><div class="line">         -noinner - turn off the support of inner classes</div><div class="line">                  //忽略局部变量的表信息</div><div class="line">         -nolvt   - ignore Local Variable Table entries (nolvt)</div><div class="line">                  //不要输出一个新行在打开一个括号之前 (default: do)</div><div class="line">         -nonlb   - don&apos;t insert a newline before opening brace (nonlb)</div><div class="line">                  //无需确认直接覆盖输出 (default: no)</div><div class="line">         -o       - overwrite output files without confirmation</div><div class="line">                  //发送反编译代码到标准输出 STDOUT (e.g., for piping)</div><div class="line">         -p       - send all output to STDOUT (for piping)</div><div class="line">                  //在生成源代码时将所有的包加前缀</div><div class="line">         -pa &lt;pfx&gt;- prefix for all packages in generated source files</div><div class="line">                  //用数字名字给所有的类加前缀 (default: _cls)</div><div class="line">         -pc &lt;pfx&gt;- prefix for classes with numerical names (default: _cls)</div><div class="line">                  //给没有用到的异常的名字加前缀</div><div class="line">         -pe &lt;pfx&gt;- prefix for unused exception names (default: _ex)</div><div class="line">                  //用数字名字给所有的成员变量加前缀 (default: _fld)</div><div class="line">         -pf &lt;pfx&gt;- prefix for fields with numerical names (default: _fld)</div><div class="line">                  //在&lt;num&gt; 的导入之后将其他引用包裹成一行导入 (default: 3)</div><div class="line">         -pi&lt;num&gt; - pack imports into one line using .* (packimports)</div><div class="line">                  //给局部变量用数字名字加前缀 (default: _lcl)</div><div class="line">         -pl &lt;pfx&gt;- prefix for locals with numerical names (default: _lcl)</div><div class="line">                  //给方法用数字名字加前缀 (default: _mth)  </div><div class="line">         -pm &lt;pfx&gt;- prefix for methods with numerical names (default: _mth)</div><div class="line">                  //给方法的参数用数字名字加前缀 (default: _prm)</div><div class="line">         -pp &lt;pfx&gt;- prefix for method parms with numerical names (default:_prm)</div><div class="line">                  //将同类型的成员包裹成一行 (default: no)</div><div class="line">         -pv&lt;num&gt; - pack fields with the same types into one line (packfields)</div><div class="line">                  //恢复包的目录结构</div><div class="line">         -r       - restore package directory structure</div><div class="line">                  //指定输出文件的类型 (by default &apos;.jad&apos;)</div><div class="line">         -s &lt;ext&gt; - output file extension (default: .jad)</div><div class="line">                  //遇到关键字(if/for/while/etc)输出空格和表达式 (default: off)</div><div class="line">         -space   - output space between keyword (if, while, etc) and expression</div><div class="line">                  //显示所有的类，方法，成员变量的总数</div><div class="line">         -stat    - show the total number of processed classes/methods/fields</div><div class="line">                  //用 &lt;num&gt;个的空格 (default: 4)</div><div class="line">         -t&lt;num&gt;  - use &lt;num&gt; spaces for indentation (default: 4)</div><div class="line">                  //用tabs代替空格对于边缘</div><div class="line">         -t       - use tabs instead of spaces for indentation</div><div class="line">                  //正在反编译的时候 显示方法的名字 </div><div class="line">         -v       - show method names while decompiling</div><div class="line">                  //将 UNICODE strings 转换成 8-bit strings，用当前的 ANSI 码页 (Win32 only)</div><div class="line">         -8       - convert Unicode strings into ANSI strings (ansi)</div><div class="line">                  //重新定向 STDERR to STDOUT (Win32 only)</div><div class="line">         -&amp;       - redirect STDERR to STDOUT</div></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;jad&lt;/code&gt;是最简单的字节码&lt;code&gt;.class&lt;/code&gt;反编译出源码&lt;code&gt;.java&lt;/code&gt;的小工具。&lt;br&gt;是&lt;code&gt;jdk&lt;/code&gt;自带的，我的在&lt;code&gt;‪D:\Java\jdk1.7.0_80\bin\j
      
    
    </summary>
    
      <category term="小工具" scheme="http://yoursite.com/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/java/"/>
    
    
      <category term="反编译" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
      <category term="jad" scheme="http://yoursite.com/tags/jad/"/>
    
  </entry>
  
  <entry>
    <title>抽象类（abstract class）和接口（interface）解析</title>
    <link href="http://yoursite.com/2017/11/05/abstract-and-interface/"/>
    <id>http://yoursite.com/2017/11/05/abstract-and-interface/</id>
    <published>2017-11-05T11:03:12.000Z</published>
    <updated>2017-11-07T15:12:50.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>抽象类</strong>：<em>包含抽象方法的类就称为 抽象类</em>；<br><strong>接口</strong>： <em>抽象方法的集合，方法没有具体实现即不包含方法体</em>。</p><hr><h2 id="两者异同"><a href="#两者异同" class="headerlink" title="两者异同"></a>两者异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都<code>不能</code>被实例化；</li><li><code>接口的实现类</code>或<code>抽象类的子类</code>都<strong>必须实现</strong><code>接口</code>或<code>抽象类中</code>的方法后才能被实例化</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li><code>接口</code>中的方法是高度抽象的，<em>只有定义，没有具体的实现</em>；<code>抽象类</code>中<em>可以有定义也可以有实现</em>；</li><li><code>接口</code>中的方法默认为<code>public abstract</code>， 可以直接写<code>public</code>， 可以都省略不写；<code>接口</code>中方法修饰符不能是<code>private</code>， 接口需要实现，所以私有的方法没有意义；<code>抽象类</code>中的具体实现的方法和普通的类一样，而只有定义的方法必须用<code>abstract</code>修饰，不然<code>编译不通过</code>；而且<code>抽象方法</code>的修饰符不能是<code>private</code>，<code>static</code>，<code>synchronized</code>，<code>native</code>，能用<code>默认的</code>，<code>public</code>和<code>protected</code>。</li><li><code>接口</code>中定义变量默认为<code>public static final</code>， 并且要赋予<code>初始值</code>，不然编译不通过；<code>抽象类</code>和普通的类一样，可以有自己的成员变量，可以重新赋值；</li><li><code>接口</code>需要<code>实现（implements）</code>， <code>抽象类</code>需要<code>继承（extends）</code>，<em>一个类可以实现多个接口，但是只能继承一个抽象类（单继承多实现）</em>。</li></ol><h2 id="接口三问"><a href="#接口三问" class="headerlink" title="接口三问"></a>接口三问</h2><h3 id="接口方法能否用private修饰"><a href="#接口方法能否用private修饰" class="headerlink" title="接口方法能否用private修饰"></a>接口方法能否用<code>private</code>修饰</h3><blockquote><p>不能。因为接口是对外开放的，需要具体的类来实现其中的方法，私有的方法作用范围为本类，在接口中定义私有方法没有任何意义，编译不会通过。</p></blockquote><h3 id="接口方法能否用synchronized修饰"><a href="#接口方法能否用synchronized修饰" class="headerlink" title="接口方法能否用synchronized修饰"></a>接口方法能否用<code>synchronized</code>修饰</h3><blockquote><p>不能。<code>synchronized</code>是一种<code>同步锁</code>，在修饰方法时，需要具体逻辑，而接口只是定义，因为直接修饰接口中的方法没意义，可以用来修饰接口方法的<code>具体实现</code>。</p></blockquote><h3 id="接口方法能否用static修饰"><a href="#接口方法能否用static修饰" class="headerlink" title="接口方法能否用static修饰"></a>接口方法能否用<code>static</code>修饰</h3><blockquote><p>这和jdk版本有关。jdk8之前：不能；jdk8新特性： 能。<br>——参见<a href="http://letus179.com/2017/11/05/JDK8-static-and-default/" target="_blank" rel="external">JDK8新特性之接口的静态方法和默认方法</a></p></blockquote><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>这里提供两种方式：<code>jad反编译</code>和<code>反射</code>来获取成员变量和方法的相关内容。</p><h3 id="jad反编译"><a href="#jad反编译" class="headerlink" title="jad反编译"></a>jad反编译</h3><p>下面先给出对应源码，再用<code>jad</code>反编译<code>.class</code>文件。反编译执行命令如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java 类名.class</div></pre></td></tr></table></figure></p><p><code>jad</code>详细命令参见<a href="http://letus179.com/2017/11/06/jad-cmd-introduce/" target="_blank" rel="external">反编译小工具：jad常用命令介绍</a></p><h4 id="接口-java源码"><a href="#接口-java源码" class="headerlink" title="接口.java源码"></a>接口.java源码</h4><p><code>MyInterface.java</code>接口源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">  String name = <span class="string">"MyInterface"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="接口-class反编译"><a href="#接口-class反编译" class="headerlink" title="接口.class反编译"></a>接口.class反编译</h4><p><code>MyInterface.class</code>反编译结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"MyInterface"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，</p><p>1.在成员变量（常量）中默认的修饰符是<code>public static final</code>;<br>2.在方法中，默认的修饰符是<code>public abstract</code></p><h4 id="抽象类-java源码"><a href="#抽象类-java源码" class="headerlink" title="抽象类.java源码"></a>抽象类.java源码</h4><p><code>MyAbstract</code>抽象类源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstract</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"MyAbstract get() "</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 抽象类中的没有实现的方法必须是“abstract”</span></div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="抽象类-class反编译"><a href="#抽象类-class反编译" class="headerlink" title="抽象类.class反编译"></a>抽象类.class反编译</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstract</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAbstract</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyAbstract get() "</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，成员方法和成员变量和普通类一样，是什么修饰就是什么。</p><h3 id="反射获取"><a href="#反射获取" class="headerlink" title="反射获取"></a>反射获取</h3><p>这里新建一个<code>MyTest</code>类，<code>继承</code>抽象类<code>MyAbstract</code>，并且<code>实现</code>接口<code>MyInterface</code></p><h4 id="反射代码"><a href="#反射代码" class="headerlink" title="反射代码"></a>反射代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">MyAbstract</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">Field[] abstractFields = MyAbstract.class.getDeclaredFields();</div><div class="line">Method[] abstractMethods = MyAbstract.class.getDeclaredMethods();</div><div class="line"></div><div class="line">System.out.println(<span class="string">"抽象类MyAbstract成员变量反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Field f : abstractFields) &#123;</div><div class="line">System.out.println(<span class="string">"变量名："</span> + f.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(f.getModifiers()));</div><div class="line">System.out.println(<span class="string">"变量类型："</span> + f.getType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"抽象类MyAbstract成员方法反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Method m : abstractMethods) &#123;</div><div class="line">System.out.println(<span class="string">"方法名："</span> + m.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(m.getModifiers()));</div><div class="line">System.out.println(<span class="string">"返回类型："</span> + m.getReturnType()  + <span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Field[] interfaceFields = MyInterface.class.getDeclaredFields();</div><div class="line">Method[] interfaceMethods = MyInterface.class.getDeclaredMethods();</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"接口MyInterface成员变量反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Field f : interfaceFields) &#123;</div><div class="line">System.out.println(<span class="string">"变量名："</span> + f.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(f.getModifiers()));</div><div class="line">System.out.println(<span class="string">"变量类型："</span> + f.getType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"接口MyInterface成员方法反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Method m : interfaceMethods) &#123;</div><div class="line">System.out.println(<span class="string">"方法名："</span> + m.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(m.getModifiers()));</div><div class="line">System.out.println(<span class="string">"返回类型："</span> + m.getReturnType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">抽象类MyAbstract成员变量反射信息：</div><div class="line">变量名：name</div><div class="line">修饰符：public</div><div class="line">变量类型：class java.lang.String</div><div class="line"></div><div class="line">抽象类MyAbstract成员方法反射信息：</div><div class="line">方法名：get</div><div class="line">修饰符：</div><div class="line">返回类型：void</div><div class="line"></div><div class="line">方法名：delete</div><div class="line">修饰符：abstract</div><div class="line">返回类型：void</div><div class="line"></div><div class="line">接口MyInterface成员变量反射信息：</div><div class="line">变量名：name</div><div class="line">修饰符：public static final</div><div class="line">变量类型：class java.lang.String</div><div class="line"></div><div class="line">接口MyInterface成员方法反射信息：</div><div class="line">方法名：add</div><div class="line">修饰符：public abstract</div><div class="line">返回类型：void</div></pre></td></tr></table></figure><p>可以看到，和<code>jad</code>反编译的结果是一样的。</p><p>具体的<code>反射机制</code>请参见另一篇博文<a href="http://letus179.com/2017/11/07/reflect-base/" target="_blank" rel="external">反射机制基础解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;抽象类&lt;/strong&gt;：&lt;em&gt;包含抽象方法的类就称为 抽象类&lt;/em&gt;；&lt;br&gt;&lt;strong&gt;接口&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="抽象类" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="jdk8新特性" scheme="http://yoursite.com/tags/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性之接口的静态方法和默认方法</title>
    <link href="http://yoursite.com/2017/11/05/JDK8-static-and-default/"/>
    <id>http://yoursite.com/2017/11/05/JDK8-static-and-default/</id>
    <published>2017-11-05T10:50:10.000Z</published>
    <updated>2017-11-07T15:21:25.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JDK8之前</strong>我们在接口中定义<code>成员变量</code>只能是<code>public static final</code>的，定义的<code>成员方法</code>只能是<code>public abstract</code>的，默认省略。JDK8前后这一概念等价。定义接口<code>BeforeJDK8Interface</code>如下：<br><code>name</code>和<code>name1</code>表述等价，<code>getName()</code>和<code>getName1()</code>表述等价。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeJDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">    String name = <span class="string">"BeforeJDK8Interface"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//public、 static、 final 可以单独使用，也可以组合使用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name1 = <span class="string">"BeforeJDK8Interface"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//public、 abstract 可以单独使用，也可以组合使用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getName1</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>JDK8新增特性</strong>，允许我们在接口中定义<strong>default默认方法</strong>和<strong>static静态方法</strong>。定义接口<code>JDK8Interface</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">myDefaultMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"JDK8新特性:接口中的默认方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myStaticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"JDK8新特性：接口中的静态方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实现接口时，这里static方法由于<code>static</code>的原因，属于接口类，只能通过 <em>接口类名直接调用</em>；<br>而default方法，需要 <em>接口实现类实例化后调用</em>。定义接口实现类<code>JDK8InterfaceImpl</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JDK8Interface.myStaticMethod();</div><div class="line"></div><div class="line">        JDK8InterfaceImpl jdk8Interface = <span class="keyword">new</span> JDK8InterfaceImpl();</div><div class="line">        jdk8Interface.myDefaultMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于<code>static</code>的原因，静态方法不能重写；但是default方法却可以，重写<code>myDefaultMethod</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDefaultMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"接口中的default方法不满足需求，需要重写"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里稍注意下，<code>JDK8Interface</code>接口中<code>default</code>方法用了修饰符<code>&quot;default&quot;</code>，这里重写后修饰符是<code>&quot;public&quot;</code></p><p>由于java实行的是<strong>单继承</strong><code>extends</code><strong>多实现</strong><code>implements</code>，那<code>JDK8</code>新增特性中的两个方法有啥要求不？</p><ul><li>首先看看<code>static</code>方法，由于调用static方法时，用的是接口类名，不能的接口类名肯定不同，所以<strong>没影响</strong>；</li><li>对于<code>default</code>方法， 有于是实现类实例化后调用，若该类有<code>多个接口</code>且接口中有<code>相同名称</code>的default方法，这时候编译器就没办法区分了，<strong>会报错，必须重写default方法</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JDK8之前&lt;/strong&gt;我们在接口中定义&lt;code&gt;成员变量&lt;/code&gt;只能是&lt;code&gt;public static final&lt;/code&gt;的，定义的&lt;code&gt;成员方法&lt;/code&gt;只能是&lt;code&gt;public abstract&lt;/code&gt;的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jdk8新特性" scheme="http://yoursite.com/tags/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="静态方法" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
      <category term="默认方法" scheme="http://yoursite.com/tags/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>重载（Overload）和重写（Override）解析</title>
    <link href="http://yoursite.com/2017/11/02/overload-and-override/"/>
    <id>http://yoursite.com/2017/11/02/overload-and-override/</id>
    <published>2017-11-02T15:23:49.000Z</published>
    <updated>2017-11-06T15:04:27.536Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="重载Overload"><a href="#重载Overload" class="headerlink" title="重载Overload"></a>重载Overload</h3><p>   重载发生在<code>一个类</code>中，<code>同名的方法</code>如果有<code>不同的参数列表</code>（<code>参数类型不同</code>、<code>参数个数不同</code>或者<code>二者都不同</code>）。</p><ul><li>访问修饰符：重载与访问修饰符<code>无关</code> </li><li>返回类型： 重载与返回值<code>无关</code></li><li>方法名： 重载方法名需<code>完全一致</code> </li><li>参数列表： 重载参数列表需<code>完全不同</code></li></ul><h3 id="重写Override"><a href="#重写Override" class="headerlink" title="重写Override"></a>重写Override</h3><p>   发生在<code>子类与父类</code>之间，重写要求子类被重写方法与父类被重写方法有<code>相同的返回类型</code>，比父类被重写方法<code>更好访问</code>，<code>不能</code>比父类被重写方法声明<code>更多的异常</code>（里氏代换原则）。</p><ul><li>访问修饰符：子类的访问修饰符权限 <code>&gt;=</code> 父类的访问修饰符权限 </li><li>返回类型： 子类的返回类型 <code>&lt;=</code> 父类的返回类型 </li><li>方法名： 方法名应<code>完全一致</code> </li><li>参数列表： 参数列表应<code>完全一致</code></li></ul><hr><h2 id="举例String类"><a href="#举例String类" class="headerlink" title="举例String类"></a>举例String类</h2><h3 id="重载例子"><a href="#重载例子" class="headerlink" title="重载例子"></a>重载例子<span id="overload"></span></h3><p><code>String</code>类的<code>构造器</code>重载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>String</code>类的<code>valueOf()方法</code>的重载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(data);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><hr><h3 id="重写例子"><a href="#重写例子" class="headerlink" title="重写例子"></a>重写例子<span id="override"></span></h3><p><code>ArrayList</code>继承了<code>AbstractList</code>类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div></pre></td></tr></table></figure></p><p><code>AbstractList</code>类中有方法<code>add()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    add(size(), e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>ArrayList</code>类中有重写了<code>add()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>面向对象编程有三大特性：<code>封装</code>、<code>继承</code>、<code>多态</code>。</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p></blockquote><p>实现多态的技术称为：<code>动态绑定（dynamic binding）</code><br>多态存在的三个必要条件</p><pre><code>1. 要有继承；2. 要有重写；3. 父类引用指向子类对象。</code></pre><p>根据<code>何时确定</code>执行多态方法中的哪一个，多态分为两种情况：<code>编译时多态</code>和<code>运行时多态</code>。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。</p><h3 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h3><p><a href="#overload">重载</a>都是<code>编译时多态</code>，从上面的分析可以看到，只要确定了方法参数的<code>数据类型</code>,<code>个数</code>,<code>次序</code>就能确定调用哪一个方法。</p><h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><p><a href="#override">重写</a>有两种多态性，当对象引用<code>本类</code>实例，此时为<code>编译时多态</code>，能在编译期确定调用哪个方法；否则为<code>运行时多态</code>。</p><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Animal"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Dog"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>1.执行下面的main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Animal();</div><div class="line">Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(animal.getName());</div><div class="line">System.out.println(dog.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal</div><div class="line">Dog</div></pre></td></tr></table></figure></p><p><code>Animal</code>和<code>Dog</code>引用的都是<code>本类的实例</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal animal = <span class="keyword">new</span> Animal();</div><div class="line">Dog dog = <span class="keyword">new</span> Dog();</div></pre></td></tr></table></figure></p><p>2.若是这样呢？输入结果是多少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(animal.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dog</div></pre></td></tr></table></figure></p><p>程序在运行时，会从实例<code>所属的类</code>开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照<code>继承关系</code>逐层向上查找，直到超级父类<code>Object类</code>。<br>该例子<code>animal.getName()</code>执行过程是：<br><img src="/2017/11/02/overload-and-override/查找匹配执行方法流程.png" alt="logo"></p><p>3.修改<code>Animal</code>类, 空类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时执行方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(((Dog) animal).getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要显示地转换下<code>((Dog) animal).getName()</code>,因为<code>Animal</code>类中没有定义<code>getName()</code>方法。</p><p>4.修改<code>Animal</code>,<code>Dog</code>类的<code>getName()</code>方法为<code>静态方法</code>,并增加一<code>成员变量name</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> String name = <span class="string">"a"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Animal"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> String name = <span class="string">"d"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Dog"</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>执行main方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">  System.out.println(animal.getName());</div><div class="line">  System.out.println(animal.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal</div><div class="line">a</div></pre></td></tr></table></figure></p><p>结果解释：<br>1.<a href="#override">重写</a>只使用于<code>实例方法</code>，不能用于<code>静态方法</code>，对于<code>static方法</code>，只能<code>隐藏</code>,<a href="#overload">重载</a>,<code>继承</code>；<br>2.在利用引用<code>animal</code>访问对象的属性<code>name</code>或静态方法<code>getName()</code>时，是引用类型决定了实际上访问的是哪个对象（<code>Animal</code>）的成员，而不是当前引用代表的那个类（<code>new Dog()</code>）;<br>由此可知，子类静态方法并<code>不能</code><a href="#override">重写</a>（<code>覆盖</code>）父类的静态方法;故而输出的结果都是父类的成员结果。</p><h2 id="为什么不能根据返回类型来区分重载"><a href="#为什么不能根据返回类型来区分重载" class="headerlink" title="为什么不能根据返回类型来区分重载"></a>为什么不能根据返回类型来区分重载</h2><p>假设下面的重载方法<code>update</code>能编译通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。<br>方法的<code>返回值</code>,只能作为方法运行之后得一个<code>状态</code>，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的<code>标示</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="重载" scheme="http://yoursite.com/tags/%E9%87%8D%E8%BD%BD/"/>
    
      <category term="重写" scheme="http://yoursite.com/tags/%E9%87%8D%E5%86%99/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="编译时多态" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81/"/>
    
      <category term="运行时多态" scheme="http://yoursite.com/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>int和Integer解析</title>
    <link href="http://yoursite.com/2017/11/02/int-and-Integer/"/>
    <id>http://yoursite.com/2017/11/02/int-and-Integer/</id>
    <published>2017-11-02T10:40:58.000Z</published>
    <updated>2017-11-06T15:04:35.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p></blockquote><p>Java 为每个原始类型提供了包装类型：</p><ul><li>原始类型: <code>boolean</code>，<code>char</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code> </li><li>包装类型：<code>Boolean</code>，<code>Character</code>，<code>Byte</code>，<code>Short</code>，<code>Integer</code>，<code>Long</code>，<code>Float</code>，<code>Double</code></li></ul><hr><h3 id="两个常见的面试例子"><a href="#两个常见的面试例子" class="headerlink" title="两个常见的面试例子"></a>两个常见的面试例子</h3><p>先看两个常见的例子，后面会针对例子加以分析。<br><strong><span id="jump_eg1">例1</span></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">        Integer b = <span class="number">8</span>;                  </div><div class="line">        <span class="keyword">int</span> c = <span class="number">8</span>;</div><div class="line">        System.out.println(a == b);     </div><div class="line">        System.out.println(a == c);     </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行结果： false, true</div></pre></td></tr></table></figure><p><strong><span id="jump_eg2">例2</span></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">250</span>, f4 = <span class="number">250</span>;</div><div class="line">      System.out.println(f1 == f2);</div><div class="line">      System.out.println(f3 == f4);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行结果： true, false</div></pre></td></tr></table></figure><hr><h3 id="知识点一：自动拆箱与自动包装"><a href="#知识点一：自动拆箱与自动包装" class="headerlink" title="知识点一：自动拆箱与自动包装"></a><strong>知识点一：自动拆箱与自动包装</strong></h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>1.自动拆箱： 自动将<em>包装器类型</em>转换为<em>基本数据类型</em>；</p><p>2.自动包装： 自动将<em>基本数据类型</em>转换为<em>包装器类型</em>。</p><h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a><strong>具体分析</strong></h4><p><a href="#jump_eg1">例1</a>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;    <span class="comment">//自动装箱</span></div><div class="line"><span class="comment">//Integer a = new Integer(8);</span></div><div class="line"><span class="comment">//int c = 8;</span></div><div class="line">System.out.println(a == c) <span class="comment">// 自动拆箱</span></div></pre></td></tr></table></figure></p><p><strong>注意</strong>：<br>Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是<code>intValue()</code>方法。</p><p>对<a href="#jump_eg1">例1</a>反编译看看(这里用<code>jad</code>来反编译), <code>Test</code>是例子中的类名。<br>下面命令将<strong><code>输出带字节码注释和源码</code></strong> </p><ul><li><code>-a</code>表示<code>用JVM字节格式来注解输出</code>;</li><li><code>-o</code>表示<code>无需确认直接覆盖输出</code>;</li><li><code>-s</code>表示<code>定义输出文件的扩展名</code>,默认的扩展名是<code>jad</code>;</li><li><code>java</code>表示我们想要的反编译后输出<code>java</code>格式文件</li></ul><p><code>jad</code>详细命令参见<a href="http://letus179.com/2017/11/06/jad-cmd-introduce/" target="_blank" rel="external">反编译小工具：jad常用命令介绍</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java Test.class</div></pre></td></tr></table></figure></p><p>反编译结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.PrintStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//    0    0:aload_0         </span></div><div class="line">    <span class="comment">//    1    1:invokespecial   #8   &lt;Method void Object()&gt;</span></div><div class="line">    <span class="comment">//    2    4:return          </span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">    <span class="comment">//    0    0:new             #16  &lt;Class Integer&gt;</span></div><div class="line">    <span class="comment">//    1    3:dup             </span></div><div class="line">    <span class="comment">//    2    4:bipush          8</span></div><div class="line">    <span class="comment">//    3    6:invokespecial   #18  &lt;Method void Integer(int)&gt;</span></div><div class="line">    <span class="comment">//    4    9:astore_1        </span></div><div class="line">    Integer b = Integer.valueOf(<span class="number">8</span>);</div><div class="line">    <span class="comment">//    5   10:bipush          8</span></div><div class="line">    <span class="comment">//    6   12:invokestatic    #21  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">    <span class="comment">//    7   15:astore_2        </span></div><div class="line">    <span class="keyword">int</span> c = <span class="number">8</span>;</div><div class="line">    <span class="comment">//    8   16:bipush          8</span></div><div class="line">    <span class="comment">//    9   18:istore_3        </span></div><div class="line">    System.out.println(a == b);</div><div class="line">    <span class="comment">//   10   19:getstatic       #25  &lt;Field PrintStream System.out&gt;</span></div><div class="line">    <span class="comment">//   11   22:aload_1         </span></div><div class="line">    <span class="comment">//   12   23:aload_2         </span></div><div class="line">    <span class="comment">//   13   24:if_acmpne       31</span></div><div class="line">    <span class="comment">//   14   27:iconst_1        </span></div><div class="line">    <span class="comment">//   15   28:goto            32</span></div><div class="line">    <span class="comment">//   16   31:iconst_0        </span></div><div class="line">    <span class="comment">//   17   32:invokevirtual   #31  &lt;Method void PrintStream.println(boolean)&gt;</span></div><div class="line">    System.out.println(a.intValue() == c);</div><div class="line">    <span class="comment">//   18   35:getstatic       #25  &lt;Field PrintStream System.out&gt;</span></div><div class="line">    <span class="comment">//   19   38:aload_1         </span></div><div class="line">    <span class="comment">//   20   39:invokevirtual   #37  &lt;Method int Integer.intValue()&gt;</span></div><div class="line">    <span class="comment">//   21   42:iload_3         </span></div><div class="line">    <span class="comment">//   22   43:icmpne          50</span></div><div class="line">    <span class="comment">//   23   46:iconst_1        </span></div><div class="line">    <span class="comment">//   24   47:goto            51</span></div><div class="line">    <span class="comment">//   25   50:iconst_0        </span></div><div class="line">    <span class="comment">//   26   51:invokevirtual   #31  &lt;Method void PrintStream.println(boolean)&gt;</span></div><div class="line">    <span class="comment">//   27   54:return          </span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到第<code>20</code>, <code>22</code>行，调用了Integer方法<code>.valueOf(int)</code><strong>自动装箱</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = Integer.valueOf(<span class="number">8</span>);</div></pre></td></tr></table></figure><p><span id="jump_1"></span>第<code>36</code>行,调用了Integer方法<code>.intValue()</code><strong>自动拆箱</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(a == c);</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(a.intValue() == c);</div></pre></td></tr></table></figure><p>所以：<code>a == c</code>的结果为<code>true</code></p><p><a href="#jump_eg1">例1</a>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">Integer b = <span class="number">8</span>;</div><div class="line">System.out.println(a == b);</div></pre></td></tr></table></figure></p><p>结果为何为<code>false</code>？</p><p>刚讲到了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;</div></pre></td></tr></table></figure></p><p>调用了Integer方法<code>.valueOf(int)</code>自动装箱，我们来看下<code>.valueOf(int)</code>源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>也就是说最后会<code>new</code>出来一个Integer对象或者返回<code>缓存</code>中的数据。<br><strong>注意：</strong></p><ul><li><code>==</code>符号在<code>比较对象</code>时，比较的是<code>内存地址</code>;</li><li>对于<code>原始数据类型</code>(如上面<a href="#jump_1"><code>a == c</code></a>)直接比对的是<code>数据值</code>。</li></ul><p>这里又涉及到了<strong><code>堆栈内存</code></strong>了，需要清楚2点：</p><ol><li><code>new</code>出来的对象或创建的<code>数组</code>会在<code>堆</code>中开辟内存空间；</li><li><code>对象的引用</code>（即对象在<code>堆内存</code>中的地址，如<code>a</code>）和<code>基本数据类型</code>存储在<code>栈</code>中；</li></ol><p>由此可知<code>a</code>,<code>b</code>引用指向的对象不是同一个，所以结果是<code>false</code></p><hr><h3 id="知识点二：Integer缓存"><a href="#知识点二：Integer缓存" class="headerlink" title="知识点二：Integer缓存"></a><strong>知识点二：Integer缓存</strong></h3><p>在上面的<code>.valueOf(int)</code>源码中我们能看到<code>IntegerCache</code>类，看名称就知道是和<code>缓存</code>有关。我们来看下<code>Integer</code>类的静态内部类<code>IntegerCache</code>源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// high value may be configured by property</span></div><div class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">        String integerCacheHighPropValue =</div><div class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">            i = Math.max(i, <span class="number">127</span>);</div><div class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        high = h;</div><div class="line"></div><div class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> j = low;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该类中有一个<code>静态数组</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div></pre></td></tr></table></figure></p><p>还有一个<code>静态代码块</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;...&#125;</div></pre></td></tr></table></figure></p><p>既然是在<code>static</code>静态类的<code>静态代码快</code>中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到<code>静态代码快</code>主要是向<code>静态数组</code>中添加了<code>[-128,127]</code>,也就要是说，调用方法<code>.valueOf(int)</code>传入的<code>int</code>值在<code>[-128,127]</code>这个范围内时，直接从<code>IntegerCache</code>的缓存数组中获取， 不会去在堆内存中<code>new</code>。</p><p><code>[-128,127]</code>期间的数字比较常用，这一行为<strong>有助于节省内存、提高性能。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">       <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div></pre></td></tr></table></figure><p>所以在<a href="#jump_eg2">例2</a>中：<br>1.<code>自动装箱</code>调用方法<code>Integer.valueOf(int)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">       Integer f1 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">   <span class="comment">//    0    0:bipush          100</span></div><div class="line">   <span class="comment">//    1    2:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    2    5:astore_1        </span></div><div class="line">       Integer f2 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">   <span class="comment">//    3    6:bipush          100</span></div><div class="line">   <span class="comment">//    4    8:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    5   11:astore_2        </span></div><div class="line">       Integer f3 = Integer.valueOf(<span class="number">250</span>);</div><div class="line">   <span class="comment">//    6   12:sipush          250</span></div><div class="line">   <span class="comment">//    7   15:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    8   18:astore_3        </span></div><div class="line">       Integer f4 = Integer.valueOf(<span class="number">250</span>);</div><div class="line">   <span class="comment">//    9   19:sipush          250</span></div><div class="line">   <span class="comment">//   10   22:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//   11   25:astore          4</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>2.通过<code>Integer.valueOf(int)</code>内部调用<code>IntegerCache</code>类实现。<br>由于<code>f1</code>,<code>f2</code>对应的基本值在<code>[-128,127]</code>之间，结果返回<code>true</code>;<br>而<code>f3</code>,<code>f4</code>对应的基本值不在范围内，结果返回<code>false</code></p><hr><p>其他的包装类型也可以类似分析，回头再总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从J
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="基本数据类型" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="包装类型" scheme="http://yoursite.com/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="自动包装" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%85%E8%A3%85/"/>
    
      <category term="自动拆箱" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
