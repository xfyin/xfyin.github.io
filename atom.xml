<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农的春天还没来</title>
  
  <subtitle>等待 突破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-06T13:15:38.736Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>殷学飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程之设计模式篇</title>
    <link href="http://yoursite.com/2018/02/04/future-Master-Worker/"/>
    <id>http://yoursite.com/2018/02/04/future-Master-Worker/</id>
    <published>2018-02-04T13:13:45.000Z</published>
    <updated>2018-03-06T13:15:38.736Z</updated>
    
    <content type="html"><![CDATA[<p>并行设计模式属于设计优化的一部分，它是对一些常用的多线程结构的总结和抽象。与串行程序相比，并行程序的结构通常更为复杂。因此合理地使用并行模式在多线程开发中更有意义。</p><h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>该模式有点类似于商品订单。比如在网购时，当看中某商品时，就可以提交订单，当订单处理完成后，只需要在家等待商品送货上门即可。又如当我们发送Ajax请求时，页面时异步地进行后台处理，用户无需一直等待请求结果，可以继续浏览或操作其他内容。</p><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><a href="https://pan.baidu.com/s/1mhPW684" target="_blank" rel="external">Future示意图</a></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>链接：<a href="https://pan.baidu.com/s/1mhPW684" target="_blank" rel="external">https://pan.baidu.com/s/1mhPW684</a> 密码：kha7</p><h2 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h2><p>是常用的<strong>并行计算模式</strong>。核心思想是系统由两类进行协作工作：<strong>Master进程和Worker进程</strong>。Master负责<strong>接收和分配</strong>任务，Worker负责<strong>处理子任务</strong>。当各个Worker子进程处理完成后，会将结果返回给Master，由Master做<strong>归纳和总结</strong>。其好处是能将一个大任务分解成若干个小任务，并行执行，从而提高系统的吞吐量。</p><h3 id="示意图-1"><a href="#示意图-1" class="headerlink" title="示意图"></a>示意图</h3><p><a href="https://pan.baidu.com/s/1mhPW684" target="_blank" rel="external">Master-Worker示意图</a></p><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>链接：<a href="https://pan.baidu.com/s/1dFnlAtN" target="_blank" rel="external">https://pan.baidu.com/s/1dFnlAtN</a> 密码：vvx7</p><h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><p>生产者-消费者模式是非常典型的多线程模式，通常由两类线程：若干个生产者的线程和若干个消费者的线程。<strong>生产者线程负责提交用户请求，消费者线程负责具体处理生产者提交的任务，在生产者和消费者之间通过共享内存缓存区进行通信</strong>。</p><h3 id="示意图-2"><a href="#示意图-2" class="headerlink" title="示意图"></a>示意图</h3><p><a href="https://pan.baidu.com/s/1eTurxrs" target="_blank" rel="external">Provider-Customer示意图</a></p><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>链接：<a href="https://pan.baidu.com/s/1eTurxrs" target="_blank" rel="external">https://pan.baidu.com/s/1eTurxrs</a> 密码：ipyh</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;并行设计模式属于设计优化的一部分，它是对一些常用的多线程结构的总结和抽象。与串行程序相比，并行程序的结构通常更为复杂。因此合理地使用并行模式在多线程开发中更有意义。&lt;/p&gt;
&lt;h2 id=&quot;Future模式&quot;&gt;&lt;a href=&quot;#Future模式&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java/"/>
    
    
      <category term="Future" scheme="http://yoursite.com/tags/Future/"/>
    
      <category term="Master-Worker" scheme="http://yoursite.com/tags/Master-Worker/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之队列篇</title>
    <link href="http://yoursite.com/2018/01/28/queue-of-concurrent/"/>
    <id>http://yoursite.com/2018/01/28/queue-of-concurrent/</id>
    <published>2018-01-28T13:09:46.000Z</published>
    <updated>2018-03-06T13:12:51.315Z</updated>
    
    <content type="html"><![CDATA[<p>在并发队列上，JDK提供了继承于<strong>Queue</strong>的两套实现：</p><ul><li><strong>以ConcurrentLinkedQueue为代表的高性能队列</strong>；</li><li><strong>以BlockingQueue接口为代表的阻塞队列</strong>。</li></ul><p>其中<strong>BlockingQueue</strong>接口下的常用实现有：</p><ul><li><strong>ArrayBlockingQueue</strong></li><li><strong>LinkedBlockingQueue</strong></li><li><strong>PriorityBlockingQueue</strong></li><li><strong>DelayQueue</strong></li><li><strong>SynchronousQueue</strong></li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>是一个适用于<strong>高并发</strong>场景下的队列，通过<strong>无锁</strong>的方式实现。实现了高并发状态下的高性能，通常<strong>ConcurrentLinkedQueue</strong>性能好于<strong>BlockingQueue</strong>。它是一个基于链节点的无界线程安全队列。该队列的元素遵循先进先出的原则。头部是最先加入的，尾部是最后加入的。不允许有null元素。</p><p>重要方法：</p><ul><li>add() 和 offer() 都是加入元素的方法，（在ConcurrentLinkedQueue中，这两个方法没有区别）；</li><li>poll() 和 peek() 都是取头元素节点，区别在于前者会删除元素，后者不会。</li></ul><h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>基于数组的<strong>阻塞队列</strong>实现，在<strong>ArrayBlockingQueue</strong>内部，维护了一个定长数组，以便缓存队列中的数据对象，其内部没有实现读写分离，也就意味着生产和消费不能完全并行。长度是需要自定义的，可以指定先进先出或先进后出；也叫<strong>有界队列</strong>。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>基于链表的<strong>阻塞</strong>队列实现，其内部也维持着一个由链表构成的缓冲队列；该队列之所以能高效地处理并发数据，是因为其内部实现采用的是读写分离锁，从而实现生产和消费可以完全并行运行；是<strong>无界队列</strong>。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入的队列对象必须实现Comparable接口），在实现该队列时，内部控制线程同步的锁采用的是公平锁；是一个无界队列；</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>带有延迟时间的队列，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取该元素。该队列中的元素必须实现<strong>Delayed</strong>接口，该队列是一个没有大小限制的队列，应用场景多，譬如：对缓存超时的数据进行移除，任务超时处理，空闲连接的关闭等。现实中例子：如在网吧上网，交多少钱对应上网多少时间，时间到了自动下机。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>是一种没有缓冲的队列，生产者产生的数据会直接被消费者获取并消费。其内部没有空间，若只是<strong>put()</strong>操作，会抛异常“<strong>queue full</strong>”；需要先<strong>take()</strong>阻塞，再<strong>put()</strong>可取，也就是没有经过队列内部。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在并发队列上，JDK提供了继承于&lt;strong&gt;Queue&lt;/strong&gt;的两套实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;以ConcurrentLinkedQueue为代表的高性能队列&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以BlockingQue
      
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java/"/>
    
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="阻塞" scheme="http://yoursite.com/tags/%E9%98%BB%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之容器篇</title>
    <link href="http://yoursite.com/2018/01/20/container-of-concurrent/"/>
    <id>http://yoursite.com/2018/01/20/container-of-concurrent/</id>
    <published>2018-01-20T12:43:13.000Z</published>
    <updated>2018-03-06T13:11:55.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步类容器"><a href="#同步类容器" class="headerlink" title="同步类容器"></a>同步类容器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>同步类容器都是<strong>线程安全</strong>的，但是在某些场景下可能需要通过<strong>加锁</strong>来保护复合操作。那什么是复合类操作呢？诸如：<strong>迭代</strong>（反复访问元素，遍历完容器中所有的元素），<strong>跳转</strong>（根据指定的顺序找到当前元素的下一个元素），以及<strong>条件运算</strong>等。这些复合类操作在多线程并发修改容器时，可能会出现意想不到的情况，如经典的异常类<strong>ConcurrentModificationException</strong>，究其原因，当在容器迭代过程中，被并发地修改了内容，这是由于早期迭代器设计时并没有考虑到并发修改的问题。</p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>诸如<code>Vector</code>，<code>HashTable</code>。这些容器的同步功能中有由JDK的<strong>Collections.synchronizedXX</strong>等工厂方法去创建实现的。其底层的实现机制无非就是利用传统的<strong>synchronized</strong>关键字对每个公用的方法都进行了同步操作，使得每次只能有一个线程访问容器的状态。对于当今互联网高并发的需求显然不能满足，在保证线程安全的同时，也必须要有足够好的性能。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>Vector</code>线程安全操作示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Vector;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickets</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Vector&lt;String&gt; tickets = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</div><div class="line">tickets.add(<span class="string">"火车票"</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span>  Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line"><span class="keyword">if</span> (tickets.isEmpty()) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"---"</span> + tickets.remove(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"线程"</span> + i).start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为什么是线程安全的？我们看看<code>Vector</code>的<strong>remove</strong>操作具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>很显然，这里加了锁<strong>synchronized</strong>，所以是线程安全的。若是将<strong>Vector</strong>换成<strong>ArrayList</strong>，就有有重复数据出现，也说明<strong>ArrayList是线程不安全的</strong>。但是也正是这把锁，每次就1个线程能持有，另外的9个线程必须在外面排队等候，直到前面的线程释放锁。该容器并不能支持并发操作。</p><hr><h2 id="并发类容器"><a href="#并发类容器" class="headerlink" title="并发类容器"></a>并发类容器</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>JDK5.0以后提供了多种并发类容器来替代同步类容器，从而改善性能问题。对于同步类容器，虽然实现了线程安全，但是严重降低了<strong>并发性</strong>，在多线程环境下，严重降低了应用程序的吞吐量。而并发类容器，专门针对并发设计。</p><h3 id="种类-1"><a href="#种类-1" class="headerlink" title="种类"></a>种类</h3><p>我们使用<strong>ConcurrentHashMap</strong>来代替基于散列实现的传统的<strong>HashTable</strong>，而且在<strong>ConcurrentHashMap</strong>中，添加了一些常见复合操作的支持；使用<strong>CopyOnWriteArrayList</strong>代替<strong>Vector</strong>，并发的<strong>CopyOnWriteArraySet</strong>，以及并发的<strong>Queue</strong>，如高性能的队列<strong>ConcurrentLinkedQueue</strong>和以阻塞形式的队列<strong>LinkedBlockingQueue</strong>，还有如<strong>ArrayBlockingQueue</strong>，<strong>PriorityBlockingQueue</strong>，<strong>SynchronousQueue</strong>等等。</p><h4 id="ConcurrentMap容器"><a href="#ConcurrentMap容器" class="headerlink" title="ConcurrentMap容器"></a>ConcurrentMap容器</h4><p>ConcurrentMap接口下有两个重要的实现</p><ul><li>ConcurrentHashMap—类似于 HashMap</li><li>ConcurrentSkipListMap(支持并发排序功能，弥补ConcurrentHashMap)—类似于TreeMap</li></ul><p>ConcurrentHashMap内部使用<strong>段（Segment）</strong>来表示这些不同的部分，每个段其实就是一个小的<strong>HashTable</strong>，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。把一个整体分为<strong>16</strong>个段，也就是最高支持<strong>16</strong>个线程的并发修改操作。这也是在多线程场景时，减小锁的粒度而降低锁竞争的一种方案。并且在代码中大多共享变量使用<strong>volatile</strong>关键字声明，目的是第一时间获取修改的内容，性能非常好。</p><h4 id="Copy-On-Write容器"><a href="#Copy-On-Write容器" class="headerlink" title="Copy-On-Write容器"></a>Copy-On-Write容器</h4><p>简称<strong>COW</strong>，是一种用于程序设计中的优化策略。<br>JDK中COW容器有2种，<strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>。具体什么是COW容器呢？指<strong>写时复制</strong>的容器，也就是写（Write，添加、删除、修改）的时候进行复制（Copy）。通俗的讲，例如当我们往容器中添加元素的时候，不直接往当前容器中添加，而是将当前容器Copy一份，复制出一份新的容器，然后向新的容器中添加元素，添加完元素后，将原来容器的引用指向新的容器。这样做的好处是，<strong>我们可以向CopyOnWrite容器进行并发的读，而不需要加锁</strong>，因为当前容器中不会添加任何新的元素。所有CopyOnWrite容器是一种读写分离的思想，读和写的对象是不同的容器。这类容器适合于<strong>读多写少</strong>的场景，若写操作很多，还不如直接用普通容器加锁。对于该容器，当多个写发生时，为什么不会引起线程安全问题，直接看一个写操作：<strong>add</strong>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Object[] elements = getArray();</div><div class="line">        <span class="keyword">int</span> len = elements.length;</div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        newElements[len] = e;</div><div class="line">        setArray(newElements);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，该操作中用到重入锁<strong>ReentrantLock</strong>，所以说也不会产生线程安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步类容器&quot;&gt;&lt;a href=&quot;#同步类容器&quot; class=&quot;headerlink&quot; title=&quot;同步类容器&quot;&gt;&lt;/a&gt;同步类容器&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java/"/>
    
    
      <category term="同步" scheme="http://yoursite.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之通信篇</title>
    <link href="http://yoursite.com/2018/01/13/communication-of-concurrent/"/>
    <id>http://yoursite.com/2018/01/13/communication-of-concurrent/</id>
    <published>2018-01-13T12:36:57.000Z</published>
    <updated>2018-01-18T12:39:07.142Z</updated>
    
    <content type="html"><![CDATA[<p>源码地址 链接：<a href="https://pan.baidu.com/s/1qXTRFre" target="_blank" rel="external">https://pan.baidu.com/s/1qXTRFre</a> 密码：gky1</p><p>线程是操作系统中独立的个体，若不经过特殊的处理就能不能成为一个整体，而线程间的通信就是成为整体的必要方式之一。<br>使用<strong>wait/notify</strong>方法来实现线程间的通信。<br>需要重点关注2点：</p><ul><li><code>wait/notify</code>必须配合<code>synchronized</code>关键字使用</li><li><code>wait</code>方法释放锁，<code>notify</code>方法不释放锁</li></ul><h2 id="低阶方式实现：while-true"><a href="#低阶方式实现：while-true" class="headerlink" title="低阶方式实现：while(true)"></a>低阶方式实现：while(true)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddListOne</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addList</span><span class="params">()</span> </span>&#123;</div><div class="line">list.add(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> list.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> AddListOne list = <span class="keyword">new</span> AddListOne();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">list.addList();</div><div class="line">System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">"添加了一个元素"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">500</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t1"</span>).start();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line"><span class="keyword">if</span> (list.getSize() == <span class="number">5</span>) &#123;</div><div class="line">System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">"收到了通知，list.size = 5, 本线程终止"</span>);</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t2"</span>).start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个线程共用一个变量<code>list</code>，用了<code>volatile</code>使得变量在线程间可见。一个现在循环10次，向list总增加值，另一个线程while(true)死循环，直到list中有5个值时，抛出异常，终止本线程。执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t2收到了通知，list.size = <span class="number">5</span>, 本线程终止</div><div class="line">Exception in thread <span class="string">"t2"</span> java.lang.RuntimeException</div><div class="line">at thread.AddListOne$<span class="number">2</span>.run(AddListOne.java:<span class="number">43</span>)</div><div class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div></pre></td></tr></table></figure></p><h2 id="中阶方式实现：wait-notify"><a href="#中阶方式实现：wait-notify" class="headerlink" title="中阶方式实现：wait/notify"></a>中阶方式实现：wait/notify</h2><p>由于一直在while(true)死循环，想换种线程间的通信方式，利用<strong>wait/notify</strong>重构代码。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddListTwo</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addList</span><span class="params">()</span> </span>&#123;</div><div class="line">list.add(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> list.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> AddListTwo list = <span class="keyword">new</span> AddListTwo();</div><div class="line"><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">list.addList();</div><div class="line">System.out.println(<span class="string">"当前线程："</span></div><div class="line">+ Thread.currentThread().getName() + <span class="string">"添加了一个元素"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">500</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (list.getSize() == <span class="number">5</span>) &#123;</div><div class="line">System.out.println(<span class="string">"发出通知..."</span>);</div><div class="line">lock.notify();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t1"</span>);</div><div class="line"></div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="keyword">if</span> (list.getSize() != <span class="number">5</span>) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"线程在等待"</span>);</div><div class="line">lock.wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">"收到了通知，list.size = 5, 本线程终止"</span>);</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t2"</span>);</div><div class="line"></div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里制造了一把锁<code>lock</code>，两线程共有这一把对象锁，每次只有一个线程占用。只有一方释放了锁，另一方才能拥有。<br>这里两线程执行的顺序不确定，只有t2线程先执行时，才会有<strong>等待在先，通知在后</strong>；<strong>等待</strong>等着通知来<strong>唤醒</strong>。<br>线程t2中执行<code>wait</code>方法时，阻塞了，并且释放锁，线程t1获得了锁<code>lock</code>， 虽然在list.getSize() = 5 时，发出了通知，但<code>notify</code>方法不释放锁。也就是说线程t1会一直执行下去，知道循环结束，这时候才会唤醒线程t2。执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">t2线程在等待</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">发出通知...</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t2收到了通知，list.size = <span class="number">5</span>, 本线程终止</div><div class="line">Exception in thread <span class="string">"t2"</span> java.lang.RuntimeException</div><div class="line">at thread.AddListTwo$<span class="number">2</span>.run(AddListTwo.java:<span class="number">57</span>)</div><div class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</div></pre></td></tr></table></figure></p><h2 id="高阶方式实现：CountDownLatch"><a href="#高阶方式实现：CountDownLatch" class="headerlink" title="高阶方式实现：CountDownLatch"></a>高阶方式实现：CountDownLatch</h2><p>可以看到这种情况下，虽然t1线程发出了通知，但是t2收到通知的时候，t1线程早就结束了。并<strong>不具备实时性</strong>。为了解决这个问题，在java并发包<code>JUC</code>下，提供了一个工具类<strong>CountDownLatch</strong>，不需要<code>synchronized</code>关键字，能实时实现通知。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddListThree</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addList</span><span class="params">()</span> </span>&#123;</div><div class="line">list.add(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> list.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> AddListThree list = <span class="keyword">new</span> AddListThree();</div><div class="line"><span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">list.addList();</div><div class="line">System.out.println(<span class="string">"当前线程："</span></div><div class="line">+ Thread.currentThread().getName() + <span class="string">"添加了一个元素"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">500</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (list.getSize() == <span class="number">5</span>) &#123;</div><div class="line">System.out.println(<span class="string">"发出通知..."</span>);</div><div class="line">countDownLatch.countDown();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t1"</span>);</div><div class="line"></div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (list.getSize() != <span class="number">5</span>) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">countDownLatch.await();</div><div class="line">System.out.println(Thread.currentThread().getName()</div><div class="line">+ <span class="string">"线程在等待"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"当前线程："</span></div><div class="line">+ Thread.currentThread().getName()</div><div class="line">+ <span class="string">"收到了通知，list.size = 5, 本线程终止"</span>);</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t2"</span>);</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">发出通知...</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">t2线程在等待</div><div class="line">当前线程：t2收到了通知，list.size = <span class="number">5</span>, 本线程终止</div><div class="line">Exception in thread <span class="string">"t2"</span> java.lang.RuntimeException</div><div class="line">at thread.AddListThree$<span class="number">2</span>.run(AddListThree.java:<span class="number">58</span>)</div><div class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div><div class="line">当前线程：t1添加了一个元素</div></pre></td></tr></table></figure></p><p>注意：这里<strong>new CountDownLatch(1)</strong>，这里的参数“<strong>1</strong>”表明发出几次通知，若这里传入<code>2</code>，需要调用<strong>countDownLatch.countDown()</strong>两次发通知才能收到唤醒通知。</p><h2 id="使用wait-notify模拟队列Queue"><a href="#使用wait-notify模拟队列Queue" class="headerlink" title="使用wait/notify模拟队列Queue"></a>使用wait/notify模拟队列Queue</h2><p><strong>BlockintQueue</strong>：顾名思义，首先它就是一个队列，并且支持阻塞的机制，阻塞——放入和获取数据。我们将实现类似<strong>LinkedBlockingQueue</strong>中的<strong>take</strong>和<strong>put</strong>方法。</p><ul><li><strong>take</strong>：取走<strong>BlockingQueue</strong>里排在首位的对象，若<strong>BlockingQueue</strong>为空，阻断获取，直到<strong>BlockingQueue</strong>有新的数据被加入；</li><li><strong>put(anObject)</strong>：把anObeject加到<strong>BlockingQueue</strong>里，如果<strong>BlockingQueue</strong>没有空间，则调用此方法的线程被阻断，直到<strong>BlockingQueue</strong>里面有空间再继续。</li></ul><p>代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// 1. 需要一个承装元素的集合</span></div><div class="line"><span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">// 2. 计数器</span></div><div class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 3. 集合最小数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> minSize = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// 4. 集合最大数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</div><div class="line"></div><div class="line"><span class="comment">// 5. 构造器，初始化集合最大数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.maxSize = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 6. 同一把锁对象</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="comment">// 7. 放入元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="keyword">while</span> (count.get() == <span class="keyword">this</span>.maxSize) &#123;</div><div class="line">System.out.println(<span class="string">"满了，放不下去了..."</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">lock.wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(<span class="string">"加入新元素："</span> + obj);</div><div class="line"><span class="comment">// 加入新元素</span></div><div class="line">list.add(obj);</div><div class="line"><span class="comment">// 计数++</span></div><div class="line">count.incrementAndGet();</div><div class="line"><span class="comment">// put进入后，list空间变大了，若之前take没有元素，这时候take方法收到通知就可以take出元素了</span></div><div class="line">lock.notify();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 8. 取出元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> </span>&#123;</div><div class="line">Object obj = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="keyword">while</span> (count.get() == <span class="keyword">this</span>.minSize) &#123;</div><div class="line">System.out.println(<span class="string">"空了，没有可取的..."</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">lock.wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 移除并获取首位第一个元素</span></div><div class="line">obj = list.removeFirst();</div><div class="line">System.out.println(<span class="string">"获取新元素："</span> + obj);</div><div class="line"><span class="comment">// 计数--</span></div><div class="line">count.decrementAndGet();</div><div class="line"><span class="comment">// take完后，list空间变小了，若之前put不进去，阻塞，这时候put方法收到通知就可以put了</span></div><div class="line">lock.notify();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 9 获取容器的大小</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> count.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> MyQueue mq = <span class="keyword">new</span> MyQueue(<span class="number">5</span>);</div><div class="line">mq.put(<span class="string">"a"</span>);</div><div class="line">mq.put(<span class="string">"b"</span>);</div><div class="line">mq.put(<span class="string">"c"</span>);</div><div class="line">mq.put(<span class="string">"d"</span>);</div><div class="line">mq.put(<span class="string">"e"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"MyQueue容器中有元素:"</span> + mq.getSize() + <span class="string">"个"</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">mq.put(<span class="string">"f"</span>);</div><div class="line">mq.put(<span class="string">"g"</span>);</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t1"</span>).start();</div><div class="line"></div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">mq.take();</div><div class="line">mq.take();</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t2"</span>).start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>main</strong>方法中模拟，先将容器中塞满元素；这时一个线程想加入2个元素但是被阻塞，于是<strong>wait()</strong>，并释放锁；这时候另一个线程获得锁从容器中取出元素，这时候容器有空余位置，并<strong>notify()</strong>，之前的put操作解除阻塞。<br>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">加入新元素：a</div><div class="line">加入新元素：b</div><div class="line">加入新元素：c</div><div class="line">加入新元素：d</div><div class="line">加入新元素：e</div><div class="line">MyQueue容器中有元素:5个 </div><div class="line">满了，放不下去了...</div><div class="line">// 2s后</div><div class="line">获取新元素：a</div><div class="line">获取新元素：b</div><div class="line">加入新元素：f</div><div class="line">加入新元素：g</div></pre></td></tr></table></figure></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><strong>概念</strong>：线程局部变量，是一种多线程间并发访问变量的解决方案。与<strong>synchronized</strong>等加锁的方式不同，<strong>ThreadLocal完全不提供锁</strong>，而是使用<strong>以空间换时间</strong>的手段，为每个线程提供独立变量的独立副本，以保障线程安全。<br>从性能上看，<strong>ThreadLocal</strong>不具有绝对的优势，在并发不是很高的时候，加锁的性能会更好；但作为一套与锁无关的解决方案，在高并发量或者竞争激烈的场景下，使用<strong>ThreadLocal</strong>可以在一定程度上减少锁竞争。<br>代码示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getThreadLocal</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">": "</span></div><div class="line">+ threadLocal.get());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadLocal</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">threadLocal.set(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> MyThreadLocal myloLocal = <span class="keyword">new</span> MyThreadLocal();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">myloLocal.setThreadLocal(<span class="string">"Hello"</span>);</div><div class="line">myloLocal.getThreadLocal();</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t1"</span>).start();</div><div class="line"></div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line">System.out.println(<span class="string">"休眠2s后..."</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">myloLocal.getThreadLocal();</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t2"</span>).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>共用同一个对象<strong>ThreadLocal</strong>，一个线程t1，设置<strong>myloLocal.setThreadLocal(“Hello”)</strong> 并获取<strong>myloLocal.getThreadLocal()</strong>值；在休眠2s后（确保已经先设置值了），另一个线程也去获取值，结果如何？按照一般的思维，两个线程都应该获得值“<strong>Hello</strong>”。（若此处换成List，获取的值一样），执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">t1: Hello</div><div class="line">休眠<span class="number">2</span>s后...</div><div class="line">t2: <span class="keyword">null</span></div></pre></td></tr></table></figure></p><p>线程<code>t2</code>并没有获取到线程<code>t1</code>中设置的值，也就是说<strong>ThreadLocal为每个线程提供独立变量的独立副本</strong>，这样一来就线程安全了。如：在Spring的事务管理中就是利用<strong>ThreadLocal</strong>来解决线程安全问题。</p><h2 id="单例-amp-多线程"><a href="#单例-amp-多线程" class="headerlink" title="单例&amp;多线程"></a>单例&amp;多线程</h2><p>单例模式最常见的就是<strong>懒汉模式</strong>（在调用方法时实例化对象）和<strong>饥汉模式</strong>（直接实例化对象）。在多线程模式下，考虑到<strong>性能</strong>和<strong>线程安全</strong>问题，我们一般选择下面两种比较经典的单例模式，在提高性能的同时，又保证了线程安全。</p><ul><li><strong>static inner class 静态内部类模式</strong></li><li><strong>dubble check instance 双检测模式</strong></li></ul><h3 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton single = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> Singleton.single;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方式实现起来很简单。</p><h3 id="双检测模式"><a href="#双检测模式" class="headerlink" title="双检测模式"></a>双检测模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubbleCheckSingleton</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> DubbleCheckSingleton dcSingleton;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubbleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (dcSingleton == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>); <span class="comment">// 假设在做初始化准备工作</span></div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">synchronized</span> (DubbleCheckSingleton.class) &#123;</div><div class="line"><span class="keyword">if</span> (dcSingleton == <span class="keyword">null</span>) &#123;</div><div class="line">dcSingleton = <span class="keyword">new</span> DubbleCheckSingleton();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> dcSingleton;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(DubbleCheckSingleton.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t1"</span>).start();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(DubbleCheckSingleton.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t2"</span>).start();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(DubbleCheckSingleton.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t3"</span>).start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在第9，17行进行了<strong>两</strong>次 <strong>if (dcSingleton == null)</strong> 判断，也就是所谓的<strong>双重检查</strong>。在<strong>main</strong>方法中开启了<strong>3</strong>个子线程，并在<strong>run</strong>方法中，打印出实例对象的<strong>hashCode()</strong>调用结果。<br>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1460678571</span></div><div class="line"><span class="number">1460678571</span></div><div class="line"><span class="number">1460678571</span></div></pre></td></tr></table></figure></p><p><strong>3</strong>个线程的<strong>hashCode</strong>值是一样的，说明确实是单例。</p><p>为什么要用<strong>双重检查</strong>呢？若在第17行，去掉这层判断，结果会怎样？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (DubbleCheckSingleton.class) &#123;</div><div class="line"><span class="comment">//if (dcSingleton == null) &#123;</span></div><div class="line">dcSingleton = <span class="keyword">new</span> DubbleCheckSingleton();</div><div class="line"><span class="comment">//&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1739173940</span></div><div class="line"><span class="number">566582889</span></div><div class="line"><span class="number">896490263</span></div></pre></td></tr></table></figure></p><p><strong>3</strong>个线程的<strong>hashCode</strong>值是都不一样的，说明不是单例。为什么会这样呢？<br>在第<code>16</code>行之前，有3s的初始化准备工作，3个线程都得到了<strong>dcSingleton == null</strong>，这时候其中一个线程<strong>A</strong>取得了锁，另外两个<strong>B，C</strong>因为锁同步别阻塞在外，假设就在第<code>15</code>行处等着线程<strong>A</strong>锁释放；另外两个线程中的一个<strong>B</strong>获得锁，另一个<strong>C</strong>依旧阻塞在外；这时候<strong>B</strong>因为前面已经获得的<strong>dcSingleton == null</strong>结论，获得锁进入同步块中又一次实例化了对象；同理后面的<strong>C</strong>获得锁后，也实例化了对象。所以这里三个线程实例化了三次，也就产生了3个不同的对象。<br>而如果是<strong>双重检查</strong>，当<strong>B</strong>线程获得锁后，会再次检查<strong>dcSingleton</strong>引用是否为<strong>null</strong>，因为<strong>A</strong>线程已经实例化了一次，这里<strong>dcSingleton</strong>已经不为<strong>null</strong>了，所以不会再次实例化。<strong>3</strong>个线程，最后就产生了<strong>1</strong>个实例，即多线程下实现了<strong>单例模式</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码地址 链接：&lt;a href=&quot;https://pan.baidu.com/s/1qXTRFre&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://pan.baidu.com/s/1qXTRFre&lt;/a&gt; 密码：gky1&lt;/p&gt;
&lt;p&gt;线程是
      
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java/"/>
    
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="wait/notify" scheme="http://yoursite.com/tags/wait-notify/"/>
    
      <category term="CountDownLatch" scheme="http://yoursite.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之基础篇</title>
    <link href="http://yoursite.com/2018/01/07/basic-of-concurrent/"/>
    <id>http://yoursite.com/2018/01/07/basic-of-concurrent/</id>
    <published>2018-01-07T12:58:57.000Z</published>
    <updated>2018-01-07T13:31:28.970Z</updated>
    
    <content type="html"><![CDATA[<p>源码地址：链接：<a href="https://pan.baidu.com/s/1c1MOlXY" target="_blank" rel="external">https://pan.baidu.com/s/1c1MOlXY</a> 密码：qfqi</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>线程安全</strong>：当多个线程访问同一个类（对象或方法）时，这个类始终表现着正确的行为，那么这个类就是线程安全的。<br><strong>synchronized</strong> ： 可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或者“临界区”。<br>自定义线程类有两种方式：实现（implements）Runnable接口，继承（extends）Thread类，下面的代码采用第二种实现方式。</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">count --;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">", count = "</span> + count);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(myThread, <span class="string">"t1"</span>);</div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(myThread, <span class="string">"t2"</span>);</div><div class="line">Thread t3 = <span class="keyword">new</span> Thread(myThread, <span class="string">"t3"</span>);</div><div class="line">Thread t4 = <span class="keyword">new</span> Thread(myThread, <span class="string">"t4"</span>);</div><div class="line">Thread t5 = <span class="keyword">new</span> Thread(myThread, <span class="string">"t5"</span>);</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">t3.start();</div><div class="line">t4.start();</div><div class="line">t5.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建了5个线程（多线程），传入实例<code>myThread</code>（同一个），<code>run</code>方法中每次对成员变量<code>count</code>做减减操作，预期结果<code>count</code>值为：4,3,2,1,0.<br>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t2, count = <span class="number">2</span></div><div class="line">t5, count = <span class="number">0</span></div><div class="line">t3, count = <span class="number">2</span></div><div class="line">t4, count = <span class="number">1</span></div><div class="line">t1, count = <span class="number">2</span></div></pre></td></tr></table></figure></p><p>很明显和预期结果不一致，也就是说<strong>当多个线程访问同一个方法时，这个方法没有表现着正确的行为，也就是说这是非线程安全的</strong>。为了在线程安全的情况下运行，我们给运行的<code>run</code>方法加一把同步锁<code>synchronized</code>，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">count --;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">", count = "</span> + count);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再次运行，结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t1, count = <span class="number">4</span></div><div class="line">t2, count = <span class="number">3</span></div><div class="line">t5, count = <span class="number">2</span></div><div class="line">t4, count = <span class="number">1</span></div><div class="line">t3, count = <span class="number">0</span></div></pre></td></tr></table></figure></p><p>可看到<code>count</code>值确实和预期一致，也就是说<strong>当多个线程访问同一个方法时，这个方法表现出了正确的行为，即是线程安全的。</strong></p><p>观察下发现打印的线程名称顺序和代码编写的顺序（t1 ~ t5）不一致，这是因为：当多线程访问<code>myThread</code>的<code>run</code>方法时，是以排队的方式进行处理（这里的排队指按照CPU分配的先后顺序而定）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当一个线程想要执行<code>synchronized</code>修饰的方法代码时</p><ul><li>首先会去尝试获得这把锁；</li><li>若获取了锁，则执行<code>synchronized</code>修饰的代码体中的内容；若没有获得，这个线程就会不断尝试去获取，直到拿到为止。此代码实例中，有多个线程同时去竞争这把锁。</li></ul><p>这里又涉及到了另一个概念：锁竞争。例如有1000个线程同时尝试获取同一把锁时，CPU为了处理此次程序运行，一下子分配绝大部分内存资源出去，甚至导致死机，这是非常不好的事，所以尽量避免锁竞争问题。</p><hr><h2 id="多个线程多个锁"><a href="#多个线程多个锁" class="headerlink" title="多个线程多个锁"></a>多个线程多个锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>多个线程，每个线程都可以拿到自己指定的锁，分别获得锁后，各自执行<code>synchronized</code>方法体中的内容。</p><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(String tag)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (<span class="string">"a"</span>.equals(tag)) &#123;</div><div class="line">num = <span class="number">100</span>;</div><div class="line">System.out.println(<span class="string">"tag a, set num over!"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">num = <span class="number">200</span>;</div><div class="line">System.out.println(<span class="string">"tag b, set num over!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(<span class="string">"tag "</span> + tag + <span class="string">", num = "</span> + num);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> MultiThread m1 = <span class="keyword">new</span> MultiThread();</div><div class="line"><span class="keyword">final</span> MultiThread m2 = <span class="keyword">new</span> MultiThread();</div><div class="line"></div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">m1.printNum(<span class="string">"a"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">m2.printNum(<span class="string">"b"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在<code>printNum</code>方法上加了关键字<code>synchronized</code>，按照一贯思维，假设先执行<code>t1</code>线程时，拿到了锁，分别打印出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tag a, set num over!</div><div class="line">tag a, num = <span class="number">100</span></div></pre></td></tr></table></figure></p><p>接着打印出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tag b, set num over!</div><div class="line">tag b, num = <span class="number">200</span></div></pre></td></tr></table></figure></p><p>实际运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tag a, set num over!</div><div class="line">tag b, set num over!</div><div class="line">tag b, num = <span class="number">200</span></div><div class="line">tag a, num = <span class="number">100</span></div></pre></td></tr></table></figure></p><p>显然实际结果和预期的不一致。虽然这里都用到了同一个类<code>MultiThread</code>，但是却是两个不同的对象（<code>new</code>）（引用），<code>m1</code>，<code>m2</code>。也就是不同的对象，锁肯定不一样，一个对象只能有一把锁。这里两个线程<code>t1</code>，<code>t2</code>，分别拿到了自己指定的锁，各自执行<code>printNum</code>方法中的代码逻辑，互不影响。</p><p>那么问题来了，这种情况下，要想只有一个线程执行<code>printNum</code>方法，另一个线程等前面的线程释放锁后再执行方法，那么该怎么做呢？其实很简单，只需要让<code>printNum</code>方法变成静态方法就行，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里也需要变成static变量，因为在静态方法printNum中只能访问静态成员变量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(String tag)</span> </span>&#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>静态方法上加锁就是类级别的锁了，类锁只有一把，所以是线程安全的。<br>关于静态static相关的描述请参见：<a href="http://letus179.com/2017/11/06/static-and-non-static/" target="_blank" rel="external">静态static与非静态non-static(变量、方法、内部类)解析</a><br>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tag a, set num over!</div><div class="line">tag a, num = <span class="number">100</span></div><div class="line">tag b, set num over!</div><div class="line">tag b, num = <span class="number">200</span></div></pre></td></tr></table></figure></p><p>可以看出，<code>printNum</code>方法确实被锁住了。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>关键字<code>synchronized</code>取得的锁都是<strong>对象锁</strong>，而不是把一段代码（方法）当做是锁，在实例代码中哪个线程先执行<code>synchronized</code>关键字修饰的方法，那个线程就持有该方法所属对象的锁。两个对象，线程获得的就是两个不同的锁，他们互不影响。<br>有一种情况，相同的锁，也就是上面所看到的，在静态方法上加关键字<code>synchronized</code>上锁，表示锁定的是<strong>类.class</strong>，即类级别的锁，独占锁。</p><hr><h2 id="对象锁的同步和异步"><a href="#对象锁的同步和异步" class="headerlink" title="对象锁的同步和异步"></a>对象锁的同步和异步</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>同步：synchronized，同步的意思就是<strong>共享</strong>，如果不是共享的资源，也就是大家都需要的，就没有必要进行同步；<br>异步：asynchronized，异步的意思就是<strong>独立</strong>，相互之间不受任何约束。<br>同步的目的就是为了线程安全。</p><h3 id="代码实例-2"><a href="#代码实例-2" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"method1 "</span> + Thread.currentThread().getName());</div><div class="line">Thread.sleep(<span class="number">5000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"method2 "</span> + Thread.currentThread().getName());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> MyObject mo = <span class="keyword">new</span> MyObject();</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">mo.method1();</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t1"</span>);</div><div class="line"></div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">mo.method2();</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"t2"</span>);</div><div class="line"></div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>method1</code>方法枷锁，且打印线程名称后，休眠5s。<code>method2</code>方法不加锁，不休眠。在主方法<code>main</code>中，实例化<code>MyObject</code>类，并起了两个线程，分别调用<code>MyObject</code>类中的<code>method1</code>，<code>method2</code>方法。执行结果，几乎同时打印：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">method1 t1</div><div class="line">method2 t2</div></pre></td></tr></table></figure></p><p>也就是说，方法<code>method1</code>，<code>method2</code>的执行事<strong>相互之间不受任何约束</strong>，是<strong>异步</strong>行为。</p><p>若修改下方法<code>method2</code>，也加上锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"method2 "</span> + Thread.currentThread().getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>关于执行结果，会有这样的情形：</p><ul><li>先打印<code>method1 t1</code>，5s后，打印<code>method2 t2</code>;</li><li>或者先打印<code>method1 t2</code>，紧接着打印<code>method1 t1</code>，5s后程序终止;</li></ul><p>方法<code>method1</code>，<code>method2</code>上面的锁是<strong>对象锁</strong>，对象锁只要一把，在上面执行情形1中，方法<code>method1</code>先取得了锁，方法<code>method2</code>就在排队等候，直到<code>method1</code>执行完毕。两个方法都需要共享这把锁，这就产生了同步行为。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>A线程先持有object对象的锁，B线程如果这这个时候调用对象中的同步（synchronized）方法则需要等待，也就是同步；<br>A线程先持有object对象的锁，B线程可以以异步（asynchronized）的方式调用对象中的非synchronized修饰的方法。</p><hr><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>对于对象的同步和异步方法，我们在设计程序时，一定要考虑问题的整体性，不然就会出现数据不一致的错误，脏读就是这种情况之一。</p><h3 id="代码实例-3"><a href="#代码实例-3" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirtyRead</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> String name = <span class="string">"Hello"</span>;</div><div class="line"><span class="keyword">private</span> String password = <span class="string">"123"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, String password)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">2000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.password = password;</div><div class="line">System.out.println(<span class="string">"the result of setValue [name:"</span> + name + <span class="string">", password:"</span> + password + <span class="string">"]"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"the result of getValue [name:"</span> + name + <span class="string">", password:"</span> + password + <span class="string">"]"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="keyword">final</span> DirtyRead dr = <span class="keyword">new</span> DirtyRead();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">dr.setValue(<span class="string">"World"</span>, <span class="string">"456"</span>);</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line"></div><div class="line">dr.getValue();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里实例了一次，设值和取值都用到了同一个引用<code>dr</code>，设值时在主线程<code>main</code>线程中开启了子线程。<br>我们想要先处理下<code>name</code>，<code>password</code>的值，再获取处理后的值，也就是得到<code>name:World, password:456</code>，执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">the result of getValue [name:World, password:<span class="number">123</span>]</div><div class="line">the result of setValue [name:World, password:<span class="number">456</span>]</div></pre></td></tr></table></figure></p><p>程序获取值为：<code>name:World, password:123</code>，也就是没能保证<code>name</code>和<code>password</code>的一致性，这也就产生了<strong>脏读</strong>。我们应该使得设置值（<code>setValue</code>）和获取值（<code>getValue</code>）操作的整体性，这时候可以为两个方法都加上同步锁<code>synchronized</code>，由于公用同一把对象锁，也就抱着了原子性。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>在我们对一个对象的方法加锁时，需要考虑业务的整体性，即为<code>setValue/getValue</code>方法同时加锁<code>synchronized</code>，保证业务的原子性，不然会出现业务错误。</p><hr><h2 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h2><p>关键字<code>synchronized</code>拥有锁重入的功能，也就是说使用<code>synchronized</code>时，当一个线程得到一个对象锁后，<strong>*再次</strong>请求此对象时是可以再次得到该对象的锁的。</p><h3 id="代码实例-4"><a href="#代码实例-4" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAgain</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"method1 called..."</span>);</div><div class="line">method2();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"method2 called..."</span>);</div><div class="line">method3();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"method3 called..."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> SyncAgain sa = <span class="keyword">new</span> SyncAgain();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">sa.method1();</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>方法<code>method1</code>，<code>method2</code>，<code>metho13</code>，均用关键字<code>synchronized</code>修饰，三个方法都拥有同一把对象锁；</li><li><code>method1</code>中调用<code>method2</code>，<code>method2</code>中调用<code>method3</code>。现在开启线程，调用<code>method1</code>。</li></ul><p>我们按照正常逻辑思考：<code>method1</code>获得了对象锁，在方法体内调用<code>method2</code>，将要执行<code>method2</code>中的代码逻辑，此时由于<code>method1</code>并没有释放锁（<code>method1</code>方法还没有执行完），因此<code>method2</code>方法得不到锁。看似很矛盾，根本执行不下去。看看执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">method1 called...</div><div class="line">method2 called...</div><div class="line">method3 called...</div></pre></td></tr></table></figure></p><p>三个方法都执行了，并没有出现冲突。这就是前面说的<strong>锁重入</strong>问题，也就<strong>再次请求此对象时是可以再次得到该对象的锁的</strong>。</p><hr><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>作用：<strong>使变量在多个线程间可见</strong></p><h3 id="代码实例-5"><a href="#代码实例-5" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileVsibility</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> isRunning)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.isRunning = isRunning;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"run called..."</span>);</div><div class="line"><span class="keyword">while</span>(isRunning) &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"线程结束"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">VolatileVsibility vt = <span class="keyword">new</span> VolatileVsibility();</div><div class="line">vt.start();</div><div class="line">Thread.sleep(<span class="number">2000</span>);</div><div class="line">vt.setRunning(<span class="keyword">false</span>);</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">System.out.println(<span class="string">"now the value of isRunning is "</span> + vt.isRunning);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在主线程<code>main</code>中起了子线程<code>vt</code>，子线程<code>run</code>方法中有个<code>while</code>循环，直到<code>while(false)</code>才会退出<code>run</code>方法，并打印“<code>线程结束</code>”字样。在主线程中，启动子线程后，2s后，修改了成员变量<code>isRunning</code>的值为<code>false</code>，正好符合子线程结束的条件。看看执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">run called...</div><div class="line">now the value of isRunning is <span class="keyword">false</span></div></pre></td></tr></table></figure></p><p>可以看到控制台只打印了一句日志，且控制台上的<code>Terminate</code>指示灯一直亮着，说明程序没结束，一致在<code>while(true)</code>，但是日志表明确实<code>isRunning</code>的值已经由<code>true</code>改变为<code>false</code>。<br>也就是说变量<code>isRunning</code>主线程和子线程中并没有表现一致性，两个线程中不可见。这里有个示意图：<br><img src="/2018/01/07/basic-of-concurrent/multhread_var.png" alt="volatile-to-multhread"><br>为了让变量<code>isRunning</code>在两个线程中可见，保持一致性，只需要用<code>volatile</code>关键字修饰该变量即可，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p><p>再次执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">run called...</div><div class="line">线程结束</div><div class="line">now the value of isRunning is <span class="keyword">false</span></div></pre></td></tr></table></figure></p><p>也就是说，变量被<code>volatile</code>关键字修饰时，当变量值改变时会强制线程执行引擎去主内存中重新去读取值，再次拷贝副本到子线程中的主内存区域。</p><h3 id="不具备原子性"><a href="#不具备原子性" class="headerlink" title="不具备原子性"></a>不具备原子性</h3><p><code>volatile</code>关键字具有一致性，但是不具备原子性。</p><h3 id="代码实例1"><a href="#代码实例1" class="headerlink" title="代码实例1"></a>代码实例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileNoAtomic</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>;i++) &#123;</div><div class="line">count ++;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"count = "</span> + count);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">VolatileNoAtomic[] vna = <span class="keyword">new</span> VolatileNoAtomic[<span class="number">10</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">vna[i] = <span class="keyword">new</span> VolatileNoAtomic();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">vna[i].start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>成员变量<code>count</code>用了<code>static</code>也就是静态的，属于类，即不会因为每次<code>new VolatileNoAtomic()</code>而将变量值初始化为0，<code>volatile</code>使得多线程之间变量可见。执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">count = <span class="number">3574</span></div><div class="line">count = <span class="number">4000</span></div><div class="line">count = <span class="number">5000</span></div><div class="line">count = <span class="number">4000</span></div><div class="line">count = <span class="number">3583</span></div><div class="line">count = <span class="number">6753</span></div><div class="line">count = <span class="number">6753</span></div><div class="line">count = <span class="number">8499</span></div><div class="line">count = <span class="number">9441</span></div><div class="line">count = <span class="number">9441</span></div></pre></td></tr></table></figure></p><p>因为在执行打印时，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"count = "</span> + count);</div></pre></td></tr></table></figure></p><p>下一个线程会对<code>count</code>变量操作，所以过程中的值不会是整千，但是执行的最大的那个值应该是1000*10 = 10000。目前看来并不是，也就是说<code>volatile</code>关键字并不能保证原子性。此时可以用另一种方式来保证原子性。</p><h3 id="代码实例2"><a href="#代码实例2" class="headerlink" title="代码实例2"></a>代码实例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileNoAtomic</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//private static volatile int count = 0;</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>;i++) &#123;</div><div class="line"><span class="comment">// count ++;</span></div><div class="line">count.incrementAndGet();</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"count = "</span> + count);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">VolatileNoAtomic[] vna = <span class="keyword">new</span> VolatileNoAtomic[<span class="number">10</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">vna[i] = <span class="keyword">new</span> VolatileNoAtomic();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">vna[i].start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">count = <span class="number">7861</span></div><div class="line">count = <span class="number">8146</span></div><div class="line">count = <span class="number">8461</span></div><div class="line">count = <span class="number">8853</span></div><div class="line">count = <span class="number">8568</span></div><div class="line">count = <span class="number">9344</span></div><div class="line">count = <span class="number">9819</span></div><div class="line">count = <span class="number">9910</span></div><div class="line">count = <span class="number">9888</span></div><div class="line">count = <span class="number">10000</span></div></pre></td></tr></table></figure></p><p>不管执行多少次，最大的数确实是10000，也就证明了<code>AtomicInteger</code>类在多线程下能保证原子性。原子性操作：多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。该类来自<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div></pre></td></tr></table></figure></p><p><code>JUC</code>包，包括并发应用程序的锁、互斥、队列、线程池、轻量级任务、有效的并发集合、原子的算术操作和其它基本构件。很重要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码地址：链接：&lt;a href=&quot;https://pan.baidu.com/s/1c1MOlXY&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://pan.baidu.com/s/1c1MOlXY&lt;/a&gt; 密码：qfqi&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java/"/>
    
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="锁重入" scheme="http://yoursite.com/tags/%E9%94%81%E9%87%8D%E5%85%A5/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析以及常见问题</title>
    <link href="http://yoursite.com/2017/12/31/source-code-of-hashmap/"/>
    <id>http://yoursite.com/2017/12/31/source-code-of-hashmap/</id>
    <published>2017-12-31T08:57:25.000Z</published>
    <updated>2017-12-31T09:06:19.719Z</updated>
    
    <content type="html"><![CDATA[<p>2017年最后一篇博客，加油！</p><h2 id="HashMap基本用法"><a href="#HashMap基本用法" class="headerlink" title="HashMap基本用法"></a>HashMap基本用法</h2><p>通过HashMap与Hashtable比较：</p><ul><li>HashMap能接受为<strong>null</strong>的键和值，Hashtable键和值都不能为<strong>null</strong>（通过put方法跟踪源码就一目了然）；</li><li>HashMap是<strong>非synchronized</strong>的，所以快，Hashtable是<strong>synchronized</strong>，相对慢（源码）；</li><li>HashMap <strong>数组+链表</strong> 的存储结构，存储<strong>键值对</strong>；而一般的集合List、Set则是存储<strong>单个对象</strong>。</li></ul><hr><h2 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h2><p>HashMap是基于<strong>hashing</strong>的原理，我们在使用<strong>put(key,value)</strong>存储对象到HashMap中，使用<strong>get(key)</strong>从HashMap中获取对象；当我们给put()方法传递键和值时，我们先对<strong>键</strong>调用<strong>hashCode()</strong>方法，返回的<strong>hashCode</strong>用于找到<strong>bucket</strong>的位置来存储<strong>Entry</strong>对象。我们来看看这句话涉及的源码，首先从<strong>put(key, value)</strong>方法开始。</p><h3 id="put-方法源码实现"><a href="#put-方法源码实现" class="headerlink" title="put()方法源码实现"></a>put()方法源码实现</h3><p>HashMap存储结构在外层是<strong>数组</strong>，在源码中有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure></p><p>在下面的put方法中，第2~4行，若是第一次操作HashMap，这里table必然是空的，需要去初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">        inflateTable(threshold);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在第5行，<strong>key</strong>为<strong>null</strong>时，并没有抛出异常，说明HashMap中<strong>允许键为null值</strong>的。<br>在第7行，调用了<strong>hash</strong>方法，<strong>键</strong>作为参数传入。</p><p>这里看看hash()方法具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hashSeed;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于hashCode()，它是一个<strong>本地方法</strong>，实质就是<strong>地址取样运算</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p><p>该方法第7行，调用了<strong>key的hashCode()方法</strong>，并通过一系列<strong>位运算</strong>，获取最后的<strong>hash</strong>值。<br>反观HashTable中put()方法中调用的hash()方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="comment">// hashSeed will be zero if alternative hashing is disabled.</span></div><div class="line">    <span class="keyword">return</span> hashSeed ^ k.hashCode();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HashMap在HashTable的基础上做了优化，我们继续HashMap的put()方法的源码研究。<br>在第8行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</div></pre></td></tr></table></figure></p><p><strong>通过返回的hash值找到（table中）bucket的位置来存储Entry对</strong>象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns index for hash code h.    </span></div><div class="line"><span class="comment"> * 返回hashCode在table中的下标，以便存储Entry对象</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在第9~17行，在判断value值是不是在HashMap中已经存在，存在的话就返回旧值。<br>在第20行，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addEntry(hash, key, value, i);</div></pre></td></tr></table></figure></p><p>看方法名就知道，这里就是真正将键值对添加到HashMap中的方法。传入四个参数：<strong>hash值，key-value，以及该Entry对象存储的位置</strong>。看看具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果HashMap的大小（size）超过了<strong>阀值（threshold）</strong>并且该Entry对象存储的位置被占用了，这时候就需要“<strong>扩容</strong>”了。也就是所谓的<strong>rehash</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resize(<span class="number">2</span> * table.length)</div></pre></td></tr></table></figure></p><p>将HashMap的大小扩充为原来大小的<strong>两倍</strong>，并且重新计算该Entry对象存储的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">    Entry[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">        threshold = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</div><div class="line">    table = newTable;</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过<strong>resize()方法</strong>，我们可以看到在第9，10行，重新创建了容量是原来两倍大小的新Entry数组，并且在方法<strong>transfer()</strong>中会把原来Entry对象中的数据迁移到新的Entry中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Transfers all entries from current table to newTable. </span></div><div class="line"><span class="comment"> * 把所有的Entry对象从当前table（旧）转义到刚创建的table（新）中</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">            e.next = newTable[i];</div><div class="line">            newTable[i] = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这一过程还是相当耗时的。<br>在addEntry方法中的第8行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">createEntry(hash, key, value, bucketIndex);</div></pre></td></tr></table></figure></p><p>创建具体的Entry对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Creates new entry.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">    value = v;</div><div class="line">    next = n;</div><div class="line">    key = k;</div><div class="line">    hash = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里很清晰了，根据之前计算的Entry对象的位置和键值对，创建了Entry对象。这里需要注意这行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Entry&lt;K,V&gt; e = table[bucketIndex];</div></pre></td></tr></table></figure></p><p>计算出来的该key在bucket中的下标bucketIndex，返回该下标在数组中存储的对象，然后通过Entry构造器，在新Entry对象中，最为next存储。这里就利用到了<strong>链表</strong>结构。后面会详细讲到，这就是整个put()方法的调用过程。</p><h3 id="get-方法源码实现"><a href="#get-方法源码实现" class="headerlink" title="get()方法源码实现"></a>get()方法源码实现</h3><p>关于通过键获取值的get(key)方法，我们需要了解其中的<strong>碰撞探测以及碰撞的解决办法</strong>。首先看看get()方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>key为null值这里就不看了，逻辑很简单。<br>在第4行，这里通过key获取到了Entry对象。我们看看<strong>getEntry()</strong>的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>;  e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在第6行，这里调用的<strong>key的hash方法，计算key的hashCode值</strong>。<br>在第7行，通过返回的<strong>hashCode值获取该key在bucket中的index（下标，索引）</strong>，并返回该key对应的Entry对象在数组中的存在。<br>在9行<code>if</code>语句中，<strong>首先判断计算的hash值和该Entry对象创建时存储的key的hash值是否相等</strong>，一般人会认为两个key比较时，只要hash值相等，这个key就相等，其实这是不对的，这里就涉及到了<strong>碰撞探测</strong>。换句话说，这里用到了HashMap的存储结构–<strong>数组+链表</strong>。<br>首先是<strong>数组</strong>，我们上面的代码中计算hashCode值在bucket中的位置，这个bucket就是数组（table）；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure></p><p>若有两个key对象的hash值相同的话，也就是说两个值对象存储在同一个bucket中，这时候怎么获取值对象（value）？继续看第9行后面的部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))</div></pre></td></tr></table></figure></p><p>首先用的运算符<strong>&amp;&amp;</strong>，也就是说光传入key的hash和存储在Entry中的hash值相等还不行，后面部分运算结果也得是<strong>true</strong>。后面<strong>“||”</strong>左面部分为<strong>true</strong>的条件是，该传入的key和获取的Entry对象中的key是同一个，这样肯定能精确获得想要的值对象（hash值相同，key也相同）；<strong>“||”</strong>右面部分调用的<strong>key的equals()方法</strong>，返回结果为<strong>true</strong>，当然是同一个key，也就是说左右部分的运算都是为了找到<strong>同一个key</strong>。那么具体在同一个bucket中怎么同时存两个或多个hash值相同的不同key对象的呢？明白了怎么存的也就清楚了怎么取了。我们先回到：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// put() ==&gt; addEntry() ==&gt; createEntry()</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>若前面已经通过put(key, value)形式存储的一个Entry对象，这里又来了一个key1，通过计算key和key1拥有相同的hashCode值，也即在bucket中的位置是一致的，即bucketIndex相同。<br>在第3行中，首先就是通过下标取出数组中的Entry对象；<br>在第4行中，新建了一个Entry对象，将新的key，value，计算的hash值以及上一个相同hash值的Entry对象一起保存在该新Entry对象中，然后在相同的bucket位置返回新的Entry对象，旧的Entry对象被挂起了；后来再来一个不同的key2，若计算得出的hash值也相同，刚新建的Entry对象也将变成后来这个新Entry对象的next被挂起。这样就是<strong>链表</strong>的形式存储了具有相同hash值的不同的key对象。<br>所以说，HashMap就是通过<strong>数组+链表</strong>的形式实现的。这里说到了怎么<strong>存</strong>具有相同hash值的不同key对象，<strong>取</strong>呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// get() ==&gt;　getEntry()</span></div><div class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">    ....</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>首先这里用到了for循环遍历，其实也说明了“<strong>数不止一个</strong>” 。在循环时用到了 <strong>e = e.next</strong> ，这里正是遍历<strong>挂起的Entry对象</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    <span class="keyword">int</span> hash;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Creates new entry.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">        value = v;</div><div class="line">        next = n;</div><div class="line">        key = k;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上就是HashMap中最重要的存取方法：<strong>put(key,value)，get(key)</strong>源码解析过程。了解了这些，下面常见的问题也很容易回答。</p><hr><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p><strong>当两个不同的键对象的hashCode相同时会发生什么？</strong><br>它们会存储在同一个bucket位置的HashMap.Entry组成的链表中。</p></li><li><p><strong>若两个键的hashCode值相同，你如何正确取出值对象的？</strong><br>当我们调用get(key)方法时，会先计算key的hashCode值，通过该值找到key在bucket（数组）中的位置，找到bucket位置后，循环遍历（next），并调用keys.equals()方法找到链表中正确的节点。</p></li><li><p><strong>什么是hash，什么是碰撞？</strong><br>hash：是一种信息摘要算法，它还叫做哈希，或者散列。我们平时使用的MD5就属于Hash算法，通过输入key进行Hash计算，就可以获取key的HashCode()，比如我们通过校验MD5来验证文件的完整性。<br>碰撞：好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞;<br>就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。</p></li><li><p><strong>如何减少碰撞？</strong><br>使用不可变的，声明做final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生（若has不同对象的hashCode值都不相同，自然就不需要链表来存储了），提高效率。不可变性使得能够缓存不同键的hashCode，这将提高整个获取对象的速度（不需要遍历，速度当然就快了），使用String，Integer这样的wrapper类作为键是非常好的选择。</p></li><li><p><strong>为什么String, Interger这样的wrapper类适合作为键？</strong><br>因为String是不可变的，是final的，已经重写了hashCode()和equals()方法，其他的Wrapper类也有类似的特点。不可变性是必要的，因为为了要计算hashCode值，就要防止键值改变，如果键值在put和get时，返回了不同的hash值，也就不能正确的从HashMap中获取想要的对象了；如果可以仅仅通过将某个对象声明成final就能保证hashCode是不变的，就可以这么处理。因为获取对象时，需要调用hashCode()和equals()方法，对键值对象正确重写这两个方法时非常重要的。如果两个不相等的键值对象返回不同的hash值，那么碰撞的几率会小很多，这样较少了不必要的对链表的操作，就能提高HashMap的性能。</p></li><li><p><strong>可以使用自定义的对象作为键吗？</strong><br>当然可以，只要其遵守equals()方法和hashCode()方法规则，当键值对象插入HashMap中不会再改变就可以。</p></li><li><p><strong>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>默认的负载因子是0.75，也就是说，当一个HashMap中填满了75%的bucket时，将会创建原来<strong>两倍</strong>大小的新bucket数组，并将原来的对象迁移到新创建的bucket中。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div></pre></td></tr></table></figure></li><li><p><strong>重新调整HashMap大小存在什么问题吗？</strong><br>由于HashMap是非线程安全的，在多线程环境下，会产生条件竞争。因为若两个线程都发现需要调整HashMap时，都会尝试去调整。我们看下扩容的源码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// put() ==&gt; addEntry() ==&gt; resize(2 * table.length) ==&gt; transfer</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">            e.next = newTable[i];</div><div class="line">            newTable[i] = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 假设有两个不同的key：<strong>A，B</strong>对应了同一个<strong>hash</strong>值，假设当前bucket中存储最上面的是<strong>A，A.next = B</strong>。那么从上面的源码可以看到，当前是 <strong>A = e</strong>，<strong>e.next</strong>就是<strong>B</strong>，<br> 第11行，先将<strong>e.next（B）</strong>处“清空”，因为<strong>newTable[i]</strong>目前只是空位置；<br> 第12行，将<strong>A</strong>放入新<strong>bucket</strong>位置；<br> 第13行，将当前对象<strong>e</strong>对象设置成<strong>B</strong>，继续<strong>while</strong>循环。<br> 在<strong>B</strong>的循环中，<strong>B.next</strong> 为<strong>null</strong>，<br> 第11行，此处<strong>newTable[i]</strong>是前面的<strong>A</strong>，这里赋值给了当前对象<strong>e(B)</strong>的<strong>next</strong>对象；<br> 第12行，将<strong>B</strong>对象存储在该<strong>bucket</strong>位置；<br> 第13行，<strong>next</strong>为<strong>null</strong>赋值给当前<strong>e</strong>，<strong>while</strong>循环为<strong>false</strong>，结束循环。<br> 也就是说新的bucket中存储的最上面的是<strong>B，B.next = A</strong>，整个链表反过来了。这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。<strong>所以在多线程环境下，不能使用HashMap。</strong></p></li><li><p><strong>能否让HashMap同步？</strong><br>HashMap可以通过下面的手段实现同步：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.synchronizedMap(hashMap);</div></pre></td></tr></table></figure></li><li><p><strong>如何提升HashMap的性能？</strong><br>解决扩容损失：如果知道大致需要的容量，把初始容量设置好以解决扩容损失；<br>比如我现在有1000个数据，需要 1000/0.75 = 1333，又 1024 &lt; 1333 &lt; 2048，所以最好使用2048作为初始容量。<br><strong>2048 = roundUpToPowerOf2(1333)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">        inflateTable(threshold);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</div><div class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></div><div class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></div><div class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</div><div class="line">            ? MAXIMUM_CAPACITY</div><div class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年最后一篇博客，加油！&lt;/p&gt;
&lt;h2 id=&quot;HashMap基本用法&quot;&gt;&lt;a href=&quot;#HashMap基本用法&quot; class=&quot;headerlink&quot; title=&quot;HashMap基本用法&quot;&gt;&lt;/a&gt;HashMap基本用法&lt;/h2&gt;&lt;p&gt;通过HashMap与H
      
    
    </summary>
    
      <category term="源码" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/java/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Maven搭建SpringMVC项目</title>
    <link href="http://yoursite.com/2017/12/23/maven-and-springmvc/"/>
    <id>http://yoursite.com/2017/12/23/maven-and-springmvc/</id>
    <published>2017-12-23T13:58:37.000Z</published>
    <updated>2017-12-24T08:10:27.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个Maven-Project"><a href="#创建一个Maven-Project" class="headerlink" title="创建一个Maven Project"></a>创建一个Maven Project</h2><p><code>右键</code> -&gt; <code>New</code> -&gt; <code>Other...</code> -&gt; 搜索‘<code>maven</code>’ -&gt; 选择‘<code>Maven Project</code>’ -&gt; <code>Next</code></p><p><img src="/2017/12/23/maven-and-springmvc/1.png" alt="maven-to-springmvc"></p><h2 id="创建一个简单项目"><a href="#创建一个简单项目" class="headerlink" title="创建一个简单项目"></a>创建一个简单项目</h2><p>勾选：<code>Create a simple project</code>（自动创建约定的项目目录结构，即不使用骨架）-&gt; <code>Next</code></p><p><img src="/2017/12/23/maven-and-springmvc/2.png" alt="maven-to-springmvc"></p><h2 id="确定唯一标示"><a href="#确定唯一标示" class="headerlink" title="确定唯一标示"></a>确定唯一标示</h2><p>填写如截图中的内容 -&gt; <code>Nex</code> -&gt; <code>Finish</code></p><ul><li>Group id: 组织id，域名倒写；</li><li>Artifact id：项目、模块id；</li><li>Version： 版本；</li><li>Packaging: 该元素决定了项目的打包方式，有3种，jar，war，pom（比如是一个父模块）；<br>Maven为jar项目调用了maven-jar-plugin，为war项目调用了maven-war-plugin，换言之，packaging直接影响Maven的构建生命周期</li></ul><p><img src="/2017/12/23/maven-and-springmvc/3.png" alt="maven-to-springmvc"></p><p>由于packing是war包，那么下面也就多出了webapp的目录</p><p><img src="/2017/12/23/maven-and-springmvc/3.1.png" alt="maven-to-springmvc"></p><h2 id="转换为dynamic-web-project"><a href="#转换为dynamic-web-project" class="headerlink" title="转换为dynamic web project"></a>转换为dynamic web project</h2><p>由于我们的项目要使用eclipse发布到tomcat下面，这里我们需要先把项目转成 <code>dynamic web project</code>。<br>在我们的项目上点击 <code>右键</code>，选择 <code>Properties</code> 并找到 <code>Project Facets</code> ，并点击<code>Convert to faceted form...</code>  </p><p><img src="/2017/12/23/maven-and-springmvc/4.png" alt="maven-to-springmvc"></p><p>将maven项目转换为Dynamic Web项目，勾选 <code>Dynamic Web Module</code>， 并点击 <code>Further configuration available...</code> </p><p><img src="/2017/12/23/maven-and-springmvc/4.1.png" alt="maven-to-springmvc"></p><p>勾选生成web项目需要的部署描述符文件 <code>web.xml</code>， 然后点击 <code>OK</code> -&gt; <code>OK</code></p><p><img src="/2017/12/23/maven-and-springmvc/4.2.png" alt="maven-to-springmvc"></p><p>接下来观察我们的项目结构，多了一个WebContent目录</p><p><img src="/2017/12/23/maven-and-springmvc/4.3.png" alt="maven-to-springmvc"></p><blockquote><p>META-INF<br>相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。<br>MANIFEST.MF文件，在用jar打包时自动生成。</p></blockquote><h2 id="转为标准的Maven项目结构"><a href="#转为标准的Maven项目结构" class="headerlink" title="转为标准的Maven项目结构"></a>转为标准的Maven项目结构</h2><p>虽然此时我们可以发布到tomcat中，但这不符合maven的结构，“<strong>约定优于配置</strong>”，转为标准的maven项目结构。<br>我们还要做如下修改：<br>把上图 <code>WebContent</code> 下面两个目录 <code>META-INF，WEB-INF</code> 直接剪切到 <code>src/main/webapp</code> 目录下，并删掉 <code>WebContent</code> 目录，那么现在的项目结构如下图：</p><p><img src="/2017/12/23/maven-and-springmvc/5.png" alt="maven-to-springmvc"></p><h2 id="修改发布规则"><a href="#修改发布规则" class="headerlink" title="修改发布规则"></a>修改发布规则</h2><p>需要修改发布规则，右键点击项目，选择 <code>Properties</code> ， 选择 <code>Deployment Assembly</code></p><p><img src="/2017/12/23/maven-and-springmvc/6.png" alt="maven-to-springmvc"></p><ul><li>选择 <code>WebContent</code>，把它 <code>Remove</code> </li><li>测试类我们也不需要发布，    <code>test</code> 的两个目录页可以 <code>Remove</code></li></ul><p>因为是基于Maven项目，需要把Maven依赖库也添加到发布路径，点击 <code>Add</code> ， 选择 <code>Java Build Path Entries</code>, <code>Next</code>，选择 <code>Maven Dependencies</code>， <code>Finish</code>， <code>OK</code></p><p><img src="/2017/12/23/maven-and-springmvc/6.1.png" alt="maven-to-springmvc"><br><img src="/2017/12/23/maven-and-springmvc/6.2.png" alt="maven-to-springmvc"></p><p>此处列表是，部署项目时，文件发布的路径</p><p><img src="/2017/12/23/maven-and-springmvc/6.3.png" alt="maven-to-springmvc"></p><p>至此一个基于maven的webapp就建立好了，并可以直接从eclipse中发布到tomcat中。</p><h2 id="导入我们的Spring-MVC依赖jar包"><a href="#导入我们的Spring-MVC依赖jar包" class="headerlink" title="导入我们的Spring MVC依赖jar包"></a>导入我们的Spring MVC依赖jar包</h2><p>在 <code>pom.xml</code> 文件中写入下面的依赖，maven会自动为我们下载需要依赖的jar包，<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!-- 集中定义依赖版本号 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.1.3.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">jsp-api.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">jsp-api.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">commons-io.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">commons-io.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">commons-net.version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">commons-net.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Spring --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- JSP相关 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jstl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jsp-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Apache工具组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-io.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-net<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-net<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-net.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p><p>此时工程目录下多了 <code>Maven Dependencies</code> 库</p><p><img src="/2017/12/23/maven-and-springmvc/7.png" alt="maven-to-springmvc"></p><p>在上面的步骤中，我们在 pom.xml 文件中加入了好多东西，简单说说。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 集中定义依赖版本号 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.1.3.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">jsp-api.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">jsp-api.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">commons-io.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">commons-io.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">commons-net.version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">commons-net.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在大型项目或者比较复杂的项目，例如聚合项目中，为了统一规定版本号，可以在父类工程中集中定义依赖版本号，这样在子类工程中就不许要考虑版本号问题了。<br>从这里也可以看出该文件中有3大类依赖，spring，jsp以及工具类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Spring --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>在 <code>&lt;properties&gt;</code> 节点中集中定义了依赖版本号后，具体的依赖中就可以如上面直接用花括号的形式引用版本号了，当然要是再父类工程定义了版本号，子类想要用父类定义好的版本号，需要引入父类工程，如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springmvc-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div></pre></td></tr></table></figure></p><p>后面的 <code>build</code> 节点中集成了Tomcat7 插件，这样在运行项目时，只需要 项目右键 -&gt; <code>Run as</code> -&gt; <code>Run Configurations...</code>， 在 <code>Goals</code> 中填入 <code>tomcat7:run</code> 就可以自动部署项目到tomcat下运行了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure></p><p>根据部署描述符(web.xml)中的默认欢迎页面，我们在webapp下新建一个 <code>index.jsp</code> 页面<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p><p><img src="/2017/12/23/maven-and-springmvc/8.png" alt="maven-to-springmvc"><br>项目右键 -&gt; <code>Run as</code> -&gt; <code>Run Configurations...</code>， 在 <code>Goals</code> 中填入 <code>tomcat7:run</code>，单击 <code>Run</code>，项目运行。<br><img src="/2017/12/23/maven-and-springmvc/8.1.png" alt="maven-to-springmvc"><br>控制台中会输出下面的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[INFO] Running war on http:<span class="comment">//localhost:8081/</span></div><div class="line">[INFO] Creating Tomcat server configuration at D:\workspace_springmvc\springmvc\target\tomcat</div><div class="line">[INFO] create webapp with contextPath:</div></pre></td></tr></table></figure></p><p>在浏览器中输入 <code>http://localhost:8081</code>，回车</p><p><img src="/2017/12/23/maven-and-springmvc/8.2.png" alt="maven-to-springmvc"></p><p>自此，基于maven搭建的web项目能正常访问了。<br>我们再看下项目结构，多了个 <code>target</code> 文件夹，这个是哪来的？</p><p><img src="/2017/12/23/maven-and-springmvc/8.3.png" alt="maven-to-springmvc"></p><p>如图可知，java编译后的字节码文件就存在 <code>target/classes</code> 下</p><p><img src="/2017/12/23/maven-and-springmvc/8.4.png" alt="maven-to-springmvc"></p><p>下一步，就是集成SpringMVC。</p><h2 id="集成SpringMVC"><a href="#集成SpringMVC" class="headerlink" title="集成SpringMVC"></a>集成SpringMVC</h2><p>我们在</p><ul><li>在<code>src/main/java</code> 下新建包：控制层（mvc.controller），业务逻辑层（mvc.service），数据访问层（mvc.dao），还有实体层（mvc.entity）；</li><li>在<code>src/main/resources</code>下新建spingmvc所需要的配置文件<code>/mvc/config/springmvc.xml</code>；</li><li>在<code>WEB-INF</code>下新建文件夹: css，js，jsp，用于存放资源文件和页面等</li><li><p>在部署描述符（web.xml）中，我们加入如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:mvc/config/springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 拦截所有的请求，包括WEB-INF下资源文件请求 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>在新建的 <code>springmvc.xml</code> 文件中，我们需要加入下面的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></div><div class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></div><div class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></div><div class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></div><div class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd</span></span></div><div class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- spring基于扫描机制找到应用程序中所有基于注解的控制器类和业务逻辑层 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"mvc.controller"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"mvc.service"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 由于在`web.xml`中，会拦截所有的请求'/'，包括 `WEB-INF`下的资源文件：css，js等，而在`WEB-INF` 下的文件又不能直接访问，这里需要特殊处理下--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/css/"</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/js/"</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span></span></div><div class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></li></ul><p>下面是一系列源码，很简单，就不解说了，文章最后附有完整的项目工程。<br>实体类 <code>Book.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1520961851058396786L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="keyword">private</span> String isbn;</div><div class="line">    <span class="keyword">private</span> String title;</div><div class="line">    <span class="keyword">private</span> Category category;</div><div class="line">    <span class="keyword">private</span> String author;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">long</span> id, String isbn, String title, </span></span></div><div class="line"><span class="function"><span class="params">            Category category, String author)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.isbn = isbn;</div><div class="line">        <span class="keyword">this</span>.title = title;</div><div class="line">        <span class="keyword">this</span>.category = category;</div><div class="line">        <span class="keyword">this</span>.author = author;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实体类 <code>Category.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5658716793957904104L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Category</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Category</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">// getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里忽略数据访问层DAO<br>业务逻辑层接口类 <code>BookService.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function">List&lt;Category&gt; <span class="title">getAllCategories</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Category <span class="title">getCategory</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</div><div class="line">    <span class="function">List&lt;Book&gt; <span class="title">getAllBooks</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Book <span class="title">save</span><span class="params">(Book book)</span></span>;</div><div class="line">    <span class="function">Book <span class="title">update</span><span class="params">(Book book)</span></span>;</div><div class="line">    <span class="function">Book <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNextId</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>业务逻辑层接口实现类 <code>BookServiceImpl.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * this implementation is not thread-safe</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;Category&gt; categories;</div><div class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookServiceImpl</span><span class="params">()</span> </span>&#123;</div><div class="line">        categories = <span class="keyword">new</span> ArrayList&lt;Category&gt;();</div><div class="line">        Category category1 = <span class="keyword">new</span> Category(<span class="number">1</span>, <span class="string">"Computing"</span>);</div><div class="line">        Category category2 = <span class="keyword">new</span> Category(<span class="number">2</span>, <span class="string">"Travel"</span>);</div><div class="line">        Category category3 = <span class="keyword">new</span> Category(<span class="number">3</span>, <span class="string">"Health"</span>);</div><div class="line">        categories.add(category1);</div><div class="line">        categories.add(category2);</div><div class="line">        categories.add(category3);</div><div class="line">        </div><div class="line">        books = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</div><div class="line">        books.add(<span class="keyword">new</span> Book(<span class="number">1L</span>, <span class="string">"9780980839623"</span>, </div><div class="line">                <span class="string">"Servlet &amp; JSP: A Tutorial"</span>, </div><div class="line">                category1, <span class="string">"Budi Kurniawan"</span>));</div><div class="line">        books.add(<span class="keyword">new</span> Book(<span class="number">2L</span>, <span class="string">"9780980839630"</span>,</div><div class="line">                <span class="string">"C#: A Beginner's Tutorial"</span>,</div><div class="line">                category1, <span class="string">"Jayden Ky"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getAllBooks</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> books;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后控制层类 <code>BookController.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> BookService bookService;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(BookController.class);</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/book_list"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">listBooks</span><span class="params">(Model model)</span> </span>&#123;</div><div class="line">        logger.info(<span class="string">"book_list"</span>);</div><div class="line">        List&lt;Book&gt; books = bookService.getAllBooks();</div><div class="line">        model.addAttribute(<span class="string">"books"</span>, books);</div><div class="line">        <span class="keyword">return</span> <span class="string">"BookList"</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>页面 <code>BookList.jsp</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></div><div class="line">pageEncoding=<span class="string">"UTF-8"</span>%&gt;</div><div class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span>%&gt;</div><div class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</div><div class="line">&lt;title&gt;Book List&lt;/title&gt;</div><div class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</div><div class="line"><span class="meta">@IMPORT</span> url(<span class="string">"./css/main.css"</span>);</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=<span class="string">"global"</span>&gt;</div><div class="line">&lt;h1&gt;Book List&lt;/h1&gt;</div><div class="line">&lt;a href="&lt;c:url value='/book_input'/&gt;"&gt;Add Book&lt;/a&gt;</div><div class="line">&lt;table&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;th&gt;Category&lt;/th&gt;</div><div class="line">&lt;th&gt;Title&lt;/th&gt;</div><div class="line">&lt;th&gt;ISBN&lt;/th&gt;</div><div class="line">&lt;th&gt;Author&lt;/th&gt;</div><div class="line">&lt;th&gt;&amp;nbsp;&lt;/th&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;c:forEach items=<span class="string">"$&#123;books&#125;"</span> var=<span class="string">"book"</span>&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;$&#123;book.category.name&#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;book.title &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;book.isbn &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;book.author &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;&lt;a href="book_edit/$&#123;book.id &#125;"&gt;Edit&lt;/a&gt;&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;/c:forEach&gt;</div><div class="line">&lt;/table&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>由于我在pom.xml 文件中配置的 项目访问路径是 “/”，所以直接在浏览器中输入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//localhost:8081/book_list</span></div></pre></td></tr></table></figure></p><p><img src="/2017/12/23/maven-and-springmvc/9.png" alt="maven-to-springmvc"></p><p>自此，用Maven搭建SpringMVC项目就讲完了，还有很多细节需要处理，需要不断学习。</p><p>完整工程下载链接：<a href="https://pan.baidu.com/s/1hrQdCwc" target="_blank" rel="external">https://pan.baidu.com/s/1hrQdCwc</a> 密码：kifh</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建一个Maven-Project&quot;&gt;&lt;a href=&quot;#创建一个Maven-Project&quot; class=&quot;headerlink&quot; title=&quot;创建一个Maven Project&quot;&gt;&lt;/a&gt;创建一个Maven Project&lt;/h2&gt;&lt;p&gt;&lt;code&gt;右键&lt;/
      
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/spring/java/"/>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门介绍</title>
    <link href="http://yoursite.com/2017/12/16/Introduction-to-Maven/"/>
    <id>http://yoursite.com/2017/12/16/Introduction-to-Maven/</id>
    <published>2017-12-16T13:11:21.000Z</published>
    <updated>2017-12-24T08:36:55.010Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="项目依赖管理"><a href="#项目依赖管理" class="headerlink" title="项目依赖管理"></a>项目依赖管理</h2><p>在项目合作开的时，我们是<strong>如何进行项目依赖管理</strong>的呢？<br>我们通常会在新建项目的时候，同时建立一个<code>lib</code>目录，在其中放着<code>项目所依赖的各方类库</code>，这样提交到<code>SVN</code>之后， 每个开发人员检出项目到本地，得到项目的<code>工作副本</code>，这样所有开发人员就会持有统一的项目依赖了。这样有<code>2个</code>比较明显的问题。</p><h3 id="管理中的问题"><a href="#管理中的问题" class="headerlink" title="管理中的问题"></a>管理中的问题</h3><h4 id="依赖冗余"><a href="#依赖冗余" class="headerlink" title="依赖冗余"></a>依赖冗余</h4><p>随着项目的增多，模块的增多，这种方式就会有问题。很多模块都会引用相同的依赖，当每个模块都把自己的依赖提交到SVN，那么相同的依赖就会占用服务器SVN的Repository很大的空间，造成<code>空间浪费</code>。</p><h4 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h4><p>同时，如果一个项目中依赖的版本和另一个项目依赖的版本不一致。比如这个项目依赖hibernate2.x，而另一个可能依赖hibernate3.x， 当合并两个项目发布的时候， 可能因为这种依赖类库详细<code>版本信息的缺失</code>，造成问题。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>为了解决以上依赖管理过程中出现的问题以及我们项目中遇到的其他类似问题， 我们寻求出一途径：各个项目只要通过<code>统一的依赖描述文件</code>（<code>pom.xml</code>）来指定自己需要的依赖就可以， 而不用自己来管理真正的依赖库，因为所有的项目都使用<code>同一个中央依赖库</code>(<code>中央仓库</code>)， 所以即使各个项目中有<code>相同的依赖</code>， 也不会出现依赖冗余的问题。<strong><code>Maven</code></strong>正是我们寻求的，能解决此问题的工具。</p><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>Maven</code>是基于<code>POM</code>(project object model，即<code>项目对象模型</code>)的<code>跨平台</code>的项目管理工具，主要服务于基于JAVA平台的<strong>项目构建</strong>，<strong>依赖管理</strong>和<strong>项目信息管理</strong>。</p><ul><li>项目构建<br><code>清理</code>、<code>编译</code>、<code>测试</code>、<code>报告</code>、<code>打包</code>、<code>部署</code>；</li><li>依赖管理<br><code>自动下载</code>，<code>统一依赖管理</code>；</li><li>信息管理<br><code>项目名称描述</code>，<code>开发人员信息</code>，<code>开发者信息</code>。</li></ul><p>PS: <code>测试报告</code>存放在<code>target</code>文件夹下。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>如果没有Maven，你可能不得不经历下面的过程：</p><ul><li>使用jar包时，需要去官网下载，譬如：如果使用了spring，去spring的官网下载jar包；</li><li>当某些jar包有依赖的时候，还要去下载对应的依赖jar包；</li><li>当jar包依赖有冲突时，不得不一个一个的排查；</li><li>执行构建时，需要使用ant写出很多重复的任务代码；</li><li>当新人加入开发时，需要拷贝大量的jar包，然后重复进行构建。</li></ul><p>而maven的优势就是：</p><ul><li>项目jar包的依赖管理：仅仅通过jar包的几个属性，就能确定唯一的jar包，在指定的文件pom.xml中，只要写入这些依赖属性，就会自动下载并管理jar包；</li><li>项目自动化编译部署：清理—&gt;编译—&gt;测试—&gt;打包—&gt;部署；</li><li>项目的插件管理。</li></ul><h2 id="Maven的配置文件"><a href="#Maven的配置文件" class="headerlink" title="Maven的配置文件"></a>Maven的配置文件</h2><p>如果使用过Ant都知道Ant是通过build.xml执行构建任务的，Maven中是通过<code>pom.xml</code>来执行任务.<br>POM，project object model，即项目对象模型，它通过这个pom.xml <em>描述一个项目的构建以及信息</em>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> </span></div><div class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0  http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h3c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mavenLearning<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p><p>第一行指定了文档的<code>XML版本</code>和<code>编码</code>;<br>第二行即每个pom.xml的核心元素——<code>project</code>;<br>project下面有几个子元素，这几个子元素一般是每个项目都会使用到的：</p><ul><li><code>modelVersion</code>这个元素指定了<code>POM的版本</code>（Maven2或者Maven3 都只能是4.0.0）；</li><li><code>groupId</code> 是<code>项目组的ID</code>，一般是com.公司组织名.项目名；</li><li><code>artifactId</code> 是该项目在<code>项目组中ID</code>，比如当前的项目是项目组的一个服务链项目，就可以叫做serviceChain；</li><li><code>version</code> 是<code>项目的版本号</code>，用于维护项目的升级和发布；</li><li><code>name</code> 一般没有实际的用处，只是用于<code>标识</code>该项目；</li><li><code>packaging</code>项目<code>打包方式</code>，常有<code>jar</code>，<code>war</code>，<code>pom</code>等，缺省下为jar<br>比较重要的参数是 <code>groupId</code>、<code>artifactId</code>、<code>version</code>，这三个属性确定<code>唯一</code>的一个项目。</li></ul><h2 id="Maven如何管理jar包"><a href="#Maven如何管理jar包" class="headerlink" title="Maven如何管理jar包"></a>Maven如何管理jar包</h2><h3 id="Jar包坐标"><a href="#Jar包坐标" class="headerlink" title="Jar包坐标"></a>Jar包坐标</h3><p>关于jar包的坐标，maven是通过groupId，artifactId，以及version确定一个唯一的jar包。<br>例如，最常使用的<code>Junit</code>的声明就是如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;4.12&lt;/version&gt;</div><div class="line">  &lt;scope&gt;test&lt;/scope&gt; </div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p><p><code>&lt;scope&gt;</code>这是声明的范围，不同的生命周期所要求的范围是不一样的。</p><h3 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h3><p>在Maven中会涉及到几种仓库：</p><ol><li><code>工作空间</code>，即我们的项目工程，这里面放着pom.xml文件，这个pom.xml就是maven的配置文件；</li><li><code>本地仓库</code>，本地仓库用于存放jar包，其实Jar包并不是直接放入工作空间的，它是存放在本地仓库，然后在执行发布打包的时候，添加依赖路径；</li><li><code>私库</code>：私库是使用者自己搭建的maven仓库，用于缓解频繁从外网下载jar包资源的压力。而且使用私库作为缓存层，也相对安全一些；</li><li><code>共享仓库</code>：一般所说的中央仓库或者一些常用的镜像网站都属于这种，国内比较著名的oschina以及163都是不错的maven仓库。</li></ol><h3 id="Maven下载jar包的过程"><a href="#Maven下载jar包的过程" class="headerlink" title="Maven下载jar包的过程"></a>Maven下载jar包的过程</h3><p><img src="/2017/12/16/Introduction-to-Maven/repository_of_maven.jpg" alt="Maven下载jar包的过程"><br>当我们在pom中声明了依赖关系后，参考上面的图：</p><ol><li>Maven在执行相关的任务时，会先去本地仓库查看是否有该资源，如果有的话，判断版本是否正确，如果一切都没问题则直接使用；否则，执行下一步；</li><li>Maven会去配置的共享仓库中查找，如果找到就拷贝到本地仓库中；找不到则会给出相关的提示；</li><li>Maven在本地如果搭建了私库，则会去私库中查找，找到就拷贝到本地仓库；找不到就会去共享仓库中查找，然后放入私库和本地库。有了私库，局域网内的开发者可以共享依赖，就不用每个人都去外网下载jar包，浪费带宽了。</li></ol><h3 id="Maven的目录结构介绍"><a href="#Maven的目录结构介绍" class="headerlink" title="Maven的目录结构介绍"></a>Maven的目录结构介绍</h3><p><img src="/2017/12/16/Introduction-to-Maven/structure_of_maven.png" alt="structure_of_maven"></p><p><code>bin</code>：该目录下同JDK一样，主要是Maven的运行脚本，这些脚本用来配置Java命令，准备好classpath和相关Java系统属性，然后执行Java命令。mvn.bat是基于Windows的脚本。在CMD中每次输入一条MVN的命令都是在调用并执行这些脚本。该目录还有一个文件名为m2.conf，它是classworlds的配置文件。<br><code>boot</code>：该目录只有一个文件plexus-classworlds-2.5.1.jar。他是一个类加载器的框架，相对于JDK中的类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架架在自己的类库。<br><code>conf</code>：该目录包含了一个非常重要的文件setting.xml。配置该文件就能在Project中定制Maven的行为。<br><code>lib</code>：包含了所有Maven运行时需要的Java类库以及用到的第三方以来。<br><code>LICENSE</code>：记录了Maven的软件许可证。<br><code>NOTICE.txt</code>：记录了Maven所包含的第三方软件。<br><code>README.txt</code>：包含了Maven的简介以及简要指令等.</p><h4 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h4><p>我们没有搭建私服（私库），Maven工程需要的jar包需要联网下载，在<code>setting.xml</code>配置文件中配置代理，即可下载需要的jar包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;proxies&gt;</div><div class="line">    &lt;proxy&gt;</div><div class="line">      &lt;id&gt;optional&lt;/id&gt;</div><div class="line">      &lt;active&gt;true&lt;/active&gt;</div><div class="line">      &lt;protocol&gt;http&lt;/protocol&gt;</div><div class="line">      &lt;username&gt;xxxx&lt;/username&gt;</div><div class="line">      &lt;password&gt;xxxx&lt;/password&gt;</div><div class="line">      &lt;host&gt;xxx&lt;/host&gt;</div><div class="line">      &lt;port&gt;xxx&lt;/port&gt;</div><div class="line">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</div><div class="line">    &lt;/proxy&gt;</div><div class="line">&lt;/proxies&gt;</div></pre></td></tr></table></figure></p><p>在<code>&lt;settings&gt;</code>标签中添加如上代码，说明如下：</p><ol><li><code>proxies</code>中可以配置多个proxy，但是默认第一个proxy生效。</li><li><code>active</code>中的TRUE表示该代理目前生效状态。</li><li>http协议、主机地址、端口不在赘述。</li><li>用户名密码按需配置即可。</li><li><code>nonProxyHost</code>表示不需要代理访问的地址。中间的竖线分隔多个地址，此处可以使用星号作为通配符号。</li></ol><h4 id="本地仓库配置"><a href="#本地仓库配置" class="headerlink" title="本地仓库配置"></a>本地仓库配置</h4><p><code>本地仓库</code>，顾名思义，就是Maven在本地存储构件的地方。<br>注：maven的本地仓库，在安装maven后并不会创建，它是在第一次执行maven命令的时候才被创建<br>maven本地仓库的默认位置：无论是Windows还是Linux，在用户的目录下都有一个<code>.m2/repository/</code>的仓库目录，这就是Maven仓库的默认位置<br>如何更改maven默认的本地仓库的位置：这里要引入一个新的元素：<code>localRepository</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;localRepository&gt;E:\MAVEN&lt;/localRepository&gt;</div></pre></td></tr></table></figure></p><h4 id="远程仓库配置"><a href="#远程仓库配置" class="headerlink" title="远程仓库配置"></a>远程仓库配置</h4><p>远程仓库中最核心的<code>中央仓库</code>（还有私服和其它公共库），中央仓库是默认的远程仓库，maven在安装的时候，自带的就是中央仓库的配置。所有的maven项目都会继承超级pom，具体的说，包含了下面配置的pom我们就称之为<code>超级pom</code>。<br>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;repositories&gt;  </div><div class="line">    &lt;repository&gt;  </div><div class="line">        &lt;id&gt;central&lt;/id&gt;  </div><div class="line">        &lt;name&gt;Central Repository&lt;/name&gt;  </div><div class="line">        &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt;  </div><div class="line">        &lt;layout&gt;default&lt;/layout&gt;  </div><div class="line">        &lt;snapshots&gt;  </div><div class="line">            &lt;enabled&gt;false&lt;/enabled&gt;  </div><div class="line">        &lt;/snapshots&gt;  </div><div class="line">    &lt;/repository&gt;  </div><div class="line">&lt;/repositories&gt;</div></pre></td></tr></table></figure></p><hr><h2 id="Maven的生命周期及阶段"><a href="#Maven的生命周期及阶段" class="headerlink" title="Maven的生命周期及阶段"></a>Maven的生命周期及阶段</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Maven中有<code>三大生命周期</code>，他们相互独立，分别是：</p><ul><li><code>clean</code> 清理；</li><li><code>default</code> 构建；</li><li><code>site</code> 建站；</li></ul><p>一般来说，<code>clean</code>和<code>default</code>比较常用。</p><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p>每个生命周期又有不同的阶段，阶段按顺序执行，并且可以指定执行结束的阶段。构建的时候，会<em>依次从最上面的阶段执行到指定的那个阶段</em>。<br>比如，clean有3个阶段：</p><ul><li><code>pre-clean</code> 执行清理前要完成的工作</li><li><code>clean</code> 清理上一次构建生成的文件</li><li><code>post-clean</code> 执行清理后需要完成的工作</li></ul><p>当我们输入<code>mvn clean</code>的时候，执行的是<code>pre-clean</code>和<code>clean</code>两个阶段。</p><p>default的阶段比较多：</p><ol><li>validate</li><li>initialize</li><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources</li><li>compile</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile</li><li>process-test-classes</li><li>tet</li><li>prepare-package</li><li>package</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li><li>install</li><li>deploy</li></ol><p>看名字大概就能理解，当执行<code>mvn install</code>的时候，实际会执行<code>validate</code> -&gt; <code>initialize</code> -&gt;… -&gt; <code>verify</code>-&gt; <code>install</code>等二十几个阶段。<br>为了操作方便，不同的生命周期可以在一起执行，比如<code>mvn clean install</code>，会<code>先</code>执行<code>clean</code>的阶段，<code>再</code>执行<code>install</code>的阶段。<br>在<code>IDE</code>开发环境中，当我们<code>Run as</code>的时候，就可以执行<code>maven clean</code>进行清理，或者执行<code>maven install</code>进行构建，也可以执行<code>maven build</code><strong>同时执行</strong><code>clean</code>和<code>install</code>两个任务.</p><hr><h2 id="Maven工程结构介绍"><a href="#Maven工程结构介绍" class="headerlink" title="Maven工程结构介绍"></a>Maven工程结构介绍</h2><p>一般的<code>Maven</code>项目会包含这样一个<code>目录树</code>：</p><blockquote><p>project<br>|-src–main–java–你的源代码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–main–resource：资源文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–test–java–单元测试代码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–test– resource–单元测试代码相关资源文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–target–编译出的文件和jar包<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–pom.xml–项目信息以及任务定义</p></blockquote><p><strong>“约定优于配置（Convention over Configuration）”</strong>，maven提供了<code>约定</code>的项目的目录结构，<code>自动创建</code>项目目录，提高开发效率。</p><hr><h2 id="Maven-集成Tomcat7插件"><a href="#Maven-集成Tomcat7插件" class="headerlink" title="Maven 集成Tomcat7插件"></a>Maven 集成Tomcat7插件</h2><p>Maven Tomcat插件现在主要有两个版本，<code>tomcat-maven-plugin</code>和<code>tomcat7-maven-plugin</code>，使用方式基本相同。<br>在pom.xml中加入节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">&lt;plugins&gt;</div><div class="line">&lt;plugin&gt;</div><div class="line">               &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</div><div class="line">               &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</div><div class="line">               &lt;version&gt;2.1&lt;/version&gt;</div><div class="line">               &lt;configuration&gt;</div><div class="line">                   &lt;port&gt;9090&lt;/port&gt;</div><div class="line">                   &lt;path&gt;/mavenLearningTest&lt;/path&gt;</div><div class="line">                   &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;</div><div class="line">                   &lt;server&gt;tomcat7&lt;/server&gt;</div><div class="line">               &lt;/configuration&gt;</div><div class="line">           &lt;/plugin&gt;</div><div class="line">&lt;/plugins&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></p><ul><li><code>path</code>  是访问应用的路径。</li><li><code>port</code>  是<code>tomcat的端口号</code>（一般在<code>tomcat—conf-- server.xml</code>中修改）。</li><li><code>uriEncoding</code>  <code>URL</code>按<code>UTF-8</code>进行编码，这样就解决了<code>中文参数乱码</code>。</li><li><code>Server</code> 指定<code>tomcat名称</code>。</li></ul><p>选择<code>pom.xml</code>文件，击右键——&gt;选择 <code>Run As</code>——&gt; <code>Maven build</code>，在<code>Goals</code>中填写：<code>tomcat7:run</code><br>（若填的是<code>tomcat:run</code>,默认调用的是<code>tomcat-maven-plugin</code>，此时<code>pom</code>配置文件中也得修改）</p><p>几个常用的<code>Goal</code></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>tomcat7:deploy</td><td>部署一个web war包</td></tr><tr><td>tomcat7:reload</td><td>重新加载web war包</td></tr><tr><td>tomcat7:start</td><td>启动tomcat</td></tr><tr><td>tomcat7:stop</td><td>停止tomcat</td></tr><tr><td>tomcat7:undeploy</td><td>停止一个war包</td></tr><tr><td>tomcat7:run</td><td>启动嵌入式tomcat ，并运行当前项目</td></tr></tbody></table><hr><p>下一篇中将介绍下<strong><a href="http://letus179.com/2017/12/16/maven-and-springmvc" target="_blank" rel="external">如何使用Maven搭建SpringMVC项目</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;项目依赖管理&quot;&gt;&lt;a href=&quot;#项目依赖管理&quot; class=&quot;headerlink&quot; title=&quot;项目依赖管理&quot;&gt;&lt;/a&gt;项目依赖管理&lt;/h2&gt;&lt;p&gt;在项目合作开的时，我们是&lt;strong&gt;如何进行项目依赖管理&lt;/strong&gt;的呢？&lt;br&gt;我们通
      
    
    </summary>
    
      <category term="项目构建" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/java/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
      <category term="依赖" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC基本介绍</title>
    <link href="http://yoursite.com/2017/12/12/introduction-to-springmvc/"/>
    <id>http://yoursite.com/2017/12/12/introduction-to-springmvc/</id>
    <published>2017-12-12T15:32:23.000Z</published>
    <updated>2017-12-12T15:34:50.822Z</updated>
    
    <content type="html"><![CDATA[<p>对SpringMVC的了解来自实际项目以及在项目过程遇到问题是，查找相关资料，并没有系统地学习这些。很多会用，但是不太清楚具体原理，最新重新学习SpringMVC，开头一章系统的介绍，让我有所顿悟。对于这些知识的学习，让我对SpringMVC基本配置认识更加深刻，特此将重要的知识点摘录下来。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><hr><p>有两个组件A和B，A依赖于B。现在假定A是一个类，且A有方法methodA()，该方法中获取B，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</div><div class="line">B b = ...<span class="comment">// get an instance of B</span></div><div class="line">b.methodB();</div><div class="line">...</div><div class="line">&#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要使用B，类A必须先获取组件B的实例引用。若B是一个具体的类，则可以通过new关键字直接创建B的实例。但是，如果B是接口，且有多个实现，则问题就复杂了。我们固然可以任意选择接口B的一个实现类，但这也意味着A的可重用性大大降低，因为无法采用B的其他实现。<br>依赖注入是这样处理此类情景：<strong>接管对象的创建工作，并将该对象的引用注入需要该对象的组件</strong>。对于上面的例子，依赖注入框架会<em>分别创建对象A和对象B，并将对象B注入到对象A中</em>。<br>为了能让框架进行依赖注入，我们需要编写特定的<strong>setter方法</strong>或<strong>构造方法</strong>。<br><strong>setter方法依赖注入实例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> B b;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</div><div class="line">b.methodB();</div><div class="line">...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.b = b;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>修改后的类A新增了一个set方法，Spring会先创建B的实例，框架会调用该方法，并注入创建好的B的实例，因此在methodA()中调用B的methodB()方法前，不需要获取B的实例，<br><strong>构造器方法依赖注入实例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> B b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.b = b;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</div><div class="line">b.methodB();</div><div class="line">...</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Sping会先创建B的实例，再创建A的实例，然后把B注入到实例A中。</p><blockquote><p>注：Spring管理的对象称为beans。</p></blockquote><p>从1.0版本开始，Spring同时支持上述两种方式依赖注入：<strong>setter方式</strong>和<strong>构造器方式</strong>；从2.5版本开始，可以通过<code>AutoWired</code>注解，Spring支持基于field方式依赖注入。缺点是会引入org.springframework.beans.factory.annotation.Autowired，这对Spring产生了依赖，这样程序无法直接迁移到另一个依赖注入容器间。<br>以上是依赖注入的最后实现的两种方式。往前一点，Spring支持两种方式来支持这种依赖注入：<strong>XML配置方式</strong>和<strong>注解配置方式</strong>。此外，需要创建一个<code>ApplicationContext</code>对象，代表一个<strong>Spring控制反转容器</strong>，org.springframework.context.ApplicationContext接口有多个实现，包括<code>ClassPathXmlApplicationContext</code>和<code>FileSystemXmlApplicationContext</code>。这两个实现都需要至少包含一个beans信息的XML文件。ClassPathXmlApplicationContext尝试在<strong>类加载路径</strong>中加载配置文件，而FileSystemXmlApplicationContext从<strong>文件系统</strong>中加载。<br>下面为从类路径中加载<code>config1.xml</code>和<code>config2.xml</code>的ApplicationContext创建的一个代码示例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"config1.xml"</span>, <span class="string">"config2.xml"</span>&#125;);</div></pre></td></tr></table></figure></p><p>然后通过调用ApplicationContext的<code>getBean</code>方法获得对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Product product = context.getBean(<span class="string">"product"</span>, Product.class);</div></pre></td></tr></table></figure></p><p>getBean方法会查询<code>id</code>为product且<code>类型</code>为Product的bean对象。</p><blockquote><p>注：理想情况下，我们仅需要在测试代码中创建一个ApplicationContext，应用程序本身无需处理。对于Spring MVC应用，可以通过一个Spring Servlet来处理ApplicationContext，而无需直接处理。</p></blockquote><h2 id="XML配置文件介绍"><a href="#XML配置文件介绍" class="headerlink" title="XML配置文件介绍"></a>XML配置文件介绍</h2><p>配置文件的<code>根元素</code>通常为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans      </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p><p>若需要更强的Spring配置能力，可以在<code>schemaLocation</code>属性中添加相应的schema。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">xsi:schemaLocation=<span class="string">"  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/context  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/beans  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/tx  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/tx/spring-tx.xsd  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/jdbc  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/cache  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/cache/spring-cache-3.1.xsd  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/aop  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/aop/spring-aop.xsd  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/util  </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/util/spring-util.xsd"</span></div></pre></td></tr></table></figure></p><p>配置文件可以是一份也可以是多份，支持<strong>模块化配置</strong>。ApplicationContext的实现类支持读取多份配置文件，如上面例子中的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"config1.xml"</span>, <span class="string">"config2.xml"</span>&#125;);</div></pre></td></tr></table></figure></p><p>另一种选择是，通过一个<strong>主配置文件</strong>，将其他配置文件导入在主配置文件中，直接读取主配置文件，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans      </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</div><div class="line">    </div><div class="line">    &lt;<span class="keyword">import</span> resource=<span class="string">"config1.xml/&gt;</span></div><div class="line"><span class="string">    &lt;import resource="</span><span class="keyword">module</span>/config2.xml/&gt;</div><div class="line">    &lt;<span class="keyword">import</span> resource=<span class="string">"resource/config2.xml/&gt;</span></div><div class="line"><span class="string">    ...</span></div><div class="line"><span class="string">&lt;/beans&gt;</span></div></pre></td></tr></table></figure></p><h2 id="Spring控制反转容器的使用"><a href="#Spring控制反转容器的使用" class="headerlink" title="Spring控制反转容器的使用"></a>Spring控制反转容器的使用</h2><h3 id="通过构造器创建一个bean实例"><a href="#通过构造器创建一个bean实例" class="headerlink" title="通过构造器创建一个bean实例"></a>通过构造器创建一个bean实例</h3><p>前面通过调用ApplicationContext的getBean方法来获取到一个bean的实例。下面的配置文件中定义了一个名为product的bean。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans      </span></div><div class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</div><div class="line">    </div><div class="line">    &lt;bean name=<span class="string">"product"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"myspring.bean.Product"</span>/&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p><p>该bean的定义告诉Spring通过<strong>默认无参构造器</strong>来初始化Product类。如果不存在该构造器（若类作者重载了构造器，但是没有显示声明默认构造器），Spring将抛出异常。</p><blockquote><p>注意：应采用id或者name属性标示一个bean。</p></blockquote><p>为了让Spring创建一个Product实例，应将bean定义的name值“product”（具体实践中也可以是id值）和Product类型作为参数传递给ApplicationContext的getBean方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"spring-contig.xml"</span>&#125;);</div><div class="line">Product product = context.getBean(<span class="string">"product"</span>, Product.class);</div></pre></td></tr></table></figure></p><h3 id="通过工厂方法创建一个bean实例"><a href="#通过工厂方法创建一个bean实例" class="headerlink" title="通过工厂方法创建一个bean实例"></a>通过工厂方法创建一个bean实例</h3><p>Spring还支持通过<strong>调用</strong>一个工厂的方法来初始化类。下面的bean定义展示了通过工厂方法来实例化<code>java.util.Calendar</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"calendar"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.util.Calendar"</span> factory-method=<span class="string">"getInstance"</span>/&gt;</div></pre></td></tr></table></figure></p><p>该类中有方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    Calendar localCalendar = createCalendar(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));</div><div class="line">    localCalendar.sharedZone = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> localCalendar;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>本例子采用了id属性，而非name属性来表示bean，采用getBean方法来获取Calendar实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"spring-contig.xml"</span>&#125;);</div><div class="line">Calendar calendar = context.getBean(<span class="string">"calendar"</span>, Calendar.class);</div></pre></td></tr></table></figure></p><h3 id="Destory-Method-的使用"><a href="#Destory-Method-的使用" class="headerlink" title="Destory Method 的使用"></a>Destory Method 的使用</h3><p>有时候我们希望在类被销毁前还做点什么，这次我们可以在bean定义中配置 <code>destroy-method</code> 属性，来指定在销毁前要被执行的方法。<br>下面的例子中，我们配置Spring通过 <code>java.util.concurrent.Executors</code> 的静态方法<code>newCachedThreadPool</code> 来创建一个 <code>java.util.concurrent.ExecutorService</code> 实例，并指定了 <code>destroy-method</code> 属性值为 <code>shutdown</code> 方法。这样，Spring会在销毁 <code>ExecutorService</code> 实例前，调用其 <code>shutdown</code> 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"executorService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">".util.concurrent.ExecutorService"</span> </div><div class="line">    factory-method=<span class="string">"newCachedThreadPool"</span> destroy-method=<span class="string">"shutdown"</span>/&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对SpringMVC的了解来自实际项目以及在项目过程遇到问题是，查找相关资料，并没有系统地学习这些。很多会用，但是不太清楚具体原理，最新重新学习SpringMVC，开头一章系统的介绍，让我有所顿悟。对于这些知识的学习，让我对SpringMVC基本配置认识更加深刻，特此将重要
      
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/spring/java/"/>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>try catch finally return 的执行顺序</title>
    <link href="http://yoursite.com/2017/12/03/the%20order%20of%20the%20try-catch-finally-return/"/>
    <id>http://yoursite.com/2017/12/03/the order of the try-catch-finally-return/</id>
    <published>2017-12-03T11:03:30.000Z</published>
    <updated>2017-12-03T11:06:39.891Z</updated>
    
    <content type="html"><![CDATA[<p>结论：</p><ol><li><strong>不管有没有异常，finally中的代码一定会执行；</strong></li><li><strong>try 和 catch 中有 return 时，finally也会执行；</strong></li><li><strong>finally是在return后面的表达式运算后执行的，因此函数返回值是在finally执行前确定；</strong></li><li><strong>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值，是finally中return返回的值。</strong></li></ol><p>说明：对于第3点，<strong>return后面的表达式运算后</strong>先把要返回的值保存起来，然后执行finally中的代码（这里不包含return，否则就是第4点了），再将之前保存的值取出，并返回。</p><p>下面会列出几种情况并通过具体代码验证上面的结论。</p><hr><p>情况1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try&#123;&#125; catch()&#123;&#125;finally&#123;&#125; return;</div></pre></td></tr></table></figure></p><p>举例代码如下，这里不会发生异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"main:"</span> + test1());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"try..."</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">System.out.println(<span class="string">"catch..."</span>);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">System.out.println(<span class="string">"finally..."</span>);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"return..."</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>...</div><div class="line"><span class="keyword">finally</span>...</div><div class="line"><span class="keyword">return</span>...</div><div class="line">main:<span class="number">0</span></div></pre></td></tr></table></figure></p><p>显然按顺序执行。</p><p>情况2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try&#123; return; &#125;catch()&#123;&#125; finally&#123;&#125; return;</div></pre></td></tr></table></figure></p><p>try中有return，举例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"main:"</span> + test2());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"try...return1+1"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">System.out.println(<span class="string">"catch..."</span>);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">System.out.println(<span class="string">"finally..."</span>);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"return0..."</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>...return1+<span class="number">1</span></div><div class="line"><span class="keyword">finally</span>...</div><div class="line">main:<span class="number">2</span></div></pre></td></tr></table></figure></p><p>这里程序先执行try块中return之前已经return语句中表达式运算代码，再执行finally块，最后执行try中的return；而finally块后的return语句，因为在try块中已经return了，所以后面的就不执行了。</p><p>情况3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try&#123; &#125; catch()&#123;return;&#125; finally&#123;&#125; return;</div></pre></td></tr></table></figure></p><p>catch中有return，在try中造一个异常，举例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"main:"</span> + test3());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"try..."</span>);</div><div class="line"><span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">System.out.println(<span class="string">"catch...return2"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">System.out.println(<span class="string">"finally..."</span>);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"return0..."</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>...</div><div class="line"><span class="keyword">catch</span>...return2</div><div class="line"><span class="keyword">finally</span>...</div><div class="line">main:<span class="number">2</span></div></pre></td></tr></table></figure></p><p>程序先执行try块中的代码，因为try块中有异常，然后执行catch中return之前及return语句中表达式运算代码，最后执行finally块中的代码。</p><p>情况4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try&#123; return; &#125;catch()&#123;&#125; finally&#123;return;&#125;</div></pre></td></tr></table></figure></p><p>try块和finally块中均有return，举例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"main:"</span> + test3());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"try...return1"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">System.out.println(<span class="string">"catch..."</span>);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">System.out.println(<span class="string">"finally...return3"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">try...return1</div><div class="line">finally...return3</div><div class="line">main:3</div></pre></td></tr></table></figure></p><p>程序还是先执行try块中包括return之前已经return本身表达式运算代码，此时会将返回值存起来；这里没有异常，再接着执行finally块中的语句，由于finally块中有return，所以提前结果程序。finally中有return时，此时编译器也会给出警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">finally block does not complete normally</div></pre></td></tr></table></figure></p><p>情况5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try&#123;&#125; catch()&#123;return;&#125;finally&#123;return;&#125;</div></pre></td></tr></table></figure></p><p>catch块和finally块中有return，举例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"main:"</span> + test5());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"try..."</span>);</div><div class="line"><span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">System.out.println(<span class="string">"catch...return2"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">System.out.println(<span class="string">"finally...return3"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>...</div><div class="line"><span class="keyword">catch</span>...return2</div><div class="line"><span class="keyword">finally</span>...return3</div><div class="line">main:<span class="number">3</span></div></pre></td></tr></table></figure></p><p>程序首先执行try块，遇到了异常执行catch块，此时执行catch中return之前以及return中包含的表达式运算代码，将结果作为返回值保存起来；接着执行finally中的代码，由于finally块中有return，前面保存的返回值将丢弃，返回finally中的return值，程序退出。</p><p>情况6：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try&#123; return;&#125;catch()&#123;return;&#125; finally&#123;return;&#125;</div></pre></td></tr></table></figure></p><p>try、catch、finally块中均有return，并且try中会发生异常，举例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"main:"</span> + test6());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"try...return1"</span>);</div><div class="line"><span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">System.out.println(<span class="string">"catch...return2"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">System.out.println(<span class="string">"finally...return3"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>...return1</div><div class="line"><span class="keyword">catch</span>...return2</div><div class="line"><span class="keyword">finally</span>...return3</div><div class="line">main:<span class="number">3</span></div></pre></td></tr></table></figure></p><p>程序先执行try中代码，若没有异常将执行return之前以及return中表达式运算并将结果存起，执行finally中的代码；这里try块中有异常，接着执行catch中的代码，并执行return之前以及return中表达式运算并将结果存起，然后执行finally中的代码，由于finally中有return，将丢弃前面保存的，程序提前结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不管有没有异常，finally中的代码一定会执行；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;try 和 catch 中有 return 时，finally也会执行；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;stro
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="try-catch-finally-return" scheme="http://yoursite.com/tags/try-catch-finally-return/"/>
    
  </entry>
  
  <entry>
    <title>实现字符串反转的三种方法</title>
    <link href="http://yoursite.com/2017/11/24/reverse-string/"/>
    <id>http://yoursite.com/2017/11/24/reverse-string/</id>
    <published>2017-11-24T13:43:18.000Z</published>
    <updated>2017-11-24T13:45:14.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归反转"><a href="#递归反转" class="headerlink" title="递归反转"></a>递归反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse1</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> reverse1(str.substring(<span class="number">1</span>)) + str.charAt(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>字符串的<code>substring(1)</code>方法返回下标为<strong>1及后面所有的字符</strong>，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"abcdef"</span>.substring(<span class="number">1</span>));</div></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bcdef</div></pre></td></tr></table></figure></p><p>字符串的<code>charAt(0)</code>方法返回下标为<strong>0的字符</strong>，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"abcdef"</span>.charAt(<span class="number">0</span>));</div></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a</div></pre></td></tr></table></figure></p><p>注意：在用递归编写程序是，需要明确两点：</p><ul><li>递归公式</li><li>收敛条件（即：何时结束递归）</li></ul><p>否则会出现异常，甚至栈溢出，如下面的递归。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowErrorTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        main(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</div><div class="line">at com.h3c.imc.campus.commgroup.StackOverflowErrorTest.main(StackOverflowErrorTest.java:<span class="number">5</span>)</div><div class="line">at com.h3c.imc.campus.commgroup.StackOverflowErrorTest.main(StackOverflowErrorTest.java:<span class="number">5</span>)</div><div class="line">...</div></pre></td></tr></table></figure></p><hr><h2 id="reverse方法反转"><a href="#reverse方法反转" class="headerlink" title="reverse方法反转"></a>reverse方法反转</h2><p><code>StringBuffer/StringBuilder</code>中自带方法<code>reverse()</code>能实现字符串反转。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse2</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</div><div class="line"><span class="keyword">return</span> sb.reverse().toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h2 id="循环反转"><a href="#循环反转" class="headerlink" title="循环反转"></a>循环反转</h2><p>第一种思路：<code>循环递减</code>遍历该字符串，从最后一位开始取，每次取一个字符，最后拼接在一起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse3</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> length = str.length();</div><div class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || length &lt;= <span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">sb.append(str.charAt(i));</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二种思路：<code>循环递增</code>遍历该字符串，从首位开始取，字符拼接时，已经取出的拼接在后面，新的在前面。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse3</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> length = str.length();</div><div class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || length &lt;= <span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line">String reverse = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">    reverse = str.charAt(i) + reverse;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;递归反转&quot;&gt;&lt;a href=&quot;#递归反转&quot; class=&quot;headerlink&quot; title=&quot;递归反转&quot;&gt;&lt;/a&gt;递归反转&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="反转" scheme="http://yoursite.com/tags/%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>jvm加载class文件的原理机制分析</title>
    <link href="http://yoursite.com/2017/11/21/jvm-classloader/"/>
    <id>http://yoursite.com/2017/11/21/jvm-classloader/</id>
    <published>2017-11-21T15:25:54.000Z</published>
    <updated>2017-11-21T15:35:08.599Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>A、B类中均包含静态代码块，非静态代码块以及构造器，A类是B类的父类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    System.out.print(<span class="string">"A中静态代码块&gt;&gt;&gt;"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    System.out.print(<span class="string">"A中非静态代码块&gt;&gt;&gt;"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.print(<span class="string">"A中构造器&gt;&gt;&gt;"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.print(<span class="string">"B中静态代码块&gt;&gt;&gt;"</span>);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">      System.out.print(<span class="string">"B中非静态代码块&gt;&gt;&gt;"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"B中构造器&gt;&gt;&gt;"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么看看下面代码的运行结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABTest</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    A ab = <span class="keyword">new</span> B();</div><div class="line">    System.out.println(<span class="string">"\n==========================\n"</span>);</div><div class="line">    ab = <span class="keyword">new</span> B();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt;A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt;</div><div class="line">==========================</div><div class="line"></div><div class="line">A中非静态代码块&gt;&gt;&gt;A中构造器&gt;&gt;&gt;B中非静态代码块&gt;&gt;&gt;B中构造器&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>总结：</p><ol><li>同一类中：静态代码块 =&gt; 非静态代码块 =&gt; 构造器</li><li>父子类中：父类 =&gt; 子类；</li><li>静态代码块只在第一次实例化（new）执行了，非静态代码块在每次实例化都执行。</li></ol><p>看执行结果，上面的3条总结都没问题，对于第3点，需要注意下：静态代码块其实不是跟着实例走的，而是跟着类走。看如下测试，通过Class.forName()动态加载类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">  Class.forName(<span class="string">"B"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A中静态代码块&gt;&gt;&gt;B中静态代码块&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>这里并没有执行实例化过程，但是静态代码块却执行了，这也证明了静态static代码块并不是跟着实例走。下面将简单介绍下类加载相关概念及过程，介绍完后再看看上面的例子，印象会更深刻。首先得了解下几个比较重要的JVM的内存概念。</p><hr><h2 id="jvm的几个重要内存概念"><a href="#jvm的几个重要内存概念" class="headerlink" title="jvm的几个重要内存概念"></a>jvm的几个重要内存概念</h2><p><strong>方法区</strong></p><blockquote><p>专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域。</p></blockquote><p><strong>常量池</strong></p><blockquote><p>是方法区的一部分，主要用来存放常量和类中的符号引用等信息。</p></blockquote><p><strong>堆区</strong></p><blockquote><p>用于存放类的对象实例，如new、数组对象。</p></blockquote><p><strong>栈区</strong></p><blockquote><p>由一个个栈帧组成的后进先出的结构，主要存放方法运行时产生的局部变量、方法出口等信息。</p></blockquote><h2 id="java类的生命周期"><a href="#java类的生命周期" class="headerlink" title="java类的生命周期"></a>java类的生命周期</h2><p>我们编写完一个<code>.java</code>结尾的源文件后，经过编译后生成对应的一个或多个<code>.class</code>后缀结尾的文件。该文件也称为<code>字节码</code>文件，能在java虚拟机中运行。而类的生命周期正是：从类（.class文件）被加载到虚拟机内存，到从内存中卸载为止。整个周期一共分为7个阶段：</p><blockquote><p>加载，验证，准备，解析，初始化，使用，卸载</p></blockquote><p>其中</p><ul><li>验证，准备，解析统称为<code>连接</code>；</li><li>加载，验证，准备，初始化，卸载，这5个的顺序是确定的。</li></ul><p>值得注意的是，通常我们所说的<code>类加载</code>指的是：加载，验证，准备，解析，初始化，这5个阶段。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>该阶段虚拟机的任务主要是找到需要加载的类，并把类的信息加载到jvm的<em>方法区</em>中，然后<em>堆</em>中实例化一个<code>java.lang.Class</code>对象，作为方法区中这个类的信息的入口。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接阶段有三个阶段：<strong>验证，准备，解析</strong>。主要任务是加载后的<strong>验证工作</strong>以及一些初始化前的<strong>准备工作</strong>。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>当一个类被加载后，需要验证下该类是否合法，以保证加载的类能在虚拟机中正常运行。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>该阶段主要是为类的<strong>静态变量</strong>分配内存并设置为jvm默认的<strong>初始值</strong>；对于非静态变量，则不会为它们分配内存。这里静态变量的初始值，不是由我们指定的，是jvm默认的。</p><ul><li>基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0；</li><li>引用类型默认值是null；</li><li>常量的默认值为我们设定的值。比如我们定义<strong>final</strong> static int a = 1000，则在准备阶段中a的初始值就是1000。</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这一阶段的任务是把<strong>常量池中的符号引用转换为直接引用</strong>，也就是<strong>具体的内存地址</strong>。在这一阶段，jvm会将所有的类、接口名、字段名、方法名等转换为具体的内存地址。譬如：我们要在内存中找到一个类里面的一个叫call的方法，显然做不到，但是该阶段，由于jvm已经将call这个名字转换为指向方法区中的一块内存地址了，也就是说我们通过call这个方法名会得到具体的内存地址，也就找到了call在内存中的位置了。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>有且仅有</strong> <code>5种</code>情况必须立即对类进行<code>“初始化”</code>：</p><ol><li>使用<code>new</code>关键字实例化对象、读取或设置一个类的<code>静态字段</code>（被final修饰、已经在编译器把结果放入常量池的静态字段除外），以及调用一个类的<code>静态方法</code>的时候；</li><li>使用<code>java.lang.reflect</code>包的方法进行<code>反射调用</code>时，若类没有进行初始化，需要先触发其初始化；</li><li>当初始化一个类时，若其<code>父类</code>还没有进行初始化，则需要先触发其父类的初始化；</li><li>执行<code>main</code>方法，虚拟机会先初始化其包含的那个<code>主类</code>；</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化（这一点不是很懂）。</li></ol><p><strong>在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。</strong>（这正好解释了案例中第3点结论）</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>初始化</code>阶段的5种情况用了很强烈的限定词：<strong>有且仅有</strong>，这5种行为称为对一个类进行<code>“主动引用”</code>。其他所有引用类的方法（行为）都不会对类进行初始化，称之为<code>“被动引用”</code>。</p><p>《学习深入Java虚拟机》一书中列举了3个<code>被动引用</code>例子，我验证了下，确实如此，不过还得到了新的启发。这里列出其中的2个例子，如下：</p><p>例子1：<strong>通过子类引用父类的静态字段，不会导致子类初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> classloading;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> classloading;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> classloading;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(SubClass.value);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure></p><p>结论：<br>通过子类<code>SubClass</code>来引用父类<code>SuperClass</code>的静态字段<code>value</code>，初始化的只是父类，并不会触发子类的初始化。</p><p>例子2：<strong>常量在编译阶段会存入调用类的常量池中，不会触发定义常量的类的初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> classloading;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">System.out.println(<span class="string">"ConstClass init!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_WORLD = <span class="string">"hello world"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> classloading;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(ConstClass.HELLO_WORLD);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure></p><p>结论：<br>从打印的结果可以看到，并没有初始化<code>ConstClass</code>类；但是从源码上看是引用了<code>ConstClass</code>类的常量。因为在<code>NotInitialization</code>类的编译期中，通过常量优化，已经将常量 <code>&quot;hello world&quot;</code>存储到了<code>NotInitialization</code>类的常量池中了。也就是说，<code>NotInitialization</code>中引用<code>ConstClass.HELLO_WORLD</code>其实是<strong>对自身常量池中常量引用</strong>。 </p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>在使用完类后，需满足下面，类将被卸载：</p><ol><li>该类所有的实例都已经被回收，也就是java队中不存在该类的任何实例；</li><li>加载该类的ClassLoader已经被回收了；</li><li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>当上面三个条件都满足后，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程本质上就是在方法区中清空类信息，结束整个类的生命周期。</p><h2 id="jvm加载class文件的原理机制"><a href="#jvm加载class文件的原理机制" class="headerlink" title="jvm加载class文件的原理机制"></a>jvm加载class文件的原理机制</h2><p>面试题中经常会问到<strong>JVM加载Class文件的原理机制</strong>，结合上面的分析，引用下面网上的分析，更加容易理解。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：&nbsp;&nbsp;1)&nbsp;&nbsp;如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；&nbsp;&nbsp;2)&nbsp;&nbsp;如果类中存在初始化语句，就依次执行这些初始化语句。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。</p></blockquote><p>下面是关于几个类加载器的说明：</p><ul><li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li><li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li><li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;案例分析&quot;&gt;&lt;a href=&quot;#案例分析&quot; class=&quot;headerlink&quot; title=&quot;案例分析&quot;&gt;&lt;/a&gt;案例分析&lt;/h2&gt;&lt;p&gt;A、B类中均包含静态代码块，非静态代码块以及构造器，A类是B类的父类。&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="类加载" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈java对象浅度克隆和深度克隆</title>
    <link href="http://yoursite.com/2017/11/12/shallow-and-deep-clone/"/>
    <id>http://yoursite.com/2017/11/12/shallow-and-deep-clone/</id>
    <published>2017-11-12T05:20:16.000Z</published>
    <updated>2017-11-12T05:27:24.972Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="需要克隆的原因"><a href="#需要克隆的原因" class="headerlink" title="需要克隆的原因"></a>需要克隆的原因</h2><p>在工作中我们有时会遇到这样的需求：</p><blockquote><p>A对象包含一些有用信息，这时候需要一个和A完全相同的B对象。拿到B对象后，只需要稍微调整下就ok。A和B是两个独立的对象，只是B的初始值来自于A。而A/B对象中包含了比较复杂的数据结构。此时通过简单的赋值，并不能满足这种需求。</p></blockquote><p>我之前做过一个需求：</p><blockquote><p><strong>定时任务——自动新建XX产品</strong>：XX产品包含了很多信息，有<code>基本类型数据</code>也有<code>复杂结构对象</code>。已经上线的产品通过修改某些属性值就可以初始化形成新的XX产品，然后等待上线。这里就用到了克隆。</p></blockquote><hr><h2 id="克隆的实现方式"><a href="#克隆的实现方式" class="headerlink" title="克隆的实现方式"></a>克隆的实现方式</h2><h3 id="浅度克隆"><a href="#浅度克隆" class="headerlink" title="浅度克隆"></a>浅度克隆</h3><p>首先，定义一个<code>Student</code>类，包含两成员变量：<code>name</code>，<code>age</code>，并且实现<code>Cloneable</code>接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再，定义一个<code>Teacher</code>类，也是两字段：一个<code>name</code>，一个聚合对象<code>student</code>，并且实现<code>Cloneable</code>接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Student student;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, Student student)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.student = student;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> student;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudent</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.student = student;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要<code>clone</code>的类为什么要实现<code>Cloneable</code>接口？我们先看看该接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.lang;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></div><div class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></div><div class="line"><span class="comment"> * is legal for that method to make a</span></div><div class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></div><div class="line"><span class="comment"> * &lt;p&gt;</span></div><div class="line"><span class="comment"> * Invoking Object's clone method on an instance that does not implement the</span></div><div class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></div><div class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></div><div class="line"><span class="comment"> * &lt;p&gt;</span></div><div class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></div><div class="line"><span class="comment"> * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method.</span></div><div class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></div><div class="line"><span class="comment"> * method.</span></div><div class="line"><span class="comment"> * &lt;p&gt;</span></div><div class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method.</span></div><div class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></div><div class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></div><div class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></div><div class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></div><div class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个<code>“标示接口”</code>，即：没有任何方法和属性的接口。这个标示仅针对<code>java.lang.Object#clone()</code>方法。注释中：<br>第一段可以看到：我们调用的<code>clone()</code>方法是<code>Obejct</code>类的方法；<br>第二段中：若调用这个<code>Object.clone()</code>方法，但是不实现<code>Cloneable</code>接口(not implement Cloneable)的话，会抛<code>CloneNotSupportedException</code>异常。</p><p>我们来测试下，修改<code>Student</code>方法，去掉实现。代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">"jack"</span>, <span class="number">27</span>);</div><div class="line">    Student cloneStudent = (Student) student.clone();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"main"</span> java.lang.CloneNotSupportedException: clone.Student</div><div class="line">at java.lang.Object.clone(Native Method)</div><div class="line">at clone.Student.main(Student.java:<span class="number">38</span>)</div></pre></td></tr></table></figure></p><p>第三段中说：按照惯例，对于<code>Object.clone()</code>方法，我们需要是重写。我们看下该方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</div></pre></td></tr></table></figure></p><p>是个<code>native</code>方法，一般来说native方法的效率要高于非native方法，因此比那种new出新对象再把旧对象的信息赋值到新对象的效率要高。该方法还是个<code>protected</code>方法，也就是说外部程序想调用有局限性，因此需要重写修饰符设置为<code>public</code>。</p><p>下面再看一个<code>Teacher</code>相关的例子，这里先重写下<code>equals()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Teacher) &#123;</div><div class="line">    Teacher teacher = (Teacher) obj;</div><div class="line">    <span class="keyword">if</span> (teacher.name == <span class="keyword">this</span>.name &amp;&amp; teacher.student.equals(<span class="keyword">this</span>.student)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>作如下测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">"jack"</span>, <span class="number">27</span>);</div><div class="line">    Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"Ali"</span>, student);</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"Teacher的内存地址："</span> + teacher);</div><div class="line">    Teacher cloneTeacher = (Teacher) teacher.clone();</div><div class="line">    System.out.println(<span class="string">"克隆Teacher的内存地址："</span> + cloneTeacher);</div><div class="line">    System.out.println(<span class="string">"克隆前后，Teacher对象是否相等："</span> + teacher.equals(cloneTeacher) + <span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"++++++我只想修改克隆对象中的Student姓名为‘rose’++++++\n"</span>);</div><div class="line">    cloneTeacher.getStudent().setName(<span class="string">"rose"</span>);</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"修改Student姓名后，Teacher的内存地址："</span> + teacher);</div><div class="line">    System.out.println(<span class="string">"修改Student姓名后，克隆Teacher的内存地址："</span> + cloneTeacher);</div><div class="line">    System.out.println(<span class="string">"修改Student姓名后，克隆前后，Teacher对象是否相等："</span> + teacher.equals(cloneTeacher));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Teacher的内存地址：clone.Teacher@<span class="number">6</span>c89db9a</div><div class="line">克隆Teacher的内存地址：clone.Teacher@<span class="number">4</span>eb09321</div><div class="line">克隆前后，Teacher对象是否相等：<span class="keyword">true</span></div><div class="line"></div><div class="line">++++++我只想修改克隆对象中的Student姓名为‘rose’++++++</div><div class="line"></div><div class="line">修改Student姓名后，Teacher的内存地址：clone.Teacher@<span class="number">6</span>c89db9a</div><div class="line">修改Student姓名后，克隆Teacher的内存地址：clone.Teacher@<span class="number">4</span>eb09321</div><div class="line">修改Student姓名后，克隆前后，Teacher对象是否相等：<span class="keyword">true</span></div></pre></td></tr></table></figure></p><p>我们可以看到：</p><ul><li>克隆前后，内存地址发生了变化<code>@6c89db9a</code>=&gt;<code>@4eb09321</code>；</li><li>克隆前后以及修改了<code>Student</code>对象<code>name</code>属性值，对象没有变化，<code>equals</code>结果为<code>true</code>。</li></ul><p>也就是说，<strong>不同的引用指向了同一个对象</strong>。因此，若我只想修改克隆对象的信息，这种情况下是做不到的。</p><p>但是若只是修改<code>基本类型</code>或者<code>String字符串</code>，却能满足需求，只会影响克隆后的对象。譬如：<br>去掉：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cloneTeacher.getStudent().setName(<span class="string">"rose"</span>);</div></pre></td></tr></table></figure></p><p>并增加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cloneTeacher.setName(<span class="string">"Alice"</span>);</div></pre></td></tr></table></figure></p><p><code>equals</code>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">修改Student姓名后，克隆前后，Teacher对象是否相等：<span class="keyword">false</span></div></pre></td></tr></table></figure></p><p>最后别忘了重写下<code>clone</code>方法，修改修饰符为<code>public</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.clone();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h3><p><em>深度克隆</em>之所以有<code>深度</code>，是弥补了<em>浅度克隆</em>对于<strong>对象类型的属性</strong>克隆的不足。这里通过<strong>对象序列化和反序列化</strong>来实现深度克隆。</p><p>对象的序列化</p><blockquote><p>把对象转换为字节序列的过程</p></blockquote><p>对象的反序列化：</p><blockquote><p>把字节序列恢复为对象的过程</p></blockquote><p>如何实现：<br>首先新建一个工具类，封装<code>clone</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtil</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">CloneUtil</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">    ByteArrayOutputStream baos = <span class="keyword">null</span>;</div><div class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</div><div class="line">    ByteArrayInputStream bais = <span class="keyword">null</span>;</div><div class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">      oos = <span class="keyword">new</span> ObjectOutputStream(baos);</div><div class="line">      oos.writeObject(obj);</div><div class="line"></div><div class="line">      bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</div><div class="line">      ois = <span class="keyword">new</span> ObjectInputStream(bais);</div><div class="line">      <span class="keyword">return</span> (T) ois.readObject();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Class not found."</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Clone Object failed in IO."</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</div><div class="line">          ois.close();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</div><div class="line">          oos.close();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>说明：</p><blockquote><p>调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义。这两个基于内存的流就能够释只要垃圾回收器清理对象放资源，这一点不同于对外部资源（如文件流）的释放。</p></blockquote><p>修改<code>Student</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>修改<code>Teacher</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Teacher [name="</span> + name + <span class="string">", student="</span> + student + <span class="string">"]"</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>替换<code>main</code>方法中测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Teacher cloneTeacher = (Teacher) teacher.clone();</div></pre></td></tr></table></figure></p><p>为<code>序列化-反序列化</code>克隆方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Teacher cloneTeacher = CloneUtil.clone(teacher);</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=<span class="number">27</span>]]</div><div class="line">克隆Teacher的toString：Teacher [name=Ali, student=Student [name=jack, age=<span class="number">27</span>]]</div><div class="line">克隆前后，Teacher对象是否相等：<span class="keyword">false</span></div><div class="line"></div><div class="line">++++++我只想修改克隆对象中的Student姓名为‘rose’++++++</div><div class="line"></div><div class="line">修改Student姓名后，Teacher的的toString：Teacher [name=Ali, student=Student [name=jack, age=<span class="number">27</span>]]</div><div class="line">修改Student姓名后，克隆Teacher的的toString：Teacher [name=Ali, student=Student [name=rose, age=<span class="number">27</span>]]</div><div class="line">修改Student姓名后，克隆前后，Teacher对象是否相等：<span class="keyword">false</span></div></pre></td></tr></table></figure></p><p>明显可以看到，修改<code>Student</code>属性后，对克隆前的对象没有影响。</p><p>需要注意：<code>CloneUtil</code>类中的<code>clone()</code>长这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型<strong><code>&lt;T extends Serializable&gt;</code></strong>限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用<code>Object</code>类的<code>clone</code>方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p><p>当然，若是聚合对象如<code>Teacher</code>中的<code>Student</code>没有实现<code>Serializable</code>接口，还是会在运行时抛异常的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;需要克隆的原因&quot;&gt;&lt;a href=&quot;#需要克隆的原因&quot; class=&quot;headerlink&quot; title=&quot;需要克隆的原因&quot;&gt;&lt;/a&gt;需要克隆的原因&lt;/h2&gt;&lt;p&gt;在工作中我们有时会遇到这样的需求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A对象包含一些
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="浅度克隆" scheme="http://yoursite.com/tags/%E6%B5%85%E5%BA%A6%E5%85%8B%E9%9A%86/"/>
    
      <category term="深度克隆" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/"/>
    
  </entry>
  
  <entry>
    <title>反射机制基础解析</title>
    <link href="http://yoursite.com/2017/11/07/reflect-base/"/>
    <id>http://yoursite.com/2017/11/07/reflect-base/</id>
    <published>2017-11-07T15:02:25.000Z</published>
    <updated>2017-11-07T15:08:30.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p></blockquote><p>通俗来讲：<strong>反射就是把Class对象的各种成分映射成对应的Java类</strong>。</p><hr><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>java反射机制其实就是将<code>.class</code>转化为<code>.java</code>，也即<strong>反编译</strong>。具体主要提供了以下功能：</p><ul><li>在运行时判断任意一个对象所属的<code>类</code>；</li><li>在运行时<code>构造</code>任意一个类的对象；</li><li>在运行时判断任意一个类所具有的<code>成员变量</code>和<code>方法</code>；</li><li>在运行时<code>调用</code>任意一个对象的方法。</li></ul><p>后面会围绕这几点具体展开。</p><hr><h2 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h2><p>在<code>java.lang.reflect</code>包下<strong>提供类和接口，以获得关于类和对象的反射信息</strong>。这里简单罗列了与反射相关的几个重要的API，真正想学习反射机制，除了在项目中历练，API也是非常重要的手段。英语不好理解的话，就搜搜汉化后的API文档。</p><table><thead><tr><th>变量相关</th><th>含义</th></tr></thead><tbody><tr><td>getField(String name)</td><td>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定<strong>公共成员字段</strong>。</td></tr><tr><td>getFields()</td><td>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问<strong>公共字段</strong>。</td></tr><tr><td>getDeclaredField(String name)</td><td>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。</td></tr><tr><td>getDeclaredFields()</td><td>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的<strong>所有字段</strong>。</td></tr><tr><td></td><td></td></tr><tr><td><strong>方法相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr><tr><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td></td><td></td></tr><tr><td><strong>构造方法相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法</td></tr><tr><td>getConstructors()</td><td>返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法</td></tr><tr><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。</td></tr><tr><td>getDeclaredConstructors()</td><td>返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法</td></tr><tr><td></td><td></td></tr><tr><td><strong>父类、父接口相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getInterfaces()</td><td>确定此对象所表示的类或接口实现的接口。</td></tr><tr><td>getSuperclass()</td><td>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。</td></tr><tr><td></td><td></td></tr><tr><td><strong>其他重要相关</strong></td><td><strong>含义</strong></td></tr><tr><td>getModifiers()</td><td>以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符。</td></tr><tr><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称。</td></tr><tr><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。</td></tr><tr><td>newInstance()</td><td>创建此 Class 对象所表示的类的一个新实例。</td></tr><tr><td>isInstance(Object obj)</td><td>判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。</td></tr></tbody></table><hr><h2 id="具体功能实现"><a href="#具体功能实现" class="headerlink" title="具体功能实现"></a>具体功能实现</h2><p>下面通过例子分别讲述<code>获取Class对象的3种方式</code>，<code>如何创建实例</code>，<code>如何获取构造器</code>，<code>如何获取方法</code>，<code>如何获取属性</code>以及通过反射<code>调用方法</code>。</p><h3 id="获取Class对象的3种方式"><a href="#获取Class对象的3种方式" class="headerlink" title="获取Class对象的3种方式"></a>获取Class对象的3种方式</h3><p>例如新建一个类<code>MyReflectTest</code>，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflectTest</span> </span>&#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方式1：使用<code>Class</code>类的中静态<code>forName()</code>方法获得与字符串对应的Class对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class&lt;?&gt; clz = Class.forName(<span class="string">"test.MyReflectTest"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在数据库有关开发中，我们经常会用到这个方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>)</div></pre></td></tr></table></figure></p><p>方式2： 利用对象的<code>class</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意</strong>，在基本类型和包装类型中有，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer.TYPE</div></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>.class</div></pre></td></tr></table></figure></p><p>是<code>int</code>的<code>Class</code>对象，不等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer.class</div></pre></td></tr></table></figure></p><p>这是<code>Integer</code>的<code>Class</code>对象表示，看看源码就知道了。</p><p>方式3：调用对象的<code>getClass()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  MyReflectTest myReflectTest = <span class="keyword">new</span> MyReflectTest();</div><div class="line">  Class clz = myReflectTest.getClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>获取到class对象后，调用<code>newInstance()</code>方法来创建Class对象对应的类实例，<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line">  MyReflectTest newInstance = (MyReflectTest) clz.newInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>获取类的所有构造器，测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line">  </div><div class="line">  <span class="comment">// 获取public构造器数组</span></div><div class="line">  Constructor[] cons = clz.getConstructors();</div><div class="line">  </div><div class="line">  <span class="comment">// 获取public，默认，protected，private构造器数组</span></div><div class="line">  Constructor[] declaredCons = clz.getDeclaredConstructors();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取类中指定的某个构造器，测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyReflectTest</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>();</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyReflectTest(String name, <span class="keyword">int</span> age) &#123;</div><div class="line">  <span class="keyword">super</span>();</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  <span class="comment">// 获取public构造器，构造器参数类型为String</span></div><div class="line">  Constructor con = clz.getConstructor(String.class);</div><div class="line"></div><div class="line">  <span class="comment">// 获取public，默认，protected，private构造器，构造器参数类型为String，int</span></div><div class="line">  Constructor declaredCon = clz.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>新增两个方法:<code>add()</code>和<code>get()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">  System.out.println(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  System.out.println(age);</div><div class="line">  <span class="keyword">return</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>getDeclaredMethods()</code>方法相关测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  Method[] declaredMethods = clz.getDeclaredMethods();</div><div class="line">  <span class="keyword">for</span> (Method method : declaredMethods) &#123;</div><div class="line">    System.out.println(<span class="string">"==============================="</span>);</div><div class="line">    <span class="comment">// 访问修饰符</span></div><div class="line">    System.out.println(Modifier.toString(method.getModifiers()));</div><div class="line">    <span class="comment">// 返回类型</span></div><div class="line">    System.out.println(method.getReturnType());</div><div class="line">    <span class="comment">// 方法名称</span></div><div class="line">    System.out.println(method.getName());</div><div class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; param : parameterTypes) &#123;</div><div class="line">      <span class="comment">// 方法参数类型</span></div><div class="line">      System.out.println(param.getName());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">===============================</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span></div><div class="line"><span class="keyword">void</span></div><div class="line">main</div><div class="line">[Ljava.lang.String; <span class="comment">//"["表示数组对象</span></div><div class="line">===============================</div><div class="line"><span class="keyword">private</span></div><div class="line"><span class="keyword">void</span></div><div class="line">add</div><div class="line">java.lang.String</div><div class="line">===============================</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="keyword">int</span></div><div class="line">get</div></pre></td></tr></table></figure></p><p>能获取私有的方法<code>add()</code>。<br>看看另一个反射方法：<code>getMethods()</code>，代码和上面一个，基本没变化。<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  Method[] methods = clz.getMethods();</div><div class="line">  <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">    System.out.println(<span class="string">"+++++++++++++++++++++++++++++++++"</span>);</div><div class="line">    System.out.println(Modifier.toString(method.getModifiers()));</div><div class="line">    System.out.println(method.getReturnType());</div><div class="line">    System.out.println(method.getName());</div><div class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; param : parameterTypes) &#123;</div><div class="line">      System.out.println(param.getName());</div><div class="line">      </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span></div><div class="line"><span class="keyword">void</span></div><div class="line">main</div><div class="line">[Ljava.lang.String;</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="keyword">int</span></div><div class="line">get</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span></div><div class="line"><span class="keyword">void</span></div><div class="line">wait</div><div class="line"><span class="keyword">long</span></div><div class="line"><span class="keyword">int</span></div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span></div><div class="line"><span class="keyword">void</span></div><div class="line">wait</div><div class="line"><span class="keyword">long</span></div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span></div><div class="line"><span class="keyword">void</span></div><div class="line">wait</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="keyword">boolean</span></div><div class="line">equals</div><div class="line">java.lang.Object</div><div class="line">+++++++++++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></div><div class="line"><span class="class"><span class="title">toString</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">int</span></span></div><div class="line"><span class="class"><span class="title">hashCode</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span></span></div><div class="line"><span class="class"><span class="title">getClass</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">void</span></span></div><div class="line"><span class="class"><span class="title">notify</span></span></div><div class="line"><span class="class">+++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">native</span></span></div><div class="line"><span class="class"><span class="title">void</span></span></div><div class="line"><span class="class"><span class="title">notifyAll</span></span></div></pre></td></tr></table></figure></p><p>对比上面的<code>getDeclaredMethods()</code>，少了一个私有的方法<code>add()</code>，但是多了好多不在本类的方法。由于每个类的超类都是<code>Object</code>类，很明显，这些方法都是来自超类，看看源码也能发现这个。也就是说：</p><ul><li><code>getDeclaredMethods()</code>获取的是本类的方法，public、默认、protected、private；</li><li><code>getMethods()</code>获取的是本类和父类的所有的public的方法。</li></ul><p>另外有获取指定某一个方法的反射方法。<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">", age: "</span> + age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  <span class="comment">// 第一个参数是“方法名”，后面的是方法的可变参数列表</span></div><div class="line">  Method method = clz.getMethod(<span class="string">"save"</span>, String.class, <span class="keyword">int</span>.class);</div><div class="line">  System.out.println(Modifier.toString(method.getModifiers()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span></div></pre></td></tr></table></figure></p><p>其他的类似。</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>创建两个成员变量<code>name</code>，<code>age</code>，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String name;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</div></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  Field[] fields = clz.getFields();</div><div class="line">  <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">    System.out.println(<span class="string">"+++++++++++++++++++++++++"</span>);</div><div class="line">    System.out.println(Modifier.toString(field.getModifiers()));</div><div class="line">    System.out.println(field.getType());</div><div class="line">    System.out.println(field.getName());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Field[] declaredFields = clz.getDeclaredFields();</div><div class="line">  <span class="keyword">for</span> (Field field : declaredFields) &#123;</div><div class="line">    System.out.println(<span class="string">"========================="</span>);</div><div class="line">    System.out.println(Modifier.toString(field.getModifiers()));</div><div class="line">    System.out.println(field.getType());</div><div class="line">    System.out.println(field.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+++++++++++++++++++++++++</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></div><div class="line"><span class="class"><span class="title">name</span></span></div><div class="line"><span class="class"></span>=========================</div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></div><div class="line"><span class="class"><span class="title">name</span></span></div><div class="line"><span class="class"></span>=========================</div><div class="line"><span class="keyword">private</span></div><div class="line"><span class="keyword">int</span></div><div class="line">age</div></pre></td></tr></table></figure></p><p>另外<code>getField(String)</code>，<code>getDeclaredField(String)</code>参数为方法名，和<code>Method</code>类似。</p><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>通过上面的一系列操作获取到某一方法后，我们可以利用<code>invoke()</code>方法来调用这个方法。<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">", age: "</span> + age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">// 获取类对象</span></div><div class="line">  Class&lt;MyReflectTest&gt; clz = MyReflectTest.class;</div><div class="line"></div><div class="line">  <span class="comment">// 获取对象实例</span></div><div class="line">  MyReflectTest reflect = (MyReflectTest) clz.newInstance();</div><div class="line">  </div><div class="line">  <span class="comment">// 获取save方法</span></div><div class="line">  Method method = clz.getMethod(<span class="string">"save"</span>, String.class, <span class="keyword">int</span>.class);</div><div class="line">  </div><div class="line">  <span class="comment">// 第一个参数为对象实例，后面的为方法的参数</span></div><div class="line">  Object result = method.invoke(reflect, <span class="string">"jack"</span>, <span class="number">27</span>);</div><div class="line">  </div><div class="line">  System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name: jack, age: <span class="number">27</span></div></pre></td></tr></table></figure></p><p>最后：反射在工作中其实用到的时候并不多，主要用来构建框架。譬如Spring中的<code>IOC</code>也即<code>控制反转</code>，其底层就是利用了反射。以后有时间再整理下这块。反射机制基础到这结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Reflection enables Java code to discover information abou
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>静态static与非静态non-static(变量、方法、内部类)解析</title>
    <link href="http://yoursite.com/2017/11/06/static-and-non-static/"/>
    <id>http://yoursite.com/2017/11/06/static-and-non-static/</id>
    <published>2017-11-06T14:54:16.000Z</published>
    <updated>2017-11-06T15:04:50.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。<br> </p><p align="right">—— <a href="https://baike.baidu.com/item/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/10078563?fr=aladdin" target="_blank" rel="external">Java编程思想</a></p><p></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;一句话描述下：<strong>方便在对象没有创建的时候调用方法或变量</strong>。<em>很显然，<code>static</code>依赖于<code>类</code>，只要类加载了，就可以使用，而不需要等对象实例化后再调用。</em></p><p>下面具体分析下。</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul><li><code>static</code>修饰的变量，也叫<code>类变量</code>；</li><li>可以直接用<code>类名.变量</code>调用，也可以用<code>对象名.变量</code>调用；</li><li>所有对象的同一个类变量共享同一块内存空间。</li></ul><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul><li>没有<code>static</code>修饰，也就<code>对象变量</code>；</li><li>只能通过<code>对象</code>调用；</li><li>所有对象的同一个类变量共享不同内存空间。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>静态变量是所有对象<strong>共有的</strong>，当某一个对象将它的值改变，此时其他对象去获取时，将得到改变后的值，因为它依赖于<code>类</code>；</li><li>实例变量是每一个对象<strong>私有的</strong>，当某一个对象将它的值改变，此时其他对象去获取时，得到的还是改变前的值，因为它依赖具体的<code>实例</code>；</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>静态变量和非静态变量举例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"静态变量：直接用‘类名.’调用: age = "</span> + StaticTest.age);</div><div class="line"></div><div class="line">    <span class="comment">// 修改静态变量值</span></div><div class="line">    StaticTest.age = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 实例化StaticTest对象</span></div><div class="line">    StaticTest staticTest = <span class="keyword">new</span> StaticTest();</div><div class="line">    System.out.println(<span class="string">"静态变量：通过‘实例化后的对象’调用：age = "</span> + staticTest.age);</div><div class="line">    System.out.println(<span class="string">"实例变量：只能通过‘实例化后的对象’调用：level = "</span> + staticTest.level);</div><div class="line"></div><div class="line">    <span class="comment">// 修改静态变量值</span></div><div class="line">    staticTest.age = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 修改实例变量值</span></div><div class="line">    staticTest.level = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 再实例化一个StaticTest对象</span></div><div class="line">    StaticTest staticTest1 = <span class="keyword">new</span> StaticTest();</div><div class="line">    System.out.println(<span class="string">"静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = "</span> + staticTest1.age);</div><div class="line">    System.out.println(<span class="string">"实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = "</span> + staticTest1.level);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">静态变量：直接用‘类名.’调用: age = 1</div><div class="line">静态变量：通过‘实例化后的对象’调用：age = 2</div><div class="line">实例变量：只能通过‘实例化后的对象’调用：level = 1</div><div class="line">静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = 3</div><div class="line">实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = 1</div></pre></td></tr></table></figure></p><p>结果和前面分析的一致。</p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><code>static</code>修饰的方法，属于<code>类</code>；</li><li>可以直接用<code>类名.方法名</code>调用，也可以用<code>对象名.方法名</code>调用；</li><li>在访问本类成员时，只允许访问<code>静态变量</code>和<code>静态方法</code>，不允许访问<code>实例变量</code>和<code>实例方法</code>；</li><li><code>static</code>块也即静态代码块，只能调用静态方法。</li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li>没有<code>static</code>修饰，属于<code>对象</code>；</li><li>只能通过<code>对象</code>调用；</li><li>实例方法可以访问<code>实例成员</code>，也可访问<code>静态成员</code>；</li><li><code>static</code>块中不能调用实例方法。</li></ul><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 非静态方法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="keyword">this</span>.level);</div><div class="line">    </div><div class="line">    System.out.println(age);</div><div class="line">    </div><div class="line">    staticMethod();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 静态方法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(age);</div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过</span></div><div class="line">    <span class="comment">//System.out.println(level);</span></div><div class="line"></div><div class="line">    System.out.println(<span class="keyword">new</span> StaticTest().level);</div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过</span></div><div class="line">    <span class="comment">//nonStaticMethod();</span></div><div class="line"></div><div class="line">    <span class="keyword">new</span> StaticTest().nonStaticMethod();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;静态方法在类加载时就创建了，但是非静态方法需要实例化后才能创建，因为<strong>先类加载，再实例化</strong>，所以静态方法中不能直接访问类的成员，只有类实例化后才能访问。</p><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;将一个类的定义放在另一个类的定义内部，就是内部类。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;这里只分析普通内部类和静态内部类的区别，具体关于内部类知识暂时请参见<a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="external">详解内部类</a></p><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><ul><li>不能有静态成员（静态方法，静态变量），否则编译不通过；</li><li>可以访问外部类的所有成员（方法，属性）；</li><li>实例化内部类方法：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1). 先生成一个外部类的对象实例，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass o = <span class="keyword">new</span> OutClass();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2). 通过外部类的对象实例生成内部类对象，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerClass no_static_i = o.new InnerClass();</div></pre></td></tr></table></figure></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ul><li>可以有静态和非静态成员；</li><li>只能访问外部类的静态成员；</li><li>实例化一个静态内部类方法：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1). 不依赖外部类的实例，直接实例化内部类对象，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerStaticClass static_i  = <span class="keyword">new</span> OutClass.InnerStaticClass();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2). 调用静态内部类的方法或变量，通过类名直接调用，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerStaticClass.static_name;</div><div class="line">OutClass.InnerStaticClass.getName();</div></pre></td></tr></table></figure></p><h3 id="举例及总结"><a href="#举例及总结" class="headerlink" title="举例及总结"></a>举例及总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String outName = <span class="string">"OutClass.outName"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> String staticOutName = <span class="string">"OutClass.staticOutName"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOutName</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(outName);</div><div class="line">    System.out.println(staticOutName);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getOutStaticName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 编译不通过，静态方法不能访问非静态成员</span></div><div class="line">    <span class="comment">//System.out.println(outName);</span></div><div class="line"></div><div class="line">    System.out.println(staticOutName);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 依赖外部类实例，创建非静态内部类</span></div><div class="line">    OutClass o = <span class="keyword">new</span> OutClass();</div><div class="line">    OutClass.InnerClass no_static_i = o.new InnerClass();</div><div class="line">    no_static_i.getInnerName();</div><div class="line"></div><div class="line">    <span class="comment">// 不依赖外部类实例，直接实例化静态内部类</span></div><div class="line">    OutClass.InnerStaticClass static_i = <span class="keyword">new</span> OutClass.InnerStaticClass();</div><div class="line">    static_i.getInnerName();</div><div class="line"></div><div class="line">    <span class="comment">// 通过静态内部类类名直接调用成员变量或方法</span></div><div class="line">    System.out.println(OutClass.InnerStaticClass.staticInnerName);</div><div class="line">    OutClass.InnerStaticClass.getStaticInnerName();</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 非静态内部类</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 编译不通过，普通静态内部类中不能有static变量</span></div><div class="line">    <span class="comment">//static String staticInnerName = "InnerClass.staticInnerName";</span></div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过，普通静态内部类中不能有static方法</span></div><div class="line">    <span class="comment">//public static void getStaticInnerName() &#123;</span></div><div class="line">    <span class="comment">//  System.out.println(staticInnerName);</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line"></div><div class="line">    String innerName = <span class="string">"InnerClass.innerName"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(innerName);</div><div class="line"></div><div class="line">      <span class="comment">// 直接访问外部类成员变量</span></div><div class="line">      System.out.println(outName);</div><div class="line"></div><div class="line">      <span class="comment">// 直接访问外部类静态成员变量</span></div><div class="line">      System.out.println(staticOutName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 静态内部类</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerStaticClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> String staticInnerName = <span class="string">"InnerStaticClass.staticInnerName"</span>;</div><div class="line"></div><div class="line">    String innerName = <span class="string">"InnerStaticClass.innerName"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getStaticInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(staticInnerName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(innerName);</div><div class="line"></div><div class="line">      <span class="comment">// 编译不通过，不能直接反问外部类成员变量</span></div><div class="line">      <span class="comment">//System.out.println(outName);</span></div><div class="line"></div><div class="line">      <span class="comment">// 只能访问外部类静态成员</span></div><div class="line">      System.out.println(staticOutName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="静态" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81/"/>
    
      <category term="非静态" scheme="http://yoursite.com/tags/%E9%9D%9E%E9%9D%99%E6%80%81/"/>
    
      <category term="内部类" scheme="http://yoursite.com/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>反编译小工具：jad常用命令介绍</title>
    <link href="http://yoursite.com/2017/11/06/jad-cmd-introduce/"/>
    <id>http://yoursite.com/2017/11/06/jad-cmd-introduce/</id>
    <published>2017-11-05T16:56:14.000Z</published>
    <updated>2017-11-05T17:13:50.446Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>jad</code>是最简单的字节码<code>.class</code>反编译出源码<code>.java</code>的小工具。<br>是<code>jdk</code>自带的，我的在<code>‪D:\Java\jdk1.7.0_80\bin\jad.exe</code>。</p><hr><h2 id="jad常用命令"><a href="#jad常用命令" class="headerlink" title="jad常用命令"></a>jad常用命令</h2><ul><li><code>-o</code> 不提示，覆盖源文件，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -o example.class</div></pre></td></tr></table></figure></li></ul><p>　若当前目录下有<code>example.jad</code>文件（默认扩展名<code>jad</code>），执行该命令后会覆盖原<code>example.jad</code>文件</p><ul><li><code>-s</code> 指定输出文件的类型，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -s java example.class</div></pre></td></tr></table></figure></li></ul><p>反编译结果以<code>.java</code>为扩展名。</p><ul><li><code>-p</code> 将反编译结果输出到<code>cmd</code>窗口，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -p example.class</div></pre></td></tr></table></figure></li></ul><p>反编译结果直接在<code>cmd</code>界面显示。</p><ul><li><code>&gt;</code> 将反编译结果重定向到文件，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -p example.class &gt; example1.java</div></pre></td></tr></table></figure></li></ul><p>在当前目录下，将<code>example.class</code>反编译后输出到<code>example1.java</code>文件中。</p><ul><li><code>-d</code> 指定反编译的输出文件目录，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -d test example.class</div></pre></td></tr></table></figure></li></ul><p>在当前目录下会产生目录<code>test</code>，里面有<code>example.jad</code>文件</p><p><strong>常用命令组合</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java example.class</div></pre></td></tr></table></figure></p><ul><li>用<code>JVM字节码格式</code>来注解输出(<code>-a</code>)；</li><li>覆盖原文件（<code>-o</code>）；</li><li>以<code>java</code>扩展名输出<code>example</code>文件（<code>-s java</code>）</li></ul><h2 id="jad帮助信息"><a href="#jad帮助信息" class="headerlink" title="jad帮助信息"></a>jad帮助信息</h2><p><code>jad</code>的帮助信息如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">Options: </div><div class="line">                   //用JVM字节格式来注解输出   </div><div class="line">         -a       - generate JVM instructions as comments (annotate) </div><div class="line">                  //同 -a,但是注解的时候用全名称</div><div class="line">         -af      - output fully qualified names when annotating</div><div class="line">                  //输出多于的括号 (e.g., if(a) &#123; b(); &#125;, default: no)</div><div class="line">         -b       - generate redundant braces (braces)</div><div class="line">                  //清除所有的前缀 </div><div class="line">         -clear   - clear all prefixes, including the default ones</div><div class="line">                  //指定输出文件的文件目录</div><div class="line">         -d &lt;dir&gt; - directory for output files</div><div class="line">                  //试图反编译代码的dead 部分(default: no)</div><div class="line">         -dead    - try to decompile dead parts of code (if there are any)</div><div class="line">                  //不用用字节码的方式反编译 (no JAVA source generated)</div><div class="line">         -dis     - disassembler only (disassembler)</div><div class="line">                  //输出整个的名字,无论是类还是方法</div><div class="line">         -f       - generate fully qualified names (fullnames)</div><div class="line">                  //输出类的成员在方法之前 (default: after methods)</div><div class="line">         -ff      - output fields before methods (fieldsfirst)</div><div class="line">                  //输出所有的变量的缺省的最初值</div><div class="line">         -i       - print default initializers for fields (definits)</div><div class="line">                  //将strings分割成指定数目的块的字符 (default: no)</div><div class="line">         -l&lt;num&gt;  - split strings into pieces of max &lt;num&gt; chars (splitstr)</div><div class="line">                  //将输出文件用行号来注解 (default: no)</div><div class="line">         -lnc     - output original line numbers as comments (lnc)</div><div class="line">                  //分割strings用新行字符 newline character (default: no)</div><div class="line">         -nl      - split strings on newline characters (splitstr)</div><div class="line">                  //不要转换java的定义符 (default: do)</div><div class="line">         -noconv  - don&apos;t convert Java identifiers into valid ones (noconv)</div><div class="line">                  //不要生成辅助文件</div><div class="line">         -nocast  - don&apos;t generate auxiliary casts</div><div class="line">                  //不要生成方法的源代码 </div><div class="line">         -nocode  - don&apos;t generate the source code for methods</div><div class="line">                  //不允许空的构造器存在</div><div class="line">         -noctor  - suppress the empty constructors</div><div class="line">                  //不要去检查class文件是否以dos方式写 (CR before NL, default: check)</div><div class="line">         -nodos   - turn off check for class files written in DOS mode</div><div class="line">                  //关掉对内部类的支持 (default: turn on)</div><div class="line">         -noinner - turn off the support of inner classes</div><div class="line">                  //忽略局部变量的表信息</div><div class="line">         -nolvt   - ignore Local Variable Table entries (nolvt)</div><div class="line">                  //不要输出一个新行在打开一个括号之前 (default: do)</div><div class="line">         -nonlb   - don&apos;t insert a newline before opening brace (nonlb)</div><div class="line">                  //无需确认直接覆盖输出 (default: no)</div><div class="line">         -o       - overwrite output files without confirmation</div><div class="line">                  //发送反编译代码到标准输出 STDOUT (e.g., for piping)</div><div class="line">         -p       - send all output to STDOUT (for piping)</div><div class="line">                  //在生成源代码时将所有的包加前缀</div><div class="line">         -pa &lt;pfx&gt;- prefix for all packages in generated source files</div><div class="line">                  //用数字名字给所有的类加前缀 (default: _cls)</div><div class="line">         -pc &lt;pfx&gt;- prefix for classes with numerical names (default: _cls)</div><div class="line">                  //给没有用到的异常的名字加前缀</div><div class="line">         -pe &lt;pfx&gt;- prefix for unused exception names (default: _ex)</div><div class="line">                  //用数字名字给所有的成员变量加前缀 (default: _fld)</div><div class="line">         -pf &lt;pfx&gt;- prefix for fields with numerical names (default: _fld)</div><div class="line">                  //在&lt;num&gt; 的导入之后将其他引用包裹成一行导入 (default: 3)</div><div class="line">         -pi&lt;num&gt; - pack imports into one line using .* (packimports)</div><div class="line">                  //给局部变量用数字名字加前缀 (default: _lcl)</div><div class="line">         -pl &lt;pfx&gt;- prefix for locals with numerical names (default: _lcl)</div><div class="line">                  //给方法用数字名字加前缀 (default: _mth)  </div><div class="line">         -pm &lt;pfx&gt;- prefix for methods with numerical names (default: _mth)</div><div class="line">                  //给方法的参数用数字名字加前缀 (default: _prm)</div><div class="line">         -pp &lt;pfx&gt;- prefix for method parms with numerical names (default:_prm)</div><div class="line">                  //将同类型的成员包裹成一行 (default: no)</div><div class="line">         -pv&lt;num&gt; - pack fields with the same types into one line (packfields)</div><div class="line">                  //恢复包的目录结构</div><div class="line">         -r       - restore package directory structure</div><div class="line">                  //指定输出文件的类型 (by default &apos;.jad&apos;)</div><div class="line">         -s &lt;ext&gt; - output file extension (default: .jad)</div><div class="line">                  //遇到关键字(if/for/while/etc)输出空格和表达式 (default: off)</div><div class="line">         -space   - output space between keyword (if, while, etc) and expression</div><div class="line">                  //显示所有的类，方法，成员变量的总数</div><div class="line">         -stat    - show the total number of processed classes/methods/fields</div><div class="line">                  //用 &lt;num&gt;个的空格 (default: 4)</div><div class="line">         -t&lt;num&gt;  - use &lt;num&gt; spaces for indentation (default: 4)</div><div class="line">                  //用tabs代替空格对于边缘</div><div class="line">         -t       - use tabs instead of spaces for indentation</div><div class="line">                  //正在反编译的时候 显示方法的名字 </div><div class="line">         -v       - show method names while decompiling</div><div class="line">                  //将 UNICODE strings 转换成 8-bit strings，用当前的 ANSI 码页 (Win32 only)</div><div class="line">         -8       - convert Unicode strings into ANSI strings (ansi)</div><div class="line">                  //重新定向 STDERR to STDOUT (Win32 only)</div><div class="line">         -&amp;       - redirect STDERR to STDOUT</div></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;jad&lt;/code&gt;是最简单的字节码&lt;code&gt;.class&lt;/code&gt;反编译出源码&lt;code&gt;.java&lt;/code&gt;的小工具。&lt;br&gt;是&lt;code&gt;jdk&lt;/code&gt;自带的，我的在&lt;code&gt;‪D:\Java\jdk1.7.0_80\bin\j
      
    
    </summary>
    
      <category term="小工具" scheme="http://yoursite.com/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/java/"/>
    
    
      <category term="反编译" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
      <category term="jad" scheme="http://yoursite.com/tags/jad/"/>
    
  </entry>
  
  <entry>
    <title>抽象类（abstract class）和接口（interface）解析</title>
    <link href="http://yoursite.com/2017/11/05/abstract-and-interface/"/>
    <id>http://yoursite.com/2017/11/05/abstract-and-interface/</id>
    <published>2017-11-05T11:03:12.000Z</published>
    <updated>2017-11-07T15:12:50.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>抽象类</strong>：<em>包含抽象方法的类就称为 抽象类</em>；<br><strong>接口</strong>： <em>抽象方法的集合，方法没有具体实现即不包含方法体</em>。</p><hr><h2 id="两者异同"><a href="#两者异同" class="headerlink" title="两者异同"></a>两者异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都<code>不能</code>被实例化；</li><li><code>接口的实现类</code>或<code>抽象类的子类</code>都<strong>必须实现</strong><code>接口</code>或<code>抽象类中</code>的方法后才能被实例化</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li><code>接口</code>中的方法是高度抽象的，<em>只有定义，没有具体的实现</em>；<code>抽象类</code>中<em>可以有定义也可以有实现</em>；</li><li><code>接口</code>中的方法默认为<code>public abstract</code>， 可以直接写<code>public</code>， 可以都省略不写；<code>接口</code>中方法修饰符不能是<code>private</code>， 接口需要实现，所以私有的方法没有意义；<code>抽象类</code>中的具体实现的方法和普通的类一样，而只有定义的方法必须用<code>abstract</code>修饰，不然<code>编译不通过</code>；而且<code>抽象方法</code>的修饰符不能是<code>private</code>，<code>static</code>，<code>synchronized</code>，<code>native</code>，能用<code>默认的</code>，<code>public</code>和<code>protected</code>。</li><li><code>接口</code>中定义变量默认为<code>public static final</code>， 并且要赋予<code>初始值</code>，不然编译不通过；<code>抽象类</code>和普通的类一样，可以有自己的成员变量，可以重新赋值；</li><li><code>接口</code>需要<code>实现（implements）</code>， <code>抽象类</code>需要<code>继承（extends）</code>，<em>一个类可以实现多个接口，但是只能继承一个抽象类（单继承多实现）</em>。</li></ol><h2 id="接口三问"><a href="#接口三问" class="headerlink" title="接口三问"></a>接口三问</h2><h3 id="接口方法能否用private修饰"><a href="#接口方法能否用private修饰" class="headerlink" title="接口方法能否用private修饰"></a>接口方法能否用<code>private</code>修饰</h3><blockquote><p>不能。因为接口是对外开放的，需要具体的类来实现其中的方法，私有的方法作用范围为本类，在接口中定义私有方法没有任何意义，编译不会通过。</p></blockquote><h3 id="接口方法能否用synchronized修饰"><a href="#接口方法能否用synchronized修饰" class="headerlink" title="接口方法能否用synchronized修饰"></a>接口方法能否用<code>synchronized</code>修饰</h3><blockquote><p>不能。<code>synchronized</code>是一种<code>同步锁</code>，在修饰方法时，需要具体逻辑，而接口只是定义，因为直接修饰接口中的方法没意义，可以用来修饰接口方法的<code>具体实现</code>。</p></blockquote><h3 id="接口方法能否用static修饰"><a href="#接口方法能否用static修饰" class="headerlink" title="接口方法能否用static修饰"></a>接口方法能否用<code>static</code>修饰</h3><blockquote><p>这和jdk版本有关。jdk8之前：不能；jdk8新特性： 能。<br>——参见<a href="http://letus179.com/2017/11/05/JDK8-static-and-default/" target="_blank" rel="external">JDK8新特性之接口的静态方法和默认方法</a></p></blockquote><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>这里提供两种方式：<code>jad反编译</code>和<code>反射</code>来获取成员变量和方法的相关内容。</p><h3 id="jad反编译"><a href="#jad反编译" class="headerlink" title="jad反编译"></a>jad反编译</h3><p>下面先给出对应源码，再用<code>jad</code>反编译<code>.class</code>文件。反编译执行命令如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java 类名.class</div></pre></td></tr></table></figure></p><p><code>jad</code>详细命令参见<a href="http://letus179.com/2017/11/06/jad-cmd-introduce/" target="_blank" rel="external">反编译小工具：jad常用命令介绍</a></p><h4 id="接口-java源码"><a href="#接口-java源码" class="headerlink" title="接口.java源码"></a>接口.java源码</h4><p><code>MyInterface.java</code>接口源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">  String name = <span class="string">"MyInterface"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="接口-class反编译"><a href="#接口-class反编译" class="headerlink" title="接口.class反编译"></a>接口.class反编译</h4><p><code>MyInterface.class</code>反编译结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"MyInterface"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，</p><p>1.在成员变量（常量）中默认的修饰符是<code>public static final</code>;<br>2.在方法中，默认的修饰符是<code>public abstract</code></p><h4 id="抽象类-java源码"><a href="#抽象类-java源码" class="headerlink" title="抽象类.java源码"></a>抽象类.java源码</h4><p><code>MyAbstract</code>抽象类源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstract</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"MyAbstract get() "</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 抽象类中的没有实现的方法必须是“abstract”</span></div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="抽象类-class反编译"><a href="#抽象类-class反编译" class="headerlink" title="抽象类.class反编译"></a>抽象类.class反编译</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstract</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAbstract</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyAbstract get() "</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，成员方法和成员变量和普通类一样，是什么修饰就是什么。</p><h3 id="反射获取"><a href="#反射获取" class="headerlink" title="反射获取"></a>反射获取</h3><p>这里新建一个<code>MyTest</code>类，<code>继承</code>抽象类<code>MyAbstract</code>，并且<code>实现</code>接口<code>MyInterface</code></p><h4 id="反射代码"><a href="#反射代码" class="headerlink" title="反射代码"></a>反射代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">MyAbstract</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">Field[] abstractFields = MyAbstract.class.getDeclaredFields();</div><div class="line">Method[] abstractMethods = MyAbstract.class.getDeclaredMethods();</div><div class="line"></div><div class="line">System.out.println(<span class="string">"抽象类MyAbstract成员变量反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Field f : abstractFields) &#123;</div><div class="line">System.out.println(<span class="string">"变量名："</span> + f.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(f.getModifiers()));</div><div class="line">System.out.println(<span class="string">"变量类型："</span> + f.getType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"抽象类MyAbstract成员方法反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Method m : abstractMethods) &#123;</div><div class="line">System.out.println(<span class="string">"方法名："</span> + m.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(m.getModifiers()));</div><div class="line">System.out.println(<span class="string">"返回类型："</span> + m.getReturnType()  + <span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Field[] interfaceFields = MyInterface.class.getDeclaredFields();</div><div class="line">Method[] interfaceMethods = MyInterface.class.getDeclaredMethods();</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"接口MyInterface成员变量反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Field f : interfaceFields) &#123;</div><div class="line">System.out.println(<span class="string">"变量名："</span> + f.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(f.getModifiers()));</div><div class="line">System.out.println(<span class="string">"变量类型："</span> + f.getType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"接口MyInterface成员方法反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Method m : interfaceMethods) &#123;</div><div class="line">System.out.println(<span class="string">"方法名："</span> + m.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(m.getModifiers()));</div><div class="line">System.out.println(<span class="string">"返回类型："</span> + m.getReturnType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">抽象类MyAbstract成员变量反射信息：</div><div class="line">变量名：name</div><div class="line">修饰符：public</div><div class="line">变量类型：class java.lang.String</div><div class="line"></div><div class="line">抽象类MyAbstract成员方法反射信息：</div><div class="line">方法名：get</div><div class="line">修饰符：</div><div class="line">返回类型：void</div><div class="line"></div><div class="line">方法名：delete</div><div class="line">修饰符：abstract</div><div class="line">返回类型：void</div><div class="line"></div><div class="line">接口MyInterface成员变量反射信息：</div><div class="line">变量名：name</div><div class="line">修饰符：public static final</div><div class="line">变量类型：class java.lang.String</div><div class="line"></div><div class="line">接口MyInterface成员方法反射信息：</div><div class="line">方法名：add</div><div class="line">修饰符：public abstract</div><div class="line">返回类型：void</div></pre></td></tr></table></figure><p>可以看到，和<code>jad</code>反编译的结果是一样的。</p><p>具体的<code>反射机制</code>请参见另一篇博文<a href="http://letus179.com/2017/11/07/reflect-base/" target="_blank" rel="external">反射机制基础解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;抽象类&lt;/strong&gt;：&lt;em&gt;包含抽象方法的类就称为 抽象类&lt;/em&gt;；&lt;br&gt;&lt;strong&gt;接口&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="抽象类" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="jdk8新特性" scheme="http://yoursite.com/tags/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性之接口的静态方法和默认方法</title>
    <link href="http://yoursite.com/2017/11/05/JDK8-static-and-default/"/>
    <id>http://yoursite.com/2017/11/05/JDK8-static-and-default/</id>
    <published>2017-11-05T10:50:10.000Z</published>
    <updated>2017-11-07T15:21:25.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JDK8之前</strong>我们在接口中定义<code>成员变量</code>只能是<code>public static final</code>的，定义的<code>成员方法</code>只能是<code>public abstract</code>的，默认省略。JDK8前后这一概念等价。定义接口<code>BeforeJDK8Interface</code>如下：<br><code>name</code>和<code>name1</code>表述等价，<code>getName()</code>和<code>getName1()</code>表述等价。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeJDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">    String name = <span class="string">"BeforeJDK8Interface"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//public、 static、 final 可以单独使用，也可以组合使用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name1 = <span class="string">"BeforeJDK8Interface"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//public、 abstract 可以单独使用，也可以组合使用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getName1</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>JDK8新增特性</strong>，允许我们在接口中定义<strong>default默认方法</strong>和<strong>static静态方法</strong>。定义接口<code>JDK8Interface</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">myDefaultMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"JDK8新特性:接口中的默认方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myStaticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"JDK8新特性：接口中的静态方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实现接口时，这里static方法由于<code>static</code>的原因，属于接口类，只能通过 <em>接口类名直接调用</em>；<br>而default方法，需要 <em>接口实现类实例化后调用</em>。定义接口实现类<code>JDK8InterfaceImpl</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JDK8Interface.myStaticMethod();</div><div class="line"></div><div class="line">        JDK8InterfaceImpl jdk8Interface = <span class="keyword">new</span> JDK8InterfaceImpl();</div><div class="line">        jdk8Interface.myDefaultMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于<code>static</code>的原因，静态方法不能重写；但是default方法却可以，重写<code>myDefaultMethod</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDefaultMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"接口中的default方法不满足需求，需要重写"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里稍注意下，<code>JDK8Interface</code>接口中<code>default</code>方法用了修饰符<code>&quot;default&quot;</code>，这里重写后修饰符是<code>&quot;public&quot;</code></p><p>由于java实行的是<strong>单继承</strong><code>extends</code><strong>多实现</strong><code>implements</code>，那<code>JDK8</code>新增特性中的两个方法有啥要求不？</p><ul><li>首先看看<code>static</code>方法，由于调用static方法时，用的是接口类名，不能的接口类名肯定不同，所以<strong>没影响</strong>；</li><li>对于<code>default</code>方法， 有于是实现类实例化后调用，若该类有<code>多个接口</code>且接口中有<code>相同名称</code>的default方法，这时候编译器就没办法区分了，<strong>会报错，必须重写default方法</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JDK8之前&lt;/strong&gt;我们在接口中定义&lt;code&gt;成员变量&lt;/code&gt;只能是&lt;code&gt;public static final&lt;/code&gt;的，定义的&lt;code&gt;成员方法&lt;/code&gt;只能是&lt;code&gt;public abstract&lt;/code&gt;的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jdk8新特性" scheme="http://yoursite.com/tags/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="静态方法" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
      <category term="默认方法" scheme="http://yoursite.com/tags/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>重载（Overload）和重写（Override）解析</title>
    <link href="http://yoursite.com/2017/11/02/overload-and-override/"/>
    <id>http://yoursite.com/2017/11/02/overload-and-override/</id>
    <published>2017-11-02T15:23:49.000Z</published>
    <updated>2017-11-06T15:04:27.536Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="重载Overload"><a href="#重载Overload" class="headerlink" title="重载Overload"></a>重载Overload</h3><p>   重载发生在<code>一个类</code>中，<code>同名的方法</code>如果有<code>不同的参数列表</code>（<code>参数类型不同</code>、<code>参数个数不同</code>或者<code>二者都不同</code>）。</p><ul><li>访问修饰符：重载与访问修饰符<code>无关</code> </li><li>返回类型： 重载与返回值<code>无关</code></li><li>方法名： 重载方法名需<code>完全一致</code> </li><li>参数列表： 重载参数列表需<code>完全不同</code></li></ul><h3 id="重写Override"><a href="#重写Override" class="headerlink" title="重写Override"></a>重写Override</h3><p>   发生在<code>子类与父类</code>之间，重写要求子类被重写方法与父类被重写方法有<code>相同的返回类型</code>，比父类被重写方法<code>更好访问</code>，<code>不能</code>比父类被重写方法声明<code>更多的异常</code>（里氏代换原则）。</p><ul><li>访问修饰符：子类的访问修饰符权限 <code>&gt;=</code> 父类的访问修饰符权限 </li><li>返回类型： 子类的返回类型 <code>&lt;=</code> 父类的返回类型 </li><li>方法名： 方法名应<code>完全一致</code> </li><li>参数列表： 参数列表应<code>完全一致</code></li></ul><hr><h2 id="举例String类"><a href="#举例String类" class="headerlink" title="举例String类"></a>举例String类</h2><h3 id="重载例子"><a href="#重载例子" class="headerlink" title="重载例子"></a>重载例子<span id="overload"></span></h3><p><code>String</code>类的<code>构造器</code>重载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>String</code>类的<code>valueOf()方法</code>的重载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(data);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><hr><h3 id="重写例子"><a href="#重写例子" class="headerlink" title="重写例子"></a>重写例子<span id="override"></span></h3><p><code>ArrayList</code>继承了<code>AbstractList</code>类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div></pre></td></tr></table></figure></p><p><code>AbstractList</code>类中有方法<code>add()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    add(size(), e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>ArrayList</code>类中有重写了<code>add()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>面向对象编程有三大特性：<code>封装</code>、<code>继承</code>、<code>多态</code>。</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p></blockquote><p>实现多态的技术称为：<code>动态绑定（dynamic binding）</code><br>多态存在的三个必要条件</p><pre><code>1. 要有继承；2. 要有重写；3. 父类引用指向子类对象。</code></pre><p>根据<code>何时确定</code>执行多态方法中的哪一个，多态分为两种情况：<code>编译时多态</code>和<code>运行时多态</code>。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。</p><h3 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h3><p><a href="#overload">重载</a>都是<code>编译时多态</code>，从上面的分析可以看到，只要确定了方法参数的<code>数据类型</code>,<code>个数</code>,<code>次序</code>就能确定调用哪一个方法。</p><h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><p><a href="#override">重写</a>有两种多态性，当对象引用<code>本类</code>实例，此时为<code>编译时多态</code>，能在编译期确定调用哪个方法；否则为<code>运行时多态</code>。</p><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Animal"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Dog"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>1.执行下面的main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Animal();</div><div class="line">Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(animal.getName());</div><div class="line">System.out.println(dog.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal</div><div class="line">Dog</div></pre></td></tr></table></figure></p><p><code>Animal</code>和<code>Dog</code>引用的都是<code>本类的实例</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal animal = <span class="keyword">new</span> Animal();</div><div class="line">Dog dog = <span class="keyword">new</span> Dog();</div></pre></td></tr></table></figure></p><p>2.若是这样呢？输入结果是多少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(animal.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dog</div></pre></td></tr></table></figure></p><p>程序在运行时，会从实例<code>所属的类</code>开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照<code>继承关系</code>逐层向上查找，直到超级父类<code>Object类</code>。<br>该例子<code>animal.getName()</code>执行过程是：<br><img src="/2017/11/02/overload-and-override/查找匹配执行方法流程.png" alt="logo"></p><p>3.修改<code>Animal</code>类, 空类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时执行方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(((Dog) animal).getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要显示地转换下<code>((Dog) animal).getName()</code>,因为<code>Animal</code>类中没有定义<code>getName()</code>方法。</p><p>4.修改<code>Animal</code>,<code>Dog</code>类的<code>getName()</code>方法为<code>静态方法</code>,并增加一<code>成员变量name</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> String name = <span class="string">"a"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Animal"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> String name = <span class="string">"d"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Dog"</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>执行main方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">  System.out.println(animal.getName());</div><div class="line">  System.out.println(animal.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal</div><div class="line">a</div></pre></td></tr></table></figure></p><p>结果解释：<br>1.<a href="#override">重写</a>只使用于<code>实例方法</code>，不能用于<code>静态方法</code>，对于<code>static方法</code>，只能<code>隐藏</code>,<a href="#overload">重载</a>,<code>继承</code>；<br>2.在利用引用<code>animal</code>访问对象的属性<code>name</code>或静态方法<code>getName()</code>时，是引用类型决定了实际上访问的是哪个对象（<code>Animal</code>）的成员，而不是当前引用代表的那个类（<code>new Dog()</code>）;<br>由此可知，子类静态方法并<code>不能</code><a href="#override">重写</a>（<code>覆盖</code>）父类的静态方法;故而输出的结果都是父类的成员结果。</p><h2 id="为什么不能根据返回类型来区分重载"><a href="#为什么不能根据返回类型来区分重载" class="headerlink" title="为什么不能根据返回类型来区分重载"></a>为什么不能根据返回类型来区分重载</h2><p>假设下面的重载方法<code>update</code>能编译通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。<br>方法的<code>返回值</code>,只能作为方法运行之后得一个<code>状态</code>，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的<code>标示</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="重载" scheme="http://yoursite.com/tags/%E9%87%8D%E8%BD%BD/"/>
    
      <category term="重写" scheme="http://yoursite.com/tags/%E9%87%8D%E5%86%99/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="编译时多态" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81/"/>
    
      <category term="运行时多态" scheme="http://yoursite.com/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>int和Integer解析</title>
    <link href="http://yoursite.com/2017/11/02/int-and-Integer/"/>
    <id>http://yoursite.com/2017/11/02/int-and-Integer/</id>
    <published>2017-11-02T10:40:58.000Z</published>
    <updated>2017-11-06T15:04:35.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p></blockquote><p>Java 为每个原始类型提供了包装类型：</p><ul><li>原始类型: <code>boolean</code>，<code>char</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code> </li><li>包装类型：<code>Boolean</code>，<code>Character</code>，<code>Byte</code>，<code>Short</code>，<code>Integer</code>，<code>Long</code>，<code>Float</code>，<code>Double</code></li></ul><hr><h3 id="两个常见的面试例子"><a href="#两个常见的面试例子" class="headerlink" title="两个常见的面试例子"></a>两个常见的面试例子</h3><p>先看两个常见的例子，后面会针对例子加以分析。<br><strong><span id="jump_eg1">例1</span></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">        Integer b = <span class="number">8</span>;                  </div><div class="line">        <span class="keyword">int</span> c = <span class="number">8</span>;</div><div class="line">        System.out.println(a == b);     </div><div class="line">        System.out.println(a == c);     </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行结果： false, true</div></pre></td></tr></table></figure><p><strong><span id="jump_eg2">例2</span></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">250</span>, f4 = <span class="number">250</span>;</div><div class="line">      System.out.println(f1 == f2);</div><div class="line">      System.out.println(f3 == f4);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行结果： true, false</div></pre></td></tr></table></figure><hr><h3 id="知识点一：自动拆箱与自动包装"><a href="#知识点一：自动拆箱与自动包装" class="headerlink" title="知识点一：自动拆箱与自动包装"></a><strong>知识点一：自动拆箱与自动包装</strong></h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>1.自动拆箱： 自动将<em>包装器类型</em>转换为<em>基本数据类型</em>；</p><p>2.自动包装： 自动将<em>基本数据类型</em>转换为<em>包装器类型</em>。</p><h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a><strong>具体分析</strong></h4><p><a href="#jump_eg1">例1</a>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;    <span class="comment">//自动装箱</span></div><div class="line"><span class="comment">//Integer a = new Integer(8);</span></div><div class="line"><span class="comment">//int c = 8;</span></div><div class="line">System.out.println(a == c) <span class="comment">// 自动拆箱</span></div></pre></td></tr></table></figure></p><p><strong>注意</strong>：<br>Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是<code>intValue()</code>方法。</p><p>对<a href="#jump_eg1">例1</a>反编译看看(这里用<code>jad</code>来反编译), <code>Test</code>是例子中的类名。<br>下面命令将<strong><code>输出带字节码注释和源码</code></strong> </p><ul><li><code>-a</code>表示<code>用JVM字节格式来注解输出</code>;</li><li><code>-o</code>表示<code>无需确认直接覆盖输出</code>;</li><li><code>-s</code>表示<code>定义输出文件的扩展名</code>,默认的扩展名是<code>jad</code>;</li><li><code>java</code>表示我们想要的反编译后输出<code>java</code>格式文件</li></ul><p><code>jad</code>详细命令参见<a href="http://letus179.com/2017/11/06/jad-cmd-introduce/" target="_blank" rel="external">反编译小工具：jad常用命令介绍</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java Test.class</div></pre></td></tr></table></figure></p><p>反编译结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.PrintStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//    0    0:aload_0         </span></div><div class="line">    <span class="comment">//    1    1:invokespecial   #8   &lt;Method void Object()&gt;</span></div><div class="line">    <span class="comment">//    2    4:return          </span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">    <span class="comment">//    0    0:new             #16  &lt;Class Integer&gt;</span></div><div class="line">    <span class="comment">//    1    3:dup             </span></div><div class="line">    <span class="comment">//    2    4:bipush          8</span></div><div class="line">    <span class="comment">//    3    6:invokespecial   #18  &lt;Method void Integer(int)&gt;</span></div><div class="line">    <span class="comment">//    4    9:astore_1        </span></div><div class="line">    Integer b = Integer.valueOf(<span class="number">8</span>);</div><div class="line">    <span class="comment">//    5   10:bipush          8</span></div><div class="line">    <span class="comment">//    6   12:invokestatic    #21  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">    <span class="comment">//    7   15:astore_2        </span></div><div class="line">    <span class="keyword">int</span> c = <span class="number">8</span>;</div><div class="line">    <span class="comment">//    8   16:bipush          8</span></div><div class="line">    <span class="comment">//    9   18:istore_3        </span></div><div class="line">    System.out.println(a == b);</div><div class="line">    <span class="comment">//   10   19:getstatic       #25  &lt;Field PrintStream System.out&gt;</span></div><div class="line">    <span class="comment">//   11   22:aload_1         </span></div><div class="line">    <span class="comment">//   12   23:aload_2         </span></div><div class="line">    <span class="comment">//   13   24:if_acmpne       31</span></div><div class="line">    <span class="comment">//   14   27:iconst_1        </span></div><div class="line">    <span class="comment">//   15   28:goto            32</span></div><div class="line">    <span class="comment">//   16   31:iconst_0        </span></div><div class="line">    <span class="comment">//   17   32:invokevirtual   #31  &lt;Method void PrintStream.println(boolean)&gt;</span></div><div class="line">    System.out.println(a.intValue() == c);</div><div class="line">    <span class="comment">//   18   35:getstatic       #25  &lt;Field PrintStream System.out&gt;</span></div><div class="line">    <span class="comment">//   19   38:aload_1         </span></div><div class="line">    <span class="comment">//   20   39:invokevirtual   #37  &lt;Method int Integer.intValue()&gt;</span></div><div class="line">    <span class="comment">//   21   42:iload_3         </span></div><div class="line">    <span class="comment">//   22   43:icmpne          50</span></div><div class="line">    <span class="comment">//   23   46:iconst_1        </span></div><div class="line">    <span class="comment">//   24   47:goto            51</span></div><div class="line">    <span class="comment">//   25   50:iconst_0        </span></div><div class="line">    <span class="comment">//   26   51:invokevirtual   #31  &lt;Method void PrintStream.println(boolean)&gt;</span></div><div class="line">    <span class="comment">//   27   54:return          </span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到第<code>20</code>, <code>22</code>行，调用了Integer方法<code>.valueOf(int)</code><strong>自动装箱</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = Integer.valueOf(<span class="number">8</span>);</div></pre></td></tr></table></figure><p><span id="jump_1"></span>第<code>36</code>行,调用了Integer方法<code>.intValue()</code><strong>自动拆箱</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(a == c);</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(a.intValue() == c);</div></pre></td></tr></table></figure><p>所以：<code>a == c</code>的结果为<code>true</code></p><p><a href="#jump_eg1">例1</a>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">Integer b = <span class="number">8</span>;</div><div class="line">System.out.println(a == b);</div></pre></td></tr></table></figure></p><p>结果为何为<code>false</code>？</p><p>刚讲到了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;</div></pre></td></tr></table></figure></p><p>调用了Integer方法<code>.valueOf(int)</code>自动装箱，我们来看下<code>.valueOf(int)</code>源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>也就是说最后会<code>new</code>出来一个Integer对象或者返回<code>缓存</code>中的数据。<br><strong>注意：</strong></p><ul><li><code>==</code>符号在<code>比较对象</code>时，比较的是<code>内存地址</code>;</li><li>对于<code>原始数据类型</code>(如上面<a href="#jump_1"><code>a == c</code></a>)直接比对的是<code>数据值</code>。</li></ul><p>这里又涉及到了<strong><code>堆栈内存</code></strong>了，需要清楚2点：</p><ol><li><code>new</code>出来的对象或创建的<code>数组</code>会在<code>堆</code>中开辟内存空间；</li><li><code>对象的引用</code>（即对象在<code>堆内存</code>中的地址，如<code>a</code>）和<code>基本数据类型</code>存储在<code>栈</code>中；</li></ol><p>由此可知<code>a</code>,<code>b</code>引用指向的对象不是同一个，所以结果是<code>false</code></p><hr><h3 id="知识点二：Integer缓存"><a href="#知识点二：Integer缓存" class="headerlink" title="知识点二：Integer缓存"></a><strong>知识点二：Integer缓存</strong></h3><p>在上面的<code>.valueOf(int)</code>源码中我们能看到<code>IntegerCache</code>类，看名称就知道是和<code>缓存</code>有关。我们来看下<code>Integer</code>类的静态内部类<code>IntegerCache</code>源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// high value may be configured by property</span></div><div class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">        String integerCacheHighPropValue =</div><div class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">            i = Math.max(i, <span class="number">127</span>);</div><div class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        high = h;</div><div class="line"></div><div class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> j = low;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该类中有一个<code>静态数组</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div></pre></td></tr></table></figure></p><p>还有一个<code>静态代码块</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;...&#125;</div></pre></td></tr></table></figure></p><p>既然是在<code>static</code>静态类的<code>静态代码快</code>中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到<code>静态代码快</code>主要是向<code>静态数组</code>中添加了<code>[-128,127]</code>,也就要是说，调用方法<code>.valueOf(int)</code>传入的<code>int</code>值在<code>[-128,127]</code>这个范围内时，直接从<code>IntegerCache</code>的缓存数组中获取， 不会去在堆内存中<code>new</code>。</p><p><code>[-128,127]</code>期间的数字比较常用，这一行为<strong>有助于节省内存、提高性能。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">       <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div></pre></td></tr></table></figure><p>所以在<a href="#jump_eg2">例2</a>中：<br>1.<code>自动装箱</code>调用方法<code>Integer.valueOf(int)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">       Integer f1 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">   <span class="comment">//    0    0:bipush          100</span></div><div class="line">   <span class="comment">//    1    2:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    2    5:astore_1        </span></div><div class="line">       Integer f2 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">   <span class="comment">//    3    6:bipush          100</span></div><div class="line">   <span class="comment">//    4    8:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    5   11:astore_2        </span></div><div class="line">       Integer f3 = Integer.valueOf(<span class="number">250</span>);</div><div class="line">   <span class="comment">//    6   12:sipush          250</span></div><div class="line">   <span class="comment">//    7   15:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    8   18:astore_3        </span></div><div class="line">       Integer f4 = Integer.valueOf(<span class="number">250</span>);</div><div class="line">   <span class="comment">//    9   19:sipush          250</span></div><div class="line">   <span class="comment">//   10   22:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//   11   25:astore          4</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>2.通过<code>Integer.valueOf(int)</code>内部调用<code>IntegerCache</code>类实现。<br>由于<code>f1</code>,<code>f2</code>对应的基本值在<code>[-128,127]</code>之间，结果返回<code>true</code>;<br>而<code>f3</code>,<code>f4</code>对应的基本值不在范围内，结果返回<code>false</code></p><hr><p>其他的包装类型也可以类似分析，回头再总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从J
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="基本数据类型" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="包装类型" scheme="http://yoursite.com/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="自动包装" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%85%E8%A3%85/"/>
    
      <category term="自动拆箱" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
