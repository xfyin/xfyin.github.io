<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农的春天还没来</title>
  
  <subtitle>等待 突破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-06T15:04:50.218Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>殷学飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>静态static与非静态non-static(变量、方法、内部类)解析</title>
    <link href="http://yoursite.com/2017/11/06/static-and-non-static/"/>
    <id>http://yoursite.com/2017/11/06/static-and-non-static/</id>
    <published>2017-11-06T14:54:16.000Z</published>
    <updated>2017-11-06T15:04:50.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。<br> </p><p align="right">—— <a href="https://baike.baidu.com/item/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/10078563?fr=aladdin" target="_blank" rel="external">Java编程思想</a></p><p></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;一句话描述下：<strong>方便在对象没有创建的时候调用方法或变量</strong>。<em>很显然，<code>static</code>依赖于<code>类</code>，只要类加载了，就可以使用，而不需要等对象实例化后再调用。</em></p><p>下面具体分析下。</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul><li><code>static</code>修饰的变量，也叫<code>类变量</code>；</li><li>可以直接用<code>类名.变量</code>调用，也可以用<code>对象名.变量</code>调用；</li><li>所有对象的同一个类变量共享同一块内存空间。</li></ul><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul><li>没有<code>static</code>修饰，也就<code>对象变量</code>；</li><li>只能通过<code>对象</code>调用；</li><li>所有对象的同一个类变量共享不同内存空间。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>静态变量是所有对象<strong>共有的</strong>，当某一个对象将它的值改变，此时其他对象去获取时，将得到改变后的值，因为它依赖于<code>类</code>；</li><li>实例变量是每一个对象<strong>私有的</strong>，当某一个对象将它的值改变，此时其他对象去获取时，得到的还是改变前的值，因为它依赖具体的<code>实例</code>；</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>静态变量和非静态变量举例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"静态变量：直接用‘类名.’调用: age = "</span> + StaticTest.age);</div><div class="line"></div><div class="line">    <span class="comment">// 修改静态变量值</span></div><div class="line">    StaticTest.age = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 实例化StaticTest对象</span></div><div class="line">    StaticTest staticTest = <span class="keyword">new</span> StaticTest();</div><div class="line">    System.out.println(<span class="string">"静态变量：通过‘实例化后的对象’调用：age = "</span> + staticTest.age);</div><div class="line">    System.out.println(<span class="string">"实例变量：只能通过‘实例化后的对象’调用：level = "</span> + staticTest.level);</div><div class="line"></div><div class="line">    <span class="comment">// 修改静态变量值</span></div><div class="line">    staticTest.age = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 修改实例变量值</span></div><div class="line">    staticTest.level = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 再实例化一个StaticTest对象</span></div><div class="line">    StaticTest staticTest1 = <span class="keyword">new</span> StaticTest();</div><div class="line">    System.out.println(<span class="string">"静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = "</span> + staticTest1.age);</div><div class="line">    System.out.println(<span class="string">"实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = "</span> + staticTest1.level);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">静态变量：直接用‘类名.’调用: age = 1</div><div class="line">静态变量：通过‘实例化后的对象’调用：age = 2</div><div class="line">实例变量：只能通过‘实例化后的对象’调用：level = 1</div><div class="line">静态变量：前一个对象改变了‘静态变量’的值，该对象获取值为： age = 3</div><div class="line">实例变量：前一个对象改变了‘实例变量’的值，该对象获取值为： level = 1</div></pre></td></tr></table></figure></p><p>结果和前面分析的一致。</p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><code>static</code>修饰的方法，属于<code>类</code>；</li><li>可以直接用<code>类名.方法名</code>调用，也可以用<code>对象名.方法名</code>调用；</li><li>在访问本类成员时，只允许访问<code>静态变量</code>和<code>静态方法</code>，不允许访问<code>实例变量</code>和<code>实例方法</code>；</li><li><code>static</code>块也即静态代码块，只能调用静态方法。</li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li>没有<code>static</code>修饰，属于<code>对象</code>；</li><li>只能通过<code>对象</code>调用；</li><li>实例方法可以访问<code>实例成员</code>，也可访问<code>静态成员</code>；</li><li><code>static</code>块中不能调用实例方法。</li></ul><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 非静态方法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(<span class="keyword">this</span>.level);</div><div class="line">    </div><div class="line">    System.out.println(age);</div><div class="line">    </div><div class="line">    staticMethod();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 静态方法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    System.out.println(age);</div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过</span></div><div class="line">    <span class="comment">//System.out.println(level);</span></div><div class="line"></div><div class="line">    System.out.println(<span class="keyword">new</span> StaticTest().level);</div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过</span></div><div class="line">    <span class="comment">//nonStaticMethod();</span></div><div class="line"></div><div class="line">    <span class="keyword">new</span> StaticTest().nonStaticMethod();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;静态方法在类加载时就创建了，但是非静态方法需要实例化后才能创建，因为<strong>先类加载，再实例化</strong>，所以静态方法中不能直接访问类的成员，只有类实例化后才能访问。</p><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;将一个类的定义放在另一个类的定义内部，就是内部类。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;这里只分析普通内部类和静态内部类的区别，具体关于内部类知识暂时请参见<a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="external">详解内部类</a></p><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><ul><li>不能有静态成员（静态方法，静态变量），否则编译不通过；</li><li>可以访问外部类的所有成员（方法，属性）；</li><li>实例化内部类方法：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1). 先生成一个外部类的对象实例，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass o = <span class="keyword">new</span> OutClass();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2). 通过外部类的对象实例生成内部类对象，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerClass no_static_i = o.new InnerClass();</div></pre></td></tr></table></figure></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ul><li>可以有静态和非静态成员；</li><li>只能访问外部类的静态成员；</li><li>实例化一个静态内部类方法：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1). 不依赖外部类的实例，直接实例化内部类对象，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerStaticClass static_i  = <span class="keyword">new</span> OutClass.InnerStaticClass();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2). 调用静态内部类的方法或变量，通过类名直接调用，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OutClass.InnerStaticClass.static_name;</div><div class="line">OutClass.InnerStaticClass.getName();</div></pre></td></tr></table></figure></p><h3 id="举例及总结"><a href="#举例及总结" class="headerlink" title="举例及总结"></a>举例及总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String outName = <span class="string">"OutClass.outName"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> String staticOutName = <span class="string">"OutClass.staticOutName"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOutName</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(outName);</div><div class="line">    System.out.println(staticOutName);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getOutStaticName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 编译不通过，静态方法不能访问非静态成员</span></div><div class="line">    <span class="comment">//System.out.println(outName);</span></div><div class="line"></div><div class="line">    System.out.println(staticOutName);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 依赖外部类实例，创建非静态内部类</span></div><div class="line">    OutClass o = <span class="keyword">new</span> OutClass();</div><div class="line">    OutClass.InnerClass no_static_i = o.new InnerClass();</div><div class="line">    no_static_i.getInnerName();</div><div class="line"></div><div class="line">    <span class="comment">// 不依赖外部类实例，直接实例化静态内部类</span></div><div class="line">    OutClass.InnerStaticClass static_i = <span class="keyword">new</span> OutClass.InnerStaticClass();</div><div class="line">    static_i.getInnerName();</div><div class="line"></div><div class="line">    <span class="comment">// 通过静态内部类类名直接调用成员变量或方法</span></div><div class="line">    System.out.println(OutClass.InnerStaticClass.staticInnerName);</div><div class="line">    OutClass.InnerStaticClass.getStaticInnerName();</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 非静态内部类</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 编译不通过，普通静态内部类中不能有static变量</span></div><div class="line">    <span class="comment">//static String staticInnerName = "InnerClass.staticInnerName";</span></div><div class="line"></div><div class="line">    <span class="comment">// 编译不通过，普通静态内部类中不能有static方法</span></div><div class="line">    <span class="comment">//public static void getStaticInnerName() &#123;</span></div><div class="line">    <span class="comment">//  System.out.println(staticInnerName);</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line"></div><div class="line">    String innerName = <span class="string">"InnerClass.innerName"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(innerName);</div><div class="line"></div><div class="line">      <span class="comment">// 直接访问外部类成员变量</span></div><div class="line">      System.out.println(outName);</div><div class="line"></div><div class="line">      <span class="comment">// 直接访问外部类静态成员变量</span></div><div class="line">      System.out.println(staticOutName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 静态内部类</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerStaticClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> String staticInnerName = <span class="string">"InnerStaticClass.staticInnerName"</span>;</div><div class="line"></div><div class="line">    String innerName = <span class="string">"InnerStaticClass.innerName"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getStaticInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(staticInnerName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInnerName</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(innerName);</div><div class="line"></div><div class="line">      <span class="comment">// 编译不通过，不能直接反问外部类成员变量</span></div><div class="line">      <span class="comment">//System.out.println(outName);</span></div><div class="line"></div><div class="line">      <span class="comment">// 只能访问外部类静态成员</span></div><div class="line">      System.out.println(staticOutName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="静态" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81/"/>
    
      <category term="非静态" scheme="http://yoursite.com/tags/%E9%9D%9E%E9%9D%99%E6%80%81/"/>
    
      <category term="内部类" scheme="http://yoursite.com/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>反编译小工具：jad常用命令介绍</title>
    <link href="http://yoursite.com/2017/11/06/jad-cmd-introduce/"/>
    <id>http://yoursite.com/2017/11/06/jad-cmd-introduce/</id>
    <published>2017-11-05T16:56:14.000Z</published>
    <updated>2017-11-05T17:13:50.446Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>jad</code>是最简单的字节码<code>.class</code>反编译出源码<code>.java</code>的小工具。<br>是<code>jdk</code>自带的，我的在<code>‪D:\Java\jdk1.7.0_80\bin\jad.exe</code>。</p><hr><h2 id="jad常用命令"><a href="#jad常用命令" class="headerlink" title="jad常用命令"></a>jad常用命令</h2><ul><li><code>-o</code> 不提示，覆盖源文件，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -o example.class</div></pre></td></tr></table></figure></li></ul><p>　若当前目录下有<code>example.jad</code>文件（默认扩展名<code>jad</code>），执行该命令后会覆盖原<code>example.jad</code>文件</p><ul><li><code>-s</code> 指定输出文件的类型，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -s java example.class</div></pre></td></tr></table></figure></li></ul><p>反编译结果以<code>.java</code>为扩展名。</p><ul><li><code>-p</code> 将反编译结果输出到<code>cmd</code>窗口，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -p example.class</div></pre></td></tr></table></figure></li></ul><p>反编译结果直接在<code>cmd</code>界面显示。</p><ul><li><code>&gt;</code> 将反编译结果重定向到文件，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -p example.class &gt; example1.java</div></pre></td></tr></table></figure></li></ul><p>在当前目录下，将<code>example.class</code>反编译后输出到<code>example1.java</code>文件中。</p><ul><li><code>-d</code> 指定反编译的输出文件目录，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -d test example.class</div></pre></td></tr></table></figure></li></ul><p>在当前目录下会产生目录<code>test</code>，里面有<code>example.jad</code>文件</p><p><strong>常用命令组合</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java example.class</div></pre></td></tr></table></figure></p><ul><li>用<code>JVM字节码格式</code>来注解输出(<code>-a</code>)；</li><li>覆盖原文件（<code>-o</code>）；</li><li>以<code>java</code>扩展名输出<code>example</code>文件（<code>-s java</code>）</li></ul><h2 id="jad帮助信息"><a href="#jad帮助信息" class="headerlink" title="jad帮助信息"></a>jad帮助信息</h2><p><code>jad</code>的帮助信息如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">Options: </div><div class="line">                   //用JVM字节格式来注解输出   </div><div class="line">         -a       - generate JVM instructions as comments (annotate) </div><div class="line">                  //同 -a,但是注解的时候用全名称</div><div class="line">         -af      - output fully qualified names when annotating</div><div class="line">                  //输出多于的括号 (e.g., if(a) &#123; b(); &#125;, default: no)</div><div class="line">         -b       - generate redundant braces (braces)</div><div class="line">                  //清除所有的前缀 </div><div class="line">         -clear   - clear all prefixes, including the default ones</div><div class="line">                  //指定输出文件的文件目录</div><div class="line">         -d &lt;dir&gt; - directory for output files</div><div class="line">                  //试图反编译代码的dead 部分(default: no)</div><div class="line">         -dead    - try to decompile dead parts of code (if there are any)</div><div class="line">                  //不用用字节码的方式反编译 (no JAVA source generated)</div><div class="line">         -dis     - disassembler only (disassembler)</div><div class="line">                  //输出整个的名字,无论是类还是方法</div><div class="line">         -f       - generate fully qualified names (fullnames)</div><div class="line">                  //输出类的成员在方法之前 (default: after methods)</div><div class="line">         -ff      - output fields before methods (fieldsfirst)</div><div class="line">                  //输出所有的变量的缺省的最初值</div><div class="line">         -i       - print default initializers for fields (definits)</div><div class="line">                  //将strings分割成指定数目的块的字符 (default: no)</div><div class="line">         -l&lt;num&gt;  - split strings into pieces of max &lt;num&gt; chars (splitstr)</div><div class="line">                  //将输出文件用行号来注解 (default: no)</div><div class="line">         -lnc     - output original line numbers as comments (lnc)</div><div class="line">                  //分割strings用新行字符 newline character (default: no)</div><div class="line">         -nl      - split strings on newline characters (splitstr)</div><div class="line">                  //不要转换java的定义符 (default: do)</div><div class="line">         -noconv  - don&apos;t convert Java identifiers into valid ones (noconv)</div><div class="line">                  //不要生成辅助文件</div><div class="line">         -nocast  - don&apos;t generate auxiliary casts</div><div class="line">                  //不要生成方法的源代码 </div><div class="line">         -nocode  - don&apos;t generate the source code for methods</div><div class="line">                  //不允许空的构造器存在</div><div class="line">         -noctor  - suppress the empty constructors</div><div class="line">                  //不要去检查class文件是否以dos方式写 (CR before NL, default: check)</div><div class="line">         -nodos   - turn off check for class files written in DOS mode</div><div class="line">                  //关掉对内部类的支持 (default: turn on)</div><div class="line">         -noinner - turn off the support of inner classes</div><div class="line">                  //忽略局部变量的表信息</div><div class="line">         -nolvt   - ignore Local Variable Table entries (nolvt)</div><div class="line">                  //不要输出一个新行在打开一个括号之前 (default: do)</div><div class="line">         -nonlb   - don&apos;t insert a newline before opening brace (nonlb)</div><div class="line">                  //无需确认直接覆盖输出 (default: no)</div><div class="line">         -o       - overwrite output files without confirmation</div><div class="line">                  //发送反编译代码到标准输出 STDOUT (e.g., for piping)</div><div class="line">         -p       - send all output to STDOUT (for piping)</div><div class="line">                  //在生成源代码时将所有的包加前缀</div><div class="line">         -pa &lt;pfx&gt;- prefix for all packages in generated source files</div><div class="line">                  //用数字名字给所有的类加前缀 (default: _cls)</div><div class="line">         -pc &lt;pfx&gt;- prefix for classes with numerical names (default: _cls)</div><div class="line">                  //给没有用到的异常的名字加前缀</div><div class="line">         -pe &lt;pfx&gt;- prefix for unused exception names (default: _ex)</div><div class="line">                  //用数字名字给所有的成员变量加前缀 (default: _fld)</div><div class="line">         -pf &lt;pfx&gt;- prefix for fields with numerical names (default: _fld)</div><div class="line">                  //在&lt;num&gt; 的导入之后将其他引用包裹成一行导入 (default: 3)</div><div class="line">         -pi&lt;num&gt; - pack imports into one line using .* (packimports)</div><div class="line">                  //给局部变量用数字名字加前缀 (default: _lcl)</div><div class="line">         -pl &lt;pfx&gt;- prefix for locals with numerical names (default: _lcl)</div><div class="line">                  //给方法用数字名字加前缀 (default: _mth)  </div><div class="line">         -pm &lt;pfx&gt;- prefix for methods with numerical names (default: _mth)</div><div class="line">                  //给方法的参数用数字名字加前缀 (default: _prm)</div><div class="line">         -pp &lt;pfx&gt;- prefix for method parms with numerical names (default:_prm)</div><div class="line">                  //将同类型的成员包裹成一行 (default: no)</div><div class="line">         -pv&lt;num&gt; - pack fields with the same types into one line (packfields)</div><div class="line">                  //恢复包的目录结构</div><div class="line">         -r       - restore package directory structure</div><div class="line">                  //指定输出文件的类型 (by default &apos;.jad&apos;)</div><div class="line">         -s &lt;ext&gt; - output file extension (default: .jad)</div><div class="line">                  //遇到关键字(if/for/while/etc)输出空格和表达式 (default: off)</div><div class="line">         -space   - output space between keyword (if, while, etc) and expression</div><div class="line">                  //显示所有的类，方法，成员变量的总数</div><div class="line">         -stat    - show the total number of processed classes/methods/fields</div><div class="line">                  //用 &lt;num&gt;个的空格 (default: 4)</div><div class="line">         -t&lt;num&gt;  - use &lt;num&gt; spaces for indentation (default: 4)</div><div class="line">                  //用tabs代替空格对于边缘</div><div class="line">         -t       - use tabs instead of spaces for indentation</div><div class="line">                  //正在反编译的时候 显示方法的名字 </div><div class="line">         -v       - show method names while decompiling</div><div class="line">                  //将 UNICODE strings 转换成 8-bit strings，用当前的 ANSI 码页 (Win32 only)</div><div class="line">         -8       - convert Unicode strings into ANSI strings (ansi)</div><div class="line">                  //重新定向 STDERR to STDOUT (Win32 only)</div><div class="line">         -&amp;       - redirect STDERR to STDOUT</div></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;jad&lt;/code&gt;是最简单的字节码&lt;code&gt;.class&lt;/code&gt;反编译出源码&lt;code&gt;.java&lt;/code&gt;的小工具。&lt;br&gt;是&lt;code&gt;jdk&lt;/code&gt;自带的，我的在&lt;code&gt;‪D:\Java\jdk1.7.0_80\bin\j
      
    
    </summary>
    
      <category term="小工具" scheme="http://yoursite.com/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/java/"/>
    
    
      <category term="反编译" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
      <category term="jad" scheme="http://yoursite.com/tags/jad/"/>
    
  </entry>
  
  <entry>
    <title>抽象类（abstract class）和接口（interface）解析</title>
    <link href="http://yoursite.com/2017/11/05/abstract-and-interface/"/>
    <id>http://yoursite.com/2017/11/05/abstract-and-interface/</id>
    <published>2017-11-05T11:03:12.000Z</published>
    <updated>2017-11-06T15:04:16.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>抽象类</strong>：<em>包含抽象方法的类就称为 抽象类</em>；<br><strong>接口</strong>： <em>抽象方法的集合，方法没有具体实现即不包含方法体</em>。</p><hr><h2 id="两者异同"><a href="#两者异同" class="headerlink" title="两者异同"></a>两者异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都<code>不能</code>被实例化；</li><li><code>接口的实现类</code>或<code>抽象类的子类</code>都<strong>必须实现</strong><code>接口</code>或<code>抽象类中</code>的方法后才能被实例化</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li><code>接口</code>中的方法是高度抽象的，<em>只有定义，没有具体的实现</em>；<code>抽象类</code>中<em>可以有定义也可以有实现</em>；</li><li><code>接口</code>中的方法默认为<code>public abstract</code>， 可以直接写<code>public</code>， 可以都省略不写；<code>接口</code>中方法修饰符不能是<code>private</code>， 接口需要实现，所以私有的方法没有意义；<code>抽象类</code>中的具体实现的方法和普通的类一样，而只有定义的方法必须用<code>abstract</code>修饰，不然<code>编译不通过</code>；而且<code>抽象方法</code>的修饰符不能是<code>private</code>，<code>static</code>，<code>synchronized</code>，<code>native</code>，能用<code>默认的</code>，<code>public</code>和<code>protected</code>。</li><li><code>接口</code>中定义变量默认为<code>public static final</code>， 并且要赋予<code>初始值</code>，不然编译不通过；<code>抽象类</code>和普通的类一样，可以有自己的成员变量，可以重新赋值；</li><li><code>接口</code>需要<code>实现（implements）</code>， <code>抽象类</code>需要<code>继承（extends）</code>，<em>一个类可以实现多个接口，但是只能继承一个抽象类（单继承多实现）</em>。</li></ol><h2 id="接口三问"><a href="#接口三问" class="headerlink" title="接口三问"></a>接口三问</h2><h3 id="接口方法能否用private修饰"><a href="#接口方法能否用private修饰" class="headerlink" title="接口方法能否用private修饰"></a>接口方法能否用<code>private</code>修饰</h3><blockquote><p>不能。因为接口是对外开放的，需要具体的类来实现其中的方法，私有的方法作用范围为本类，在接口中定义私有方法没有任何意义，编译不会通过。</p></blockquote><h3 id="接口方法能否用synchronized修饰"><a href="#接口方法能否用synchronized修饰" class="headerlink" title="接口方法能否用synchronized修饰"></a>接口方法能否用<code>synchronized</code>修饰</h3><blockquote><p>不能。<code>synchronized</code>是一种<code>同步锁</code>，在修饰方法时，需要具体逻辑，而接口只是定义，因为直接修饰接口中的方法没意义，可以用来修饰接口方法的<code>具体实现</code>。</p></blockquote><h3 id="接口方法能否用static修饰"><a href="#接口方法能否用static修饰" class="headerlink" title="接口方法能否用static修饰"></a>接口方法能否用<code>static</code>修饰</h3><blockquote><p>这和jdk版本有关。jdk8之前：不能；jdk8新特性： 能。<br>——参见<a href="http://letus179.com/2017/11/05/JDK8-static-and-default/" target="_blank" rel="external">JDK8新特性之接口的静态方法和默认方法</a></p></blockquote><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>这里提供两种方式：<code>jad反编译</code>和<code>反射</code>来获取成员变量和方法的相关内容。</p><h3 id="jad反编译"><a href="#jad反编译" class="headerlink" title="jad反编译"></a>jad反编译</h3><p>下面先给出对应源码，再用<code>jad</code>反编译<code>.class</code>文件。反编译执行命令如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java 类名.class</div></pre></td></tr></table></figure></p><p><code>jad</code>详细命令参见<a href="http://letus179.com/2017/11/06/jad-cmd-introduce/" target="_blank" rel="external">反编译小工具：jad常用命令介绍</a></p><h4 id="接口-java源码"><a href="#接口-java源码" class="headerlink" title="接口.java源码"></a>接口.java源码</h4><p><code>MyInterface.java</code>接口源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">  String name = <span class="string">"MyInterface"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="接口-class反编译"><a href="#接口-class反编译" class="headerlink" title="接口.class反编译"></a>接口.class反编译</h4><p><code>MyInterface.class</code>反编译结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"MyInterface"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，</p><p>1.在成员变量（常量）中默认的修饰符是<code>public static final</code>;<br>2.在方法中，默认的修饰符是<code>public abstract</code></p><h4 id="抽象类-java源码"><a href="#抽象类-java源码" class="headerlink" title="抽象类.java源码"></a>抽象类.java源码</h4><p><code>MyAbstract</code>抽象类源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstract</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"MyAbstract get() "</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 抽象类中的没有实现的方法必须是“abstract”</span></div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="抽象类-class反编译"><a href="#抽象类-class反编译" class="headerlink" title="抽象类.class反编译"></a>抽象类.class反编译</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstract</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAbstract</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyAbstract get() "</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，成员方法和成员变量和普通类一样，是什么修饰就是什么。</p><h3 id="反射获取"><a href="#反射获取" class="headerlink" title="反射获取"></a>反射获取</h3><p>这里新建一个<code>MyTest</code>类，<code>继承</code>抽象类<code>MyAbstract</code>，并且<code>实现</code>接口<code>MyInterface</code></p><h4 id="反射代码"><a href="#反射代码" class="headerlink" title="反射代码"></a>反射代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">MyAbstract</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">Field[] abstractFields = MyAbstract.class.getDeclaredFields();</div><div class="line">Method[] abstractMethods = MyAbstract.class.getDeclaredMethods();</div><div class="line"></div><div class="line">System.out.println(<span class="string">"抽象类MyAbstract成员变量反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Field f : abstractFields) &#123;</div><div class="line">System.out.println(<span class="string">"变量名："</span> + f.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(f.getModifiers()));</div><div class="line">System.out.println(<span class="string">"变量类型："</span> + f.getType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"抽象类MyAbstract成员方法反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Method m : abstractMethods) &#123;</div><div class="line">System.out.println(<span class="string">"方法名："</span> + m.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(m.getModifiers()));</div><div class="line">System.out.println(<span class="string">"返回类型："</span> + m.getReturnType()  + <span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Field[] interfaceFields = MyInterface.class.getDeclaredFields();</div><div class="line">Method[] interfaceMethods = MyInterface.class.getDeclaredMethods();</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"接口MyInterface成员变量反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Field f : interfaceFields) &#123;</div><div class="line">System.out.println(<span class="string">"变量名："</span> + f.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(f.getModifiers()));</div><div class="line">System.out.println(<span class="string">"变量类型："</span> + f.getType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println();</div><div class="line">System.out.println(<span class="string">"接口MyInterface成员方法反射信息："</span>);</div><div class="line"><span class="keyword">for</span> (Method m : interfaceMethods) &#123;</div><div class="line">System.out.println(<span class="string">"方法名："</span> + m.getName());</div><div class="line">System.out.println(<span class="string">"修饰符："</span> + Modifier.toString(m.getModifiers()));</div><div class="line">System.out.println(<span class="string">"返回类型："</span> + m.getReturnType());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">抽象类MyAbstract成员变量反射信息：</div><div class="line">变量名：name</div><div class="line">修饰符：public</div><div class="line">变量类型：class java.lang.String</div><div class="line"></div><div class="line">抽象类MyAbstract成员方法反射信息：</div><div class="line">方法名：get</div><div class="line">修饰符：</div><div class="line">返回类型：void</div><div class="line"></div><div class="line">方法名：delete</div><div class="line">修饰符：abstract</div><div class="line">返回类型：void</div><div class="line"></div><div class="line">接口MyInterface成员变量反射信息：</div><div class="line">变量名：name</div><div class="line">修饰符：public static final</div><div class="line">变量类型：class java.lang.String</div><div class="line"></div><div class="line">接口MyInterface成员方法反射信息：</div><div class="line">方法名：add</div><div class="line">修饰符：public abstract</div><div class="line">返回类型：void</div></pre></td></tr></table></figure><p>可以看到，和<code>jad</code>反编译的结果是一样的。</p><p>具体的<code>反射机制</code>请参见另一篇博文<a href="http://blog.csdn.net/liujiahan629629/article/details/18013523" target="_blank" rel="external">简单聊聊反射机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;抽象类&lt;/strong&gt;：&lt;em&gt;包含抽象方法的类就称为 抽象类&lt;/em&gt;；&lt;br&gt;&lt;strong&gt;接口&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="抽象类" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="jdk8新特性" scheme="http://yoursite.com/tags/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性之接口的静态方法和默认方法</title>
    <link href="http://yoursite.com/2017/11/05/JDK8-static-and-default/"/>
    <id>http://yoursite.com/2017/11/05/JDK8-static-and-default/</id>
    <published>2017-11-05T10:50:10.000Z</published>
    <updated>2017-11-05T10:53:57.278Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JDK8之前</strong>我们在接口中定义<code>成员变量</code>只能是<code>public static final</code>的，定义的<code>成员方法</code>只能是<code>public abstract</code>的，默认省略。JDK8前后这一概念等价。定义接口<code>BeforeJDK8Interface</code>如下：<br><code>name</code>和<code>name1</code>表述等价，<code>getName()</code>和<code>getName1()</code>表述等价。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeJDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">    String name = <span class="string">"BeforeJDK8Interface"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//public、 static、 final 可以单独使用，也可以组合使用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name1 = <span class="string">"BeforeJDK8Interface"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//public、 abstract 可以单独使用，也可以组合使用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getName1</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>JDK8新增特性</strong>，允许我们在接口中定义<strong>default默认方法</strong>和<strong>static静态方法</strong>。定义接口<code>JDK8Interface</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">myDefaultMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"JDK8新特性:接口中的默认方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myStaticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"JDK8新特性：接口中的静态方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实现接口时，这里static方法由于<code>static</code>的原因，属于接口类，只能通过 <em>接口类名直接调用</em>；<br>而default方法，需要 <em>接口实现类实例化后调用</em>。定义接口实现类<code>JDK8InterfaceImpl</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JDK8Interface.myStaticMethod();</div><div class="line"></div><div class="line">        JDK8InterfaceImpl jdk8Interface = <span class="keyword">new</span> JDK8InterfaceImpl();</div><div class="line">        jdk8Interface.myDefaultMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于<code>static</code>的原因，静态方法不能重写；但是default方法却可以，重写<code>myDefaultMethod</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDefaultMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"接口中的default方法不满足需求，需要重写"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里稍注意下，<code>JDK8Interface</code>接口中<code>default</code>方法用了修饰符<code>&quot;default&quot;</code>，这里重写后修饰符是<code>&quot;public&quot;</code></p><p>由于java实行的是<strong>单继承</strong><code>extends</code><strong>多实现</strong><code>implements</code>，那<code>JDK8</code>新增特性中的两个方法有啥要求不？</p><ul><li>首先看看<code>static</code>方法，由于调用static方法时，用的是接口类名，不能的接口类名肯定不同，所以<strong>没影响</strong>；</li><li>对于<code>default</code>方法， 有于是实现类实例化后调用，若该类有<code>多个接口</code>且接口中有<code>相同名称</code>的default方法，这时候编译器就没办法区分了，<strong>会报错，必须重写default方法</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JDK8之前&lt;/strong&gt;我们在接口中定义&lt;code&gt;成员变量&lt;/code&gt;只能是&lt;code&gt;public static final&lt;/code&gt;的，定义的&lt;code&gt;成员方法&lt;/code&gt;只能是&lt;code&gt;public abstract&lt;/code&gt;的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="JDK8新特" scheme="http://yoursite.com/tags/JDK8%E6%96%B0%E7%89%B9/"/>
    
      <category term="静态方法" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
      <category term="默认方法" scheme="http://yoursite.com/tags/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>重载（Overload）和重写（Override）解析</title>
    <link href="http://yoursite.com/2017/11/02/overload-and-override/"/>
    <id>http://yoursite.com/2017/11/02/overload-and-override/</id>
    <published>2017-11-02T15:23:49.000Z</published>
    <updated>2017-11-06T15:04:27.536Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="重载Overload"><a href="#重载Overload" class="headerlink" title="重载Overload"></a>重载Overload</h3><p>   重载发生在<code>一个类</code>中，<code>同名的方法</code>如果有<code>不同的参数列表</code>（<code>参数类型不同</code>、<code>参数个数不同</code>或者<code>二者都不同</code>）。</p><ul><li>访问修饰符：重载与访问修饰符<code>无关</code> </li><li>返回类型： 重载与返回值<code>无关</code></li><li>方法名： 重载方法名需<code>完全一致</code> </li><li>参数列表： 重载参数列表需<code>完全不同</code></li></ul><h3 id="重写Override"><a href="#重写Override" class="headerlink" title="重写Override"></a>重写Override</h3><p>   发生在<code>子类与父类</code>之间，重写要求子类被重写方法与父类被重写方法有<code>相同的返回类型</code>，比父类被重写方法<code>更好访问</code>，<code>不能</code>比父类被重写方法声明<code>更多的异常</code>（里氏代换原则）。</p><ul><li>访问修饰符：子类的访问修饰符权限 <code>&gt;=</code> 父类的访问修饰符权限 </li><li>返回类型： 子类的返回类型 <code>&lt;=</code> 父类的返回类型 </li><li>方法名： 方法名应<code>完全一致</code> </li><li>参数列表： 参数列表应<code>完全一致</code></li></ul><hr><h2 id="举例String类"><a href="#举例String类" class="headerlink" title="举例String类"></a>举例String类</h2><h3 id="重载例子"><a href="#重载例子" class="headerlink" title="重载例子"></a>重载例子<span id="overload"></span></h3><p><code>String</code>类的<code>构造器</code>重载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>String</code>类的<code>valueOf()方法</code>的重载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(data);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><hr><h3 id="重写例子"><a href="#重写例子" class="headerlink" title="重写例子"></a>重写例子<span id="override"></span></h3><p><code>ArrayList</code>继承了<code>AbstractList</code>类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div></pre></td></tr></table></figure></p><p><code>AbstractList</code>类中有方法<code>add()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    add(size(), e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>ArrayList</code>类中有重写了<code>add()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>面向对象编程有三大特性：<code>封装</code>、<code>继承</code>、<code>多态</code>。</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p></blockquote><p>实现多态的技术称为：<code>动态绑定（dynamic binding）</code><br>多态存在的三个必要条件</p><pre><code>1. 要有继承；2. 要有重写；3. 父类引用指向子类对象。</code></pre><p>根据<code>何时确定</code>执行多态方法中的哪一个，多态分为两种情况：<code>编译时多态</code>和<code>运行时多态</code>。顾名思义，如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。</p><h3 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h3><p><a href="#overload">重载</a>都是<code>编译时多态</code>，从上面的分析可以看到，只要确定了方法参数的<code>数据类型</code>,<code>个数</code>,<code>次序</code>就能确定调用哪一个方法。</p><h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><p><a href="#override">重写</a>有两种多态性，当对象引用<code>本类</code>实例，此时为<code>编译时多态</code>，能在编译期确定调用哪个方法；否则为<code>运行时多态</code>。</p><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Animal"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Dog"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>1.执行下面的main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Animal();</div><div class="line">Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(animal.getName());</div><div class="line">System.out.println(dog.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal</div><div class="line">Dog</div></pre></td></tr></table></figure></p><p><code>Animal</code>和<code>Dog</code>引用的都是<code>本类的实例</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal animal = <span class="keyword">new</span> Animal();</div><div class="line">Dog dog = <span class="keyword">new</span> Dog();</div></pre></td></tr></table></figure></p><p>2.若是这样呢？输入结果是多少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(animal.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dog</div></pre></td></tr></table></figure></p><p>程序在运行时，会从实例<code>所属的类</code>开始寻找匹配的方法来执行，若是找不到匹配的方法，会按照<code>继承关系</code>逐层向上查找，直到超级父类<code>Object类</code>。<br>该例子<code>animal.getName()</code>执行过程是：<br><img src="/2017/11/02/overload-and-override/查找匹配执行方法流程.png" alt="logo"></p><p>3.修改<code>Animal</code>类, 空类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此时执行方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">System.out.println(((Dog) animal).getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要显示地转换下<code>((Dog) animal).getName()</code>,因为<code>Animal</code>类中没有定义<code>getName()</code>方法。</p><p>4.修改<code>Animal</code>,<code>Dog</code>类的<code>getName()</code>方法为<code>静态方法</code>,并增加一<code>成员变量name</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> String name = <span class="string">"a"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Animal"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> String name = <span class="string">"d"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Dog"</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>执行main方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Animal animal = <span class="keyword">new</span> Dog();</div><div class="line">  System.out.println(animal.getName());</div><div class="line">  System.out.println(animal.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Animal</div><div class="line">a</div></pre></td></tr></table></figure></p><p>结果解释：<br>1.<a href="#override">重写</a>只使用于<code>实例方法</code>，不能用于<code>静态方法</code>，对于<code>static方法</code>，只能<code>隐藏</code>,<a href="#overload">重载</a>,<code>继承</code>；<br>2.在利用引用<code>animal</code>访问对象的属性<code>name</code>或静态方法<code>getName()</code>时，是引用类型决定了实际上访问的是哪个对象（<code>Animal</code>）的成员，而不是当前引用代表的那个类（<code>new Dog()</code>）;<br>由此可知，子类静态方法并<code>不能</code><a href="#override">重写</a>（<code>覆盖</code>）父类的静态方法;故而输出的结果都是父类的成员结果。</p><h2 id="为什么不能根据返回类型来区分重载"><a href="#为什么不能根据返回类型来区分重载" class="headerlink" title="为什么不能根据返回类型来区分重载"></a>为什么不能根据返回类型来区分重载</h2><p>假设下面的重载方法<code>update</code>能编译通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当调用new Test().update()时，不需要返回值， 这样就不能区分具体是调用哪个方法了。<br>方法的<code>返回值</code>,只能作为方法运行之后得一个<code>状态</code>，它是保持方法的调用者与被调用者进行通信的关键，并不能作为某个方法的<code>标示</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="重载" scheme="http://yoursite.com/tags/%E9%87%8D%E8%BD%BD/"/>
    
      <category term="重写" scheme="http://yoursite.com/tags/%E9%87%8D%E5%86%99/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="编译时多态" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81/"/>
    
      <category term="运行时多态" scheme="http://yoursite.com/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>int和Integer解析</title>
    <link href="http://yoursite.com/2017/11/02/int-and-Integer/"/>
    <id>http://yoursite.com/2017/11/02/int-and-Integer/</id>
    <published>2017-11-02T10:40:58.000Z</published>
    <updated>2017-11-06T15:04:35.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p></blockquote><p>Java 为每个原始类型提供了包装类型：</p><ul><li>原始类型: <code>boolean</code>，<code>char</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code> </li><li>包装类型：<code>Boolean</code>，<code>Character</code>，<code>Byte</code>，<code>Short</code>，<code>Integer</code>，<code>Long</code>，<code>Float</code>，<code>Double</code></li></ul><hr><h3 id="两个常见的面试例子"><a href="#两个常见的面试例子" class="headerlink" title="两个常见的面试例子"></a>两个常见的面试例子</h3><p>先看两个常见的例子，后面会针对例子加以分析。<br><strong><span id="jump_eg1">例1</span></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">        Integer b = <span class="number">8</span>;                  </div><div class="line">        <span class="keyword">int</span> c = <span class="number">8</span>;</div><div class="line">        System.out.println(a == b);     </div><div class="line">        System.out.println(a == c);     </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行结果： false, true</div></pre></td></tr></table></figure><p><strong><span id="jump_eg2">例2</span></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">250</span>, f4 = <span class="number">250</span>;</div><div class="line">      System.out.println(f1 == f2);</div><div class="line">      System.out.println(f3 == f4);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行结果： true, false</div></pre></td></tr></table></figure><hr><h3 id="知识点一：自动拆箱与自动包装"><a href="#知识点一：自动拆箱与自动包装" class="headerlink" title="知识点一：自动拆箱与自动包装"></a><strong>知识点一：自动拆箱与自动包装</strong></h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>1.自动拆箱： 自动将<em>包装器类型</em>转换为<em>基本数据类型</em>；</p><p>2.自动包装： 自动将<em>基本数据类型</em>转换为<em>包装器类型</em>。</p><h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a><strong>具体分析</strong></h4><p><a href="#jump_eg1">例1</a>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;    <span class="comment">//自动装箱</span></div><div class="line"><span class="comment">//Integer a = new Integer(8);</span></div><div class="line"><span class="comment">//int c = 8;</span></div><div class="line">System.out.println(a == c) <span class="comment">// 自动拆箱</span></div></pre></td></tr></table></figure></p><p><strong>注意</strong>：<br>Integer与int比较时，会把Integer类型变量拆箱成int类型，然后比较。拆箱调用的是<code>intValue()</code>方法。</p><p>对<a href="#jump_eg1">例1</a>反编译看看(这里用<code>jad</code>来反编译), <code>Test</code>是例子中的类名。<br>下面命令将<strong><code>输出带字节码注释和源码</code></strong> </p><ul><li><code>-a</code>表示<code>用JVM字节格式来注解输出</code>;</li><li><code>-o</code>表示<code>无需确认直接覆盖输出</code>;</li><li><code>-s</code>表示<code>定义输出文件的扩展名</code>,默认的扩展名是<code>jad</code>;</li><li><code>java</code>表示我们想要的反编译后输出<code>java</code>格式文件</li></ul><p><code>jad</code>详细命令参见<a href="http://letus179.com/2017/11/06/jad-cmd-introduce/" target="_blank" rel="external">反编译小工具：jad常用命令介绍</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad -a -o -s java Test.class</div></pre></td></tr></table></figure></p><p>反编译结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.PrintStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//    0    0:aload_0         </span></div><div class="line">    <span class="comment">//    1    1:invokespecial   #8   &lt;Method void Object()&gt;</span></div><div class="line">    <span class="comment">//    2    4:return          </span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">    <span class="comment">//    0    0:new             #16  &lt;Class Integer&gt;</span></div><div class="line">    <span class="comment">//    1    3:dup             </span></div><div class="line">    <span class="comment">//    2    4:bipush          8</span></div><div class="line">    <span class="comment">//    3    6:invokespecial   #18  &lt;Method void Integer(int)&gt;</span></div><div class="line">    <span class="comment">//    4    9:astore_1        </span></div><div class="line">    Integer b = Integer.valueOf(<span class="number">8</span>);</div><div class="line">    <span class="comment">//    5   10:bipush          8</span></div><div class="line">    <span class="comment">//    6   12:invokestatic    #21  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">    <span class="comment">//    7   15:astore_2        </span></div><div class="line">    <span class="keyword">int</span> c = <span class="number">8</span>;</div><div class="line">    <span class="comment">//    8   16:bipush          8</span></div><div class="line">    <span class="comment">//    9   18:istore_3        </span></div><div class="line">    System.out.println(a == b);</div><div class="line">    <span class="comment">//   10   19:getstatic       #25  &lt;Field PrintStream System.out&gt;</span></div><div class="line">    <span class="comment">//   11   22:aload_1         </span></div><div class="line">    <span class="comment">//   12   23:aload_2         </span></div><div class="line">    <span class="comment">//   13   24:if_acmpne       31</span></div><div class="line">    <span class="comment">//   14   27:iconst_1        </span></div><div class="line">    <span class="comment">//   15   28:goto            32</span></div><div class="line">    <span class="comment">//   16   31:iconst_0        </span></div><div class="line">    <span class="comment">//   17   32:invokevirtual   #31  &lt;Method void PrintStream.println(boolean)&gt;</span></div><div class="line">    System.out.println(a.intValue() == c);</div><div class="line">    <span class="comment">//   18   35:getstatic       #25  &lt;Field PrintStream System.out&gt;</span></div><div class="line">    <span class="comment">//   19   38:aload_1         </span></div><div class="line">    <span class="comment">//   20   39:invokevirtual   #37  &lt;Method int Integer.intValue()&gt;</span></div><div class="line">    <span class="comment">//   21   42:iload_3         </span></div><div class="line">    <span class="comment">//   22   43:icmpne          50</span></div><div class="line">    <span class="comment">//   23   46:iconst_1        </span></div><div class="line">    <span class="comment">//   24   47:goto            51</span></div><div class="line">    <span class="comment">//   25   50:iconst_0        </span></div><div class="line">    <span class="comment">//   26   51:invokevirtual   #31  &lt;Method void PrintStream.println(boolean)&gt;</span></div><div class="line">    <span class="comment">//   27   54:return          </span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到第<code>20</code>, <code>22</code>行，调用了Integer方法<code>.valueOf(int)</code><strong>自动装箱</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = Integer.valueOf(<span class="number">8</span>);</div></pre></td></tr></table></figure><p><span id="jump_1"></span>第<code>36</code>行,调用了Integer方法<code>.intValue()</code><strong>自动拆箱</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(a == c);</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(a.intValue() == c);</div></pre></td></tr></table></figure><p>所以：<code>a == c</code>的结果为<code>true</code></p><p><a href="#jump_eg1">例1</a>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">8</span>);</div><div class="line">Integer b = <span class="number">8</span>;</div><div class="line">System.out.println(a == b);</div></pre></td></tr></table></figure></p><p>结果为何为<code>false</code>？</p><p>刚讲到了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer b = <span class="number">8</span>;</div></pre></td></tr></table></figure></p><p>调用了Integer方法<code>.valueOf(int)</code>自动装箱，我们来看下<code>.valueOf(int)</code>源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>也就是说最后会<code>new</code>出来一个Integer对象或者返回<code>缓存</code>中的数据。<br><strong>注意：</strong></p><ul><li><code>==</code>符号在<code>比较对象</code>时，比较的是<code>内存地址</code>;</li><li>对于<code>原始数据类型</code>(如上面<a href="#jump_1"><code>a == c</code></a>)直接比对的是<code>数据值</code>。</li></ul><p>这里又涉及到了<strong><code>堆栈内存</code></strong>了，需要清楚2点：</p><ol><li><code>new</code>出来的对象或创建的<code>数组</code>会在<code>堆</code>中开辟内存空间；</li><li><code>对象的引用</code>（即对象在<code>堆内存</code>中的地址，如<code>a</code>）和<code>基本数据类型</code>存储在<code>栈</code>中；</li></ol><p>由此可知<code>a</code>,<code>b</code>引用指向的对象不是同一个，所以结果是<code>false</code></p><hr><h3 id="知识点二：Integer缓存"><a href="#知识点二：Integer缓存" class="headerlink" title="知识点二：Integer缓存"></a><strong>知识点二：Integer缓存</strong></h3><p>在上面的<code>.valueOf(int)</code>源码中我们能看到<code>IntegerCache</code>类，看名称就知道是和<code>缓存</code>有关。我们来看下<code>Integer</code>类的静态内部类<code>IntegerCache</code>源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// high value may be configured by property</span></div><div class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">        String integerCacheHighPropValue =</div><div class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">            i = Math.max(i, <span class="number">127</span>);</div><div class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        high = h;</div><div class="line"></div><div class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> j = low;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该类中有一个<code>静态数组</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div></pre></td></tr></table></figure></p><p>还有一个<code>静态代码块</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;...&#125;</div></pre></td></tr></table></figure></p><p>既然是在<code>static</code>静态类的<code>静态代码快</code>中，也就是说在类加载的时候就会执行这部分代码逻辑。我们可以看到<code>静态代码快</code>主要是向<code>静态数组</code>中添加了<code>[-128,127]</code>,也就要是说，调用方法<code>.valueOf(int)</code>传入的<code>int</code>值在<code>[-128,127]</code>这个范围内时，直接从<code>IntegerCache</code>的缓存数组中获取， 不会去在堆内存中<code>new</code>。</p><p><code>[-128,127]</code>期间的数字比较常用，这一行为<strong>有助于节省内存、提高性能。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">       <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div></pre></td></tr></table></figure><p>所以在<a href="#jump_eg2">例2</a>中：<br>1.<code>自动装箱</code>调用方法<code>Integer.valueOf(int)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">       Integer f1 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">   <span class="comment">//    0    0:bipush          100</span></div><div class="line">   <span class="comment">//    1    2:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    2    5:astore_1        </span></div><div class="line">       Integer f2 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">   <span class="comment">//    3    6:bipush          100</span></div><div class="line">   <span class="comment">//    4    8:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    5   11:astore_2        </span></div><div class="line">       Integer f3 = Integer.valueOf(<span class="number">250</span>);</div><div class="line">   <span class="comment">//    6   12:sipush          250</span></div><div class="line">   <span class="comment">//    7   15:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//    8   18:astore_3        </span></div><div class="line">       Integer f4 = Integer.valueOf(<span class="number">250</span>);</div><div class="line">   <span class="comment">//    9   19:sipush          250</span></div><div class="line">   <span class="comment">//   10   22:invokestatic    #16  &lt;Method Integer Integer.valueOf(int)&gt;</span></div><div class="line">   <span class="comment">//   11   25:astore          4</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>2.通过<code>Integer.valueOf(int)</code>内部调用<code>IntegerCache</code>类实现。<br>由于<code>f1</code>,<code>f2</code>对应的基本值在<code>[-128,127]</code>之间，结果返回<code>true</code>;<br>而<code>f3</code>,<code>f4</code>对应的基本值不在范围内，结果返回<code>false</code></p><hr><p>其他的包装类型也可以类似分析，回头再总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从J
      
    
    </summary>
    
      <category term="面试题分析" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/java/"/>
    
    
      <category term="基本数据类型" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="包装类型" scheme="http://yoursite.com/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="自动包装" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%85%E8%A3%85/"/>
    
      <category term="自动拆箱" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
